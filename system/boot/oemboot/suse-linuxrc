#!/bin/bash
#================
# FILE          : linuxrc
#----------------
# PROJECT       : OpenSuSE KIWI Image System
# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH. All rights reserved
#               :
# AUTHOR        : Marcus Schaefer <ms@suse.de>
#               :
# BELONGS TO    : Operating System images
#               :
# DESCRIPTION   : This file is changed to become the real
#               : linuxrc script which is used to prepare the
#               : operating system for the main image
#               :
#               :
# STATUS        : BETA
#----------------
#======================================
# Exports (General)...
#--------------------------------------
export PATH="/sbin:/bin:/usr/sbin:/usr/bin"
export IFS_ORIG=$IFS
export DEBUG=0

#======================================
# Exports (Booting)
#--------------------------------------
export DOMURD_MODULES="xennet xenblk"
export INITRD_MODULES="reiserfs"
export LOCAL_BOOT=no
export systemIntegrity="clean"

#======================================
# Exports (Configuration)
#--------------------------------------
export VMX_SYSTEM="/config.vmxsystem"
export LIVECD_CONFIG=$VMX_SYSTEM
export OEM_PARTITION_CONFIG="/config.oempartition"

#======================================
# Functions...
#--------------------------------------
. /include

#======================================
# Beautify Startup
#--------------------------------------
clear
echo "Loading KIWI OEM Boot-System..."
echo "-------------------------------"

#======================================
# 1) Mounting local file systems
#--------------------------------------
mountSystemFilesystems &>/dev/null
closeKernelConsole

#======================================
# 2) Prepare module load support 
#--------------------------------------
touch /etc/modules.conf
touch /lib/modules/*/modules.dep

#======================================
# 3) run udevd
#--------------------------------------
udevStart

#======================================
# 4) start boot shell
#--------------------------------------
startBlogD
startShell
errorLogStart
openKernelConsole

#======================================
# 5) Include proc/cmdline information
#--------------------------------------
includeKernelParameters
if [ ! -z $UNIONFS_CONFIG ] || [ "$COMBINED_IMAGE" = "local" ];then
	# /.../
	# if the unionfs/combined information is already in place at this
	# stage it comes from the cmdline data which means we are not
	# booting from CD/DVD USB stick but want to boot the local system
	# ----
	export LOCAL_BOOT="yes"   
fi

#======================================
# 6) Including required kernel modules
#--------------------------------------
probeDevices
for module in ehci-hcd uhci-hcd usb_storage sg sd_mod BusLogic;do
	modprobe $module >/dev/null 2>&1
done

#======================================
# 7) Search disks, prefer removable one
#--------------------------------------
if [ ! -f $VMX_SYSTEM ];then
	# /.../
	# installed system: Check for a root device to mount and
	# prefer a USB stick if there is any. Otherwise check for
	# first partition of a disk device. During first boot of
	# the installed system there is only one partition and this
	# initrd is going to be replaced by a later mkinitrd call
	# for unified systems the kiwi initrd is used and the
	# kernel parameters of this initrd defines the missing
	# information. Additionally the partition table is different
	# for unified systems. Therefore we check if the second
	# partition is a squashfs partition and change the root
	# partition name accordingly
	# ----
	if [ -f $OEM_PARTITION_CONFIG ];then
		Echo "Including oem partition info file"
		importFile < $OEM_PARTITION_CONFIG
	fi
	Echo "Searching for disk and root partition"
	USBStickDevice
	if [ $stickFound = 0 ];then
		deviceFound=0
		for deviceRoot in /dev/sda1 /dev/hda1;do
			if mount $deviceRoot /mnt &>/dev/null;then
				deviceFound=1
				umount /mnt
				break
			fi
		done
		if [ $deviceFound = 0 ];then
			systemException \
				"Couldn't find any disk device... abort" \
			"reboot"
		fi
		export deviceDisk=`echo $deviceRoot | tr -d [0-9]`
		export deviceSwap="$deviceDisk"2
		if [ -z "$OEM_WITHOUTHOME" ];then
			export deviceHome="$deviceDisk"3
		fi
	else
		Echo "USB stick found, prefer root on stick"
		export deviceDisk=$stickRoot
		export deviceSwap="$deviceDisk"2
		if [ -z "$OEM_WITHOUTHOME" ];then
			export deviceHome="$deviceDisk"3
		fi
	fi
	probeFileSystem "$deviceDisk"2
	if test "$FSTYPE" = "squashfs";then
		if [ -z "$COMBINED_IMAGE" ];then
			Echo "Unified system detected, adapting root partition"
			export UNIONFS_CONFIG="$deviceDisk"3,"$deviceDisk"2,aufs
		fi
		export deviceRoot="$deviceDisk"2
		export deviceSwap="$deviceDisk"4
	else
		export deviceRoot="$deviceDisk"1
	fi
	Echo "Using root partition $deviceRoot on disk $deviceDisk"
else
	# /.../
	# installation mode: find a usable disk to install the image
	# on. The image is a virtual disk with one partition
	# ----
	Echo "Searching harddrive for installation"
	Echo "Waiting for devices to settle..."
	# ...
	# sleep for a while as I don't know a device to listen on
	# I should be sure all possible devices exist. If there is
	# a better way to make sure _now_ is the best time to search
	# a disk please fixme
	# ---
	sleep 5
	hwinfo="/usr/sbin/hwinfo --disk"
	export deviceDisks=`$hwinfo |\
		grep "Device File:" | cut -f2 -d: | cut -f1 -d"("`
	export deviceDisks=`echo $deviceDisks`
	if [ -z $deviceDisks ];then
		systemException \
			"No hard disk device(s) found... abort" \
		"reboot"
	fi
	Echo "Found following hard disk device(s)"
	count=0
	for i in $deviceDisks;do
		Echo -b "Disk $count -> $i"
		deviceArray[$count]=$i
		count=`expr $count + 1`
	done
	while true;do
		Echo -n "Enter device name to select disk for installation: "
		read deviceInput
		count=0
		for deviceDisk in $deviceDisks;do
			if [ ${deviceArray[$count]} = $deviceInput ];then
				break 2
			fi
			count=`expr $count + 1`
		done
		Echo "Given device is not in the list !"
	done
	Echo "Entering installation mode for disk: $deviceDisk"
fi

#======================================
# 8) Check for vmx system
#--------------------------------------
if [ -f $VMX_SYSTEM ];then
	#======================================
	# 8.1) import vmx configuration file
	#--------------------------------------
	importFile < $VMX_SYSTEM
	#======================================
	# 8.2) check version of installed OS
	#--------------------------------------
	deviceRoot="$deviceDisk"2
	probeFileSystem $deviceRoot
	if test "$FSTYPE" = "unknown";then
		deviceRoot="$deviceDisk"1
		probeFileSystem $deviceRoot
	fi
	if [ "$FSTYPE" = "squashfs" ] && [ -z "$COMBINED_IMAGE" ];then
		export UNIONFS_CONFIG="$deviceDisk"3,"$deviceDisk"2,aufs
	fi
	Echo "Try mounting installed system to check version"
	mountSystem $deviceRoot; updateNeeded
	umountSystem
	if test `getSystemIntegrity 1` = "fine";then
		Echo "Base system is up to date... reboot"
		/sbin/reboot -f -i >/dev/null 2>&1
	fi
	#======================================
	# 8.3) mount CD/DVD/USB stick
	#--------------------------------------
	USBStickDevice
	if [ $stickFound = 0 ];then
		Echo "Search for USB stick failed, checking CD/DVD drive"
		CDMount
	else
		Echo "Found Stick: $stickDevice -> $stickSerial"
		mkdir -p /cdrom && mount $stickDevice /cdrom
	fi
	#======================================
	# 8.4) install disk system
	#--------------------------------------
	# /.../
	# install virtual disk image from the CD/DVD onto the
	# real disk. All data on the disk will be lost
	# ----
	imageZipped="uncompressed"
	imageDevice=$deviceDisk
	field=0
	IFS=";" ; for n in $IMAGE;do
	case $field in
		0) field=1 ;; 
		1) imageName=$n   ; field=2 ;;
		2) imageVersion=$n;
	esac
	done
	imageName="/cdrom/$imageName"
	echo $imageName | grep -qE ".gz$"
	if [ $? = 0 ];then
		imageZipped="compressed"
	fi
	IFS=" "
	if test "$imageZipped" = "compressed"; then
		Echo "Compressed image found"
		test ! -p /dev/compressed_image && mkfifo /dev/compressed_image
		cat /dev/compressed_image | gzip -d > $imageDevice 2>/dev/null &
		imageDevice_orig=$imageDevice
		imageName_orig=$imageName
		imageDevice="/dev/compressed_image"
		imageName="$imageName.gz"
	fi
	Echo "Loading $imageName [$imageDevice]..."
	if ! dd bs=32k if=$imageName of=$imageDevice >/dev/null 2>&1; then
		systemException \
			"Failed to install image: $imageName -> $imageDevice" \
		"reboot"
	fi
	if test "$imageZipped" = "compressed"; then
		imageDevice=$imageDevice_orig
		imageName=$imageName_orig
		rm -f /dev/compressed_image
	fi
	#======================================
	# 8.5) Umount the CD/DVD
	#--------------------------------------
	umount /cdrom
	#======================================
	# 8.6) reread partition table
	#--------------------------------------
	blockdev --rereadpt $deviceDisk
	deviceTest="$deviceDisk"1
	waitForStorageDevice $deviceTest
	if ! sfdisk -s $deviceTest &>/dev/null;then
		systemException \
			"Partition $deviceTest doesn't appear... fatal !" \
		"reboot"
	fi
	#======================================
	# 8.7) find new root partition
	#--------------------------------------
	unset UNIONFS_CONFIG
	deviceRoot="$deviceDisk"2
	probeFileSystem $deviceRoot
	if test "$FSTYPE" = "unknown";then
		deviceRoot="$deviceDisk"1
		probeFileSystem $deviceRoot
	fi
	Echo "Filesystem of root system is: $FSTYPE -> $deviceRoot"
	if [ "$FSTYPE" = "squashfs" ] && [ -z "$COMBINED_IMAGE" ];then
		export UNIONFS_CONFIG="$deviceDisk"3,"$deviceDisk"2,aufs
	fi
	#======================================
	# 8.8) Create md5 version info file
	#--------------------------------------
	if ! mountSystem $deviceRoot;then
		systemException \
			"Couldn't mount installed system... abort" \
		"reboot"
	fi
	updateNeeded initialize
	field=0
	IFS=";" ; for n in $IMAGE;do
	case $field in
		0) field=1 ;;
		1) imageName=$n   ; field=2 ;;
		2) imageVersion=$n
	esac
	done
	atversion="$imageName-$imageVersion"
	versionFile="/mnt/etc/ImageVersion-$atversion"
	md5sum=`getSystemMD5Status 1`
	echo "$atversion $md5sum" > $versionFile
	umountSystem
	#======================================
	# 8.9) reboot system
	#--------------------------------------
	if [ $stickFound = 0 ];then
		Echo "NOTE: Please remove the installation CD before reboot !"
		CDEject
	else
		Echo "NOTE: Please unplug the USB stick before reboot !"
	fi
	systemException \
		"System installation has finished" \
	"reboot"
fi

#======================================
# 9) Probe filesystem of disk device
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	probeFileSystem $deviceRoot
	if [ $FSTYPE = "unknown" ];then
		systemException \
			"Couldn't determine filesystem type... abort" \
		"reboot"
	fi
fi

#======================================
# 10) repartition the disk device
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	#======================================
	# 10.1 calculate amount of swap space
	#--------------------------------------
	mem_size=`grep MemTotal: /proc/meminfo | tr -dc '[0-9]'`
	swapsize=$(( $mem_size *2 / 1024 ))
	if [ ! -z "$OEM_SWAPSIZE" ];then
		swapsize=$OEM_SWAPSIZE
	fi
	Echo "Filesystem of root system is: $FSTYPE -> $deviceRoot"
	if test ! -z $COMBINED_IMAGE;then
		#====================================== 
		# 10.2 check for read-write partition
		#--------------------------------------
		if ! sfdisk -s "$deviceDisk"3 &>/dev/null;then
			Echo "No read-write partition in this split image"
			DONT_PARTITION=1
		fi
		#======================================
		# 10.3 calculate new partition 3 size
		#--------------------------------------
		if [ -z "$DONT_PARTITION" ];then
			swapXMBytes=$swapsize
			diskXMBytes=`sfdisk -s $deviceDisk`
			diskXMBytes=`expr $diskXMBytes / 1024`
			disk1MBytes=`sfdisk -s "$deviceDisk"1`
			disk1MBytes=`expr $disk1MBytes / 1024`
			disk2MBytes=`sfdisk -s "$deviceDisk"2`
			disk2MBytes=`expr $disk2MBytes / 1024`
			disk3MBytes=`sfdisk -s "$deviceDisk"3`
			disk3MBytes=`expr $disk3MBytes / 1024`
			diskXLBytes=`expr $diskXMBytes - $disk1MBytes - $disk2MBytes`
			diskXLBytes=`expr $diskXLBytes - $disk3MBytes`
			diskXABytes=`expr $diskXLBytes - $swapXMBytes`
			if [ $diskXABytes -lt 50 ];then
				# /.../
				# Very small disk which we will not re-partition
				# ----
				Echo "Disk is too small, will not re-partition it"
				DONT_PARTITION=1
			else
				disk3MBytes=`expr $disk3MBytes + $diskXABytes`
			fi
		fi
		if [ -z "$DONT_PARTITION" ];then
			#======================================
			# 10.4 write new partition table
			#--------------------------------------
			# /.../
			# Explanation of the fdisk commands used within the
			# here document below:
			# ----
			# d               # delete xda partition
			# 3               # [ 3 ]
			# n               # create xda partition at same place than xda3
			# p               # primary
			# 3               # [ 3 ]
			#                 # accept old xda3 start block
			# +"disk3MBytes"M # accept new RW device size of disk blocks - swap
			# n               # create xda swap partition
			# p               # primary
			# 4               # [ 4 ]
			#                 # accept start block
			#                 # accept end block
			# t               # change swap system id
			# 4               # [ 4 ]
			# 82              # Linux Swap
			# w               # write partition table
			# ----
			input=/part.input
			rm -f $input
			for cmd in d 3 n p 3 . +"$disk3MBytes"M n p 4 . . t 4 82 w;do
				if [ $cmd = "." ];then
					echo >> $input
					continue
				fi
				echo $cmd >> $input
			done
			Echo "Repartition the disk according to current geometry"
			fdisk $deviceDisk < $input >/dev/null 2>&1
			if test $? != 0; then
				systemException "Failed to create partition table" "reboot"
			fi
		fi
		#======================================
		# 10.5 Update new device names
		#--------------------------------------
		export deviceBoot="$deviceDisk"1
		export deviceRoot="$deviceDisk"2
		export deviceSwap="$deviceDisk"4
		export deviceIOWR="$deviceDisk"3

		#======================================
		# 10.6 Activate swap space
		#--------------------------------------
		if sfdisk -s $deviceSwap &>/dev/null;then
			Echo "Activating swap space on $deviceSwap"
			if ! mkswap $deviceSwap >/dev/null 2>&1;then
				systemException "Failed to create swap signature" "reboot"
			fi
		fi
	else
		if ! test "$FSTYPE" = "squashfs";then
			#======================================
			# 10.2 write new partition table
			#--------------------------------------
			# /.../
			# Explanation of the fdisk commands used within the
			# here document below:
			# ----
			# d              # delete xda partition [ 1 ]
			# n              # create xda partition at same place than xda1
			# p              # primary
			# 2              # [ 2 ]
			# 1              # accept old xda1 start block for xda2
			# +10240M        # accept new root device size of 10GB
			# n              # create xda swap partition
			# p              # primary
			# 1              # [ 1 ]
			#                # accept start block
			# +"$swapsize"M  # accept new swapsize
			# n              # create xda3 home partition
			# p              # primary
			# 3              # [ 3 ]
			#                # accept start block
			#                # accept end block, complete disk
			# t              # change swap system id
			# 1              # [ 1 ]
			# 82             # Linux Swap
			# w              # write partition table
			# ----
			input=/part.input
			rm -f $input
			diskXMBytes=`sfdisk -s $deviceDisk`
			diskXMBytes=`expr $diskXMBytes / 1024`
			disk1MBytes=10240
			if [ ! -z "$OEM_SYSTEMSIZE" ];then
				disk1MBytes=$OEM_SYSTEMSIZE
			fi
			if [ ! -z "$OEM_WITHOUTHOME" ];then
				disk1MBytes=`expr $diskXMBytes - $swapsize`
			fi
			if [ $disk1MBytes -gt $diskXMBytes ];then
				# /.../
				# Very small disk which we will not re-partition
				# ----
				Echo "Disk is too small, will not re-partition it"
				OEM_WITHOUTHOME=1
				DONT_PARTITION=1
			fi
			if [ -z "$DONT_PARTITION" ];then
				if [ ! -z "$OEM_WITHOUTHOME" ];then
					#======================================
					# 10.2.1 without /home partition
					#--------------------------------------
					for cmd in \
						d n p 2 1 +"$disk1MBytes"M \
						n p 1 . +"$swapsize"M \
						t 1 82 w
					do
						if [ $cmd = "." ];then
							echo >> $input
							continue
						fi
						echo $cmd >> $input
					done
				else
					#======================================
					# 10.2.2 with /home partition
					#--------------------------------------
					for cmd in \
						d n p 2 1 +"$disk1MBytes"M \
						n p 1 . +"$swapsize"M \
						n p 3 . . \
						t 1 82 w
					do
						if [ $cmd = "." ];then
							echo >> $input
							continue
						fi
						echo $cmd >> $input
					done
				fi
				Echo "Repartition the disk according to current geometry"
				fdisk $deviceDisk < $input >/dev/null 2>&1
				if test $? != 0; then
					systemException "Failed to create partition table" "reboot"
				fi
			fi
			#======================================
			# 10.3 Update new device names
			#--------------------------------------
			if [ -z "$DONT_PARTITION" ];then
				export deviceRoot="$deviceDisk"2
				export deviceSwap="$deviceDisk"1
			else
				export deviceRoot="$deviceDisk"1
			fi
			if [ -z "$OEM_WITHOUTHOME" ];then
				export deviceHome="$deviceDisk"3
			fi
			#======================================
			# 10.4 Activate swap space
			#--------------------------------------
			if sfdisk -s $deviceSwap &>/dev/null;then
				Echo "Activating swap space on $deviceSwap"
				if ! mkswap $deviceSwap >/dev/null 2>&1;then
					systemException "Failed to create swap signature" "reboot"
				fi
			fi
			#======================================
			# 10.5 Create home file system
			#--------------------------------------
			if [ -z "$OEM_WITHOUTHOME" ];then
				Echo "Creating Home filesystem on $deviceHome"
				if ! mke2fs -j -q $deviceHome >/dev/null 2>&1;then
					systemException "Failed to create home filesystem" "reboot"
				fi
			fi
		else
			#======================================
			# 10.2 calculate end block - swapspace
			#--------------------------------------
			swapXMBytes=$swapsize
			diskXMBytes=`sfdisk -s $deviceDisk`
			diskXMBytes=`expr $diskXMBytes / 1024`
			disk1MBytes=`sfdisk -s "$deviceDisk"1`
			disk1MBytes=`expr $disk1MBytes / 1024`
			disk2MBytes=`sfdisk -s "$deviceDisk"2`
			disk2MBytes=`expr $disk2MBytes / 1024`
			disk3MBytes=`expr $diskXMBytes - $disk1MBytes - $disk2MBytes`
			disk3MBytes=`expr $disk3MBytes - $swapXMBytes`
			if [ $disk3MBytes -lt 100 ];then
				# /.../
				# Very small disk which we will not re-partition
				# ----
				Echo "Disk is too small, will not re-partition it"
				DONT_PARTITION=1
			fi
			if [ -z "$DONT_PARTITION" ];then
				#======================================
				# 10.3 write new partition table
				#--------------------------------------
				# /.../
				# Explanation of the fdisk commands used within the
				# here document below:
				# ----
				# d               # delete xda partition
				# 3               # [ 3 ]
				# n               # create xda partition at same place than xda3
				# p               # primary
				# 3               # [ 3 ]
				#                 # accept old xda3 start block
				# +"disk3MBytes"M # accept new RW device size
				# n               # create xda swap partition
				# p               # primary
				# 4               # [ 4 ]
				#                 # accept start block
				#                 # accept end block
				# t               # change swap system id
				# 4               # [ 4 ]
				# 82              # Linux Swap
				# w               # write partition table
				# ----
				input=/part.input
				rm -f $input
				for cmd in d 3 n p 3 . +"$disk3MBytes"M n p 4 . . t 4 82 w;do
					if [ $cmd = "." ];then
						echo >> $input
						continue
					fi
					echo $cmd >> $input
				done
				Echo "Repartition the disk according to current geometry"
				fdisk $deviceDisk < $input >/dev/null 2>&1
				if test $? != 0; then
					systemException "Failed to create partition table" "reboot"
				fi
			fi
			#======================================
			# 10.4 Update new device names
			#--------------------------------------
			export deviceBoot="$deviceDisk"1
			export deviceRoot="$deviceDisk"2
			export deviceSwap="$deviceDisk"4
			export deviceIOWR="$deviceDisk"3

			#======================================
			# 10.5 Activate swap space
			#--------------------------------------
			if sfdisk -s $deviceSwap &>/dev/null;then
				Echo "Activating swap space on $deviceSwap"
				if ! mkswap $deviceSwap >/dev/null 2>&1;then
					systemException "Failed to create swap signature" "reboot"
				fi
			fi
	
			#======================================
			# 10.6 create filesystem for writing
			#--------------------------------------
			Echo "Creating filesystem for RW data on $deviceIOWR..."
			if ! mke2fs $deviceIOWR >/dev/null;then
				systemException "Failed to create ext2 filesystem" "reboot"
			fi
		fi
	fi
fi

#======================================
# 11) Resize filesystem to full space
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	deviceResize=$deviceRoot
	if [ ! -z $COMBINED_IMAGE ];then
		deviceResize=$deviceIOWR
		KIWI_INITRD_PARAMS="COMBINED_IMAGE=local"
		export KIWI_INITRD_PARAMS
	fi
	if [ "$FSTYPE" = "squashfs" ] && [ -z "$COMBINED_IMAGE" ];then
		export UNIONFS_CONFIG="$deviceDisk"3,"$deviceDisk"2,aufs
		KIWI_INITRD_PARAMS="UNIONFS_CONFIG=\"$UNIONFS_CONFIG\""
		KIWI_INITRD_PARAMS="$KIWI_INITRD_PARAMS deviceRoot=\"$deviceRoot\""
		export KIWI_INITRD_PARAMS
	else
		if sfdisk -s $deviceResize &>/dev/null;then
			if [ "$FSTYPE" = "reiserfs" ];then
				Echo "Resize Reiser filesystem to full partition space..."
				resize_reiserfs -q $deviceResize
				INITRD_MODULES="$INITRD_MODULES reiserfs"
			fi
			if [ "$FSTYPE" = "ext2" ];then
				Echo "Resize EXT2 filesystem to full partition space..."
				resize2fs -f -F -p $deviceResize
				Echo "Checking EXT2 filesystem..."
				e2fsck -y -f $deviceResize
				INITRD_MODULES="$INITRD_MODULES ext2"
			fi
			if [ "$FSTYPE" = "ext3" ];then
				Echo "Resize EXT3 filesystem to full partition space..."
				resize2fs -f -F -p $deviceResize
				Echo "Checking EXT3 filesystem..."
				e2fsck -y -f $deviceResize
				INITRD_MODULES="$INITRD_MODULES ext3"
			fi
		fi
	fi
fi

#======================================
# 12) Mount system
#--------------------------------------
if ! mountSystem $deviceRoot;then
	systemException "Failed to mount root filesystem" "reboot"
fi
validateRootTree

#======================================
# 13) get installed kernels
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	kernelList /mnt
fi

#======================================
# 14) Create system dependant files
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	export HAVE_SWAP=0
	setupDefaultFstab /config
	if sfdisk -s $deviceSwap &>/dev/null;then
		updateSwapDeviceFstab /config $deviceSwap
		HAVE_SWAP=1
	fi
	if [ -z "$UNIONFS_CONFIG" ] && [ -z "$COMBINED_IMAGE" ]; then
		echo "$deviceRoot / $FSTYPE defaults 0 0" >> /config/etc/fstab
		if [ -z "$OEM_WITHOUTHOME" ];then
			if [ `ls /mnt/home/ | wc -l` != 0 ]; then
				Echo "Found non empty home/ directory !"
				Echo "Moving home/ data to home partition $deviceHome"
				mount $deviceHome /mnt/mnt && mv /mnt/home/* /mnt/mnt
				umount /mnt/mnt
			fi
			Echo "Activate home partition $deviceHome in fstab"
			echo "$deviceHome /home ext3 defaults 0 0" >> /config/etc/fstab
		fi
	else
		mkdir -p /config/kiwiboot
		echo "$deviceBoot /kiwiboot ext2 defaults 0 0" >> /config/etc/fstab
	fi
	if [ -z "$UNIONFS_CONFIG" ] && [ -z "$COMBINED_IMAGE" ]; then
		Echo "Creating grub configuration"
		if [ $HAVE_SWAP -eq 1 ];then
			setupBootLoaderGrub /mnt /config 1 ${deviceDisk}2 OEM $deviceSwap
		else
			setupBootLoaderGrub /mnt /config 1 ${deviceDisk}2 OEM
		fi
	fi
	setupKernelModules /config
fi

#======================================
# 15) copy system dependant files
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	cd /config
	find . -type d | while read d ; do  mkdir -p /mnt/$d ; done
	find . -type f | while read f ; do  cp $f /mnt/$f ; done
	cd /
	rm -rf /config
fi

#======================================
# 16) setup real root device
#--------------------------------------
echo 256 > /proc/sys/kernel/real-root-dev

#======================================
# 17) umount system filesystems
#--------------------------------------
umountSystemFilesystems

#======================================
# 18) copy initrd files to image
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	importBranding
	cp /preinit /mnt
	cp /include /mnt
fi

#======================================
# 19) kill boot shell
#--------------------------------------
killShell
killBlogD

#======================================
# 20) Activate new root
#--------------------------------------
Echo "Activating Image: [$deviceDisk]"
reopenKernelConsole
/sbin/udevsettle --timeout=30
mount --move /dev /mnt/dev
udevKill

#======================================
# 21) call preinit phase
#--------------------------------------
Echo "Calling preinit phase..."
cd /mnt
/mnt/sbin/pivot_root . mnt >/dev/null 2>&1
if test $? != 0;then
	PIVOT=false
	cleanInitrd && mount --move . / && chroot . ./preinit
	chroot . rm -f  ./preinit
	chroot . rm -f  ./include
	chroot . rm -rf ./image
else
	PIVOT=true
	./preinit
	rm -f  ./preinit
	rm -f  ./include
	rm -rf ./image
fi

#======================================
# 22 Unmount initrd / system init
#--------------------------------------
echo " "
echo "Booting into final System..."
echo "----------------------------"
export IFS=$IFS_ORIG
mount -n -o remount,rw / 2>/dev/null
if [ ! -z "$OEM_REBOOT" ];then
	Echo "Reboot requested... reboot now"
	/sbin/reboot -f -i >/dev/null 2>&1
fi
if [ $PIVOT = "true" ];then
	exec < dev/console >dev/console 2>&1
	exec umount -n -l /mnt
else
	exec < dev/console >dev/console 2>&1
	exec chroot . /sbin/init $@
fi

