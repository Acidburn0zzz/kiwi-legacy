#!/bin/bash
#================
# FILE          : linuxrc
#----------------
# PROJECT       : OpenSuSE KIWI Image System
# COPYRIGHT     : (c) 2006 SUSE LINUX Products GmbH. All rights reserved
#               :
# AUTHOR        : Marcus Schaefer <ms@suse.de>
#               :
# BELONGS TO    : Operating System images
#               :
# DESCRIPTION   : This file is changed to become the real
#               : linuxrc script which is used to prepare the
#               : operating system for the main image
#               :
#               :
# STATUS        : BETA
#----------------
#======================================
# Exports (General)
#--------------------------------------
export PATH="/sbin:/bin:/usr/sbin:/usr/bin"
export IFS_ORIG=$IFS
export input=/part.input
export ARCH=`arch`
export DEBUG=0

#======================================
# Exports (Booting)
#--------------------------------------
export DOMURD_MODULES="xennet xenblk"
export INITRD_MODULES=""
export LOCAL_BOOT="no"
export KERNEL_LIST

#======================================
# Exports (Alias)
#--------------------------------------
export SYSALIAS="undefined"
export NAME=0

#======================================
# Exports (Status)
#--------------------------------------
export SYSTEM_INTEGRITY
export SYSTEM_MD5STATUS
export systemIntegrity="unknown"
export haveDisk=0

#======================================
# Exports (clicfs usage)
#--------------------------------------
export kiwi_hybrid=yes
export kiwi_hybridpersistent=yes

#======================================
# Functions
#--------------------------------------
. /include
initialize

#======================================
# Beautify Startup
#--------------------------------------
echo "Loading KIWI PXE Boot-System..."
echo "-------------------------------"

#======================================
# Update library path
#--------------------------------------
ldconfig

#======================================
# 1) Mounting local file systems
#--------------------------------------
mountSystemFilesystems &>/dev/null
closeKernelConsole

#======================================
# 2) Prepare module load support 
#--------------------------------------
touch /etc/modules.conf
touch /lib/modules/*/modules.dep
runHook init

#======================================
# 3) run udevd
#--------------------------------------
udevStart

#======================================
# 4) Include proc/cmdline information
#--------------------------------------
includeKernelParameters
if [ ! -z $IMAGE ];then
	# /.../
	# if the image information is already in place at this stage
	# it comes from the cmdline data which means we are not booting
	# from the network but want to boot the local system
	# ----
	LOCAL_BOOT="yes"
fi

#======================================
# 5) start boot shell
#--------------------------------------
startBlogD
startShell
errorLogStart
openKernelConsole

#======================================
# 6) probe/load network module
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	loadNetworkCard
fi

#======================================
# 7) Setup network interface and DNS
#--------------------------------------
runHook prenetwork
if [ $LOCAL_BOOT = "no" ];then
	setupNetwork
fi
runHook postnetwork

#======================================
# 8) get TFTP Server IP/name
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	pxeSetupDownloadServer
fi

#======================================
# 9) Load configuration
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	CONFIG=/etc/config.netclient
	#======================================
	# Store possible values set by cmdline
	#--------------------------------------
	unset ALLOW_CMDLINE_OVERWRITE
	if [ ! -z "$NBDROOT" ];then
		KLIST[0]="NBDROOT=$NBDROOT";
	fi
	#======================================
	# Connection/access check for SERVER
	#--------------------------------------
	Echo "Checking for config file: config.$DHCPCHADDR"
	fetchFile KIWI/config.$DHCPCHADDR $CONFIG
	#======================================
	# Check alternative config names
	#--------------------------------------
	if [ ! -s $CONFIG ] ; then
		searchGroupConfig
	fi
	#======================================
	# Check alternative config names
	#--------------------------------------
	if [ ! -s $CONFIG ];then
		searchAlternativeConfig
	fi
	#======================================
	# try to import configuration
	#--------------------------------------
	IMPORTED=0
	if [ -s $CONFIG ] ;then
		importFile < $CONFIG
		#======================================
		# Check and import Hardware Maps if set
		#--------------------------------------
		searchHardwareMapConfig
		IMPORTED=1
	fi
	#========================================
	# Compare current IP and IP from config 
	#----------------------------------------
	NEWIP=0
	if [ ! -z "$WORKSTATION_LDAP_IP" ]; then
		WSNR=`echo $WORKSTATION_LDAP_IP | sed -r -e 's/(^|\.)0*/\1/g'`
		IPNR=`echo $IPADDR | sed -r -e 's/(^|\.)0*/\1/g'`
		if [ "$WSNR" != "$IPNR" ];then 
			NEWIP=1
		fi
	fi
	#======================================
	# No config found register new client
	#--------------------------------------
	if [ ! -s $CONFIG ];then
		#======================================
		# Register new network client
		#--------------------------------------
		Echo "Registering new network client..."
		pxeSetupSystemAliasName
		pxeSetupSystemHWInfoFile
		pxeSetupSystemHWTypeFile
		#======================================
		# Put files on the boot server
		#--------------------------------------
		putFile hwtype.$DHCPCHADDR upload/hwtype.$DHCPCHADDR
		putFile hwinfo.$DHCPCHADDR upload/hwinfo.$DHCPCHADDR
		echo
		Echo "Registered as: $DHCPCHADDR"
		Echo "Waiting for configuration..."
		sleep 60
		#======================================
		# Wait for configuration (reload)
		#--------------------------------------
		while test ! -s $CONFIG;do
			Echo "Lookup network client config file again..."
			Echo "Checking for config file: config.$DHCPCHADDR"
			dhcpcd -n $PXE_IFACE
			fetchFile KIWI/config.$DHCPCHADDR $CONFIG
			if [ ! -s $CONFIG ] ; then
				searchGroupConfig
			fi
			if test ! -s $CONFIG;then
				searchAlternativeConfig
			fi
			test -s $CONFIG || {
				Echo "Couldn't get image configuration"
				Echo "sleeping [60 sec]..."
				sleep 60
			}
		done
	fi
	#======================================
	# Config found but DHCP IP setup change
	#--------------------------------------
	if [ $NEWIP -eq 1 ];then
		Echo "Outdated IP address, notify new client setup..."
		pxeSetupSystemAliasName
		pxeSetupSystemHWTypeFile
		putFile hwtype.$DHCPCHADDR upload/hwtype.$DHCPCHADDR
		echo
		Echo "Notified: $DHCPCHADDR"
	fi
	#======================================
	# import latest configuration
	#--------------------------------------
	if [ $IMPORTED -eq 0 ];then
		importFile < $CONFIG
		#======================================
		# Check and import Hardware Maps if set
		#--------------------------------------
		searchHardwareMapConfig
		IMPORTED=1
	fi
	#======================================
	# restore values from cmdline
	#--------------------------------------
	if [ ! -z "$ALLOW_CMDLINE_OVERWRITE" ];then
		for i in ${KLIST[@]};do
			eval export \"$i\"
		done
	fi
fi

#======================================
# 10) Load Device modules
#--------------------------------------
runHook preprobe
probeDevices "skipUSB"
runHook postprobe

#======================================
# 11) Check for diskful station
#--------------------------------------
if \
	[ $LOCAL_BOOT = "no" ] && \
	([ ! -z "$PART" ] || [ ! -z "$IMAGE" ]) && \
	[ -z "$NFSROOT" ]      && \
	[ -z "$NBDROOT" ]      && \
	[ -z "$AOEROOT" ]
then
	if ! waitForStorageDevice $DISK;then
		systemException \
			"Disk $DISK doesn't appear... fatal !" \
		"reboot"
	fi
	export haveDisk=1
	export imageDiskDevice=$DISK
fi

#======================================
# 12) Check for installed system
#--------------------------------------
if [ $LOCAL_BOOT = "no" ] && [ $haveDisk = "1" ];then
	IMAGE_FIRST=$(echo $IMAGE | cut -f1 -d,)
	for i in $IMAGE_FIRST;do
		field=0
		IFS=";" ; for n in $i;do
			case $field in
				0) imageDevice=$n ; field=1 ;;
				1) imageName=$n   ; field=2 ;;
				2) imageVersion=$n; field=3
			esac
		done
		updateNeeded initialize
		if linuxPartition $imageDiskDevice;then
			if mountSystem $imageDevice;then
				updateNeeded
				umountSystem
				systemIntegrity=`getSystemIntegrity 1`
				if [ $systemIntegrity = "fine" ];then
					Echo "Base system is up to date, activating disk system..."
				fi
			else
				Echo -b "On-disk Image mount attempt failed,"
				Echo -b "Image Update for image [ $imageName ] needed"
				umountSystem
				RELOAD_IMAGE="yes"
				systemIntegrity="clean"
			fi
		else
			systemIntegrity="clean"
		fi
	done
fi

#======================================
# 13) Create ptable on diskful system
#--------------------------------------
if [ $LOCAL_BOOT = "no" ] && [ $systemIntegrity = "clean" ];then
	runHook prepartition
	#======================================
	# Create partition table
	#--------------------------------------
	Echo "Creating partition table..."
	cleanPartitionTable
	createPartitionerInput $(pxePartitionInput)
	callPartitioner $input
	#======================================
	# Setup swap space if requested
	#--------------------------------------
	export imageSwapDevice=$(pxeSwapDevice)
	if [ ! -z "$imageSwapDevice" ];then
		if ! mkswap $imageSwapDevice 1>&2;then
			systemException "Failed to create swap signature" "reboot"
		fi
	fi
	runHook postpartition
fi

#======================================
# 14) Setup root device environment
#--------------------------------------
runHook predownload
if [ $LOCAL_BOOT = "no" ] && [ $haveDisk = "1" ];then
	#======================================
	# 14.1) Download network client image
	#--------------------------------------
	count=0
	IFS="," ; for i in $IMAGE;do
		imageZipped="uncompressed"
		count=$(($count + 1))
		field=0
		IFS=";" ; for n in $i;do
		case $field in
			0) imageDevice=$n ; field=1 ;;
			1) imageName=$n   ; field=2 ;;
			2) imageVersion=$n; field=3 ;;
			3) imageServer=$n ; field=4 ;;
			4) imageBlkSize=$n; field=5 ;;
			5) imageZipped=$n ;
		esac
		done
		if [ $count = 1 ];then
			imageRootDevice=$imageDevice
			imageRootName=$imageName
		fi
		if [ $count = 2 ];then
			imageNextRootDevice=$imageDevice
		fi
		# /.../
		# start download only if installed system is different
		# from the image on the pxe boot server
		# ---
		if test `getSystemIntegrity $count` = "fine";then
			continue
		fi
		imageName="image/$imageName-$imageVersion"
		imageMD5s="$imageName.md5"
		[ -z "$imageServer" ]  && imageServer=$SERVER
		[ -z "$imageBlkSize" ] && imageBlkSize=8192
		while true;do
			# /.../
			# get image md5sum to be able to check for the size
			# requirements if we are loading into RAM
			# ---
			fetchFile $imageMD5s /etc/image.md5 uncomp $imageServer
			if test $loadCode != 0 || ! loadOK "$loadStatus"; then
				systemException \
					"Download of $imageMD5s failed: $loadStatus" \
				"reboot"
			fi
			IFS=" "
			read sum1 blocks blocksize zblocks zblocksize < /etc/image.md5
			if ! validateSize;then
				systemException \
					"Not enough space available for this image" \
				"reboot"
			fi
			# /.../
			# now load the image into the imageDevice
			# ---
			multicast_old=$multicast
			multicast="enable"
			if test "$imageZipped" = "compressed"; then
				Echo "Compressed image found: Disable multicast download"
				multicast="disable"
			fi
			Echo "Loading $imageName [$imageDevice BS:$imageBlkSize Byte]..."
			fetchFile $imageName $imageDevice $imageZipped $imageServer
			multicast=$multicast_old
			if test $loadCode != 0 || ! loadOK "$loadStatus";then
				systemException \
					"Download of $imageName failed: $loadStatus" \
				"reboot"
			fi
			# /.../
			# check the md5sum of the downloaded data records
			# ----
			Echo "Download complete, checking data..."
			dd if=$imageDevice bs=1024 2>/dev/null |\
				head --bytes=$((blocks * blocksize)) |\
				md5sum - > /etc/ireal.md5
			read sum2 dumy < /etc/ireal.md5
			if test $sum1 = $sum2;then
				Echo "Image checksum test: fine :-)"
				break
			fi
			Echo "Image checksum test failed:"
			Echo "Possible reasons:"
			echo 
			Echo -b "1) Physical ethernet connection lost:"
			Echo -b "   please check cable"
			echo
			Echo -b "2) Data corruption while loading the image:"
			Echo -b "   will give it a new try..."
			echo
			Echo -b "3) wrong checksum file created for the image:"
			Echo -b "   check with the md5sum command if the image on the"
			Echo -b "   TFTP server provides the same md5 sum as included"
			Echo -b "   within the appropriate .md5 file for this image"
			echo
			if test -z $DISK;then
			Echo -b "4) ramdisk size is too small for the image:"
			Echo -b "   check the ramdisk_size parameter of the PXE"
			Echo -b "   configuration file on the TFTP server"
			else
			Echo -b "4) partition size is too small for the image:"
			Echo -b "   check the PART line in the image config file on the"
			Echo -b "   TFTP server"
			fi
			echo
			Echo "Retry to load image..."
			sleep 15
		done
		if test ! -z $DISK;then
			probeFileSystem $imageDevice
			resizeFilesystem $imageDevice
		fi
		rm -f /etc/ireal.md5
		rm -f /etc/image.md5
	done
else
	#======================================
	# 14.2) Check for local boot
	#--------------------------------------
	if [ $LOCAL_BOOT = "yes" ];then
		imageDisk=$(dn $root)
		imageDevice=$(ddn $imageDisk 2)
		imageRootDevice=$imageDevice
		imageRootName="Local-System"
		if [ ! -z "$UNIONFS_CONFIG" ];then
			unionFST=$UNIONFS_CONFIG
			setupUnionFS $(ddn $imageDisk 3) $(ddn $imageDisk 2) $unionFST
		fi
		if [ ! -z "$COMBINED_IMAGE" ];then
			imageNextRootDevice=$(ddn $imageDisk 3)
		fi
	fi
	#======================================
	# 14.3) Check for NFS root
	#--------------------------------------
	if [ ! -z "$NFSROOT" ];then
		IFS="," ; for i in $NFSROOT;do
			field=0
			IFS=";" ; for n in $i;do
			case $field in
				0) nfsRootServer=$n ; field=1 ;;
				1) nfsRootDevice=$n ; field=2
			esac
			done
		done
		for m in nfs lockd sunrpc;do
			modprobe -i $m
		done
		if [ -z "$nfsRootServer" ];then
			nfsRootServer=$SERVER
		fi
		Echo "Mounting NFS root system: $nfsRootServer:$nfsRootDevice..."
		imageRootDevice="-o nolock,rw $nfsRootServer:$nfsRootDevice"
		if [ ! -z "$COMBINED_IMAGE" ] || [ ! -z "$UNIONFS_CONFIG" ];then
			imageRootDevice="-o nolock,ro $nfsRootServer:$nfsRootDevice"
		fi
		imageRootName="NFSRoot-System"
		systemIntegrity="clean"
		export FSTYPE=nfs
	fi
	#======================================
	# 14.4) Check for NBD root
	#--------------------------------------
	if [ ! -z "$NBDROOT" ];then
		if ! modprobe nbd;then
			systemException "Failed to load network blk device module" "reboot"
		fi
		IFS="," ; for i in $NBDROOT;do
			field=0
			IFS=";" ; for n in $i;do
			case $field in
				0) nbdServer=$n     ; field=1 ;;
				1) nbdPort=$n       ; field=2 ;;
				2) nbdDevice=$n     ; field=3 ;;
				3) nbdswapPort=$n   ; field=4 ;;
				4) nbdswapDevice=$n ; field=5 ;;
				5) nbdwritePort=$n  ; field=6 ;;
				6) nbdwriteDevice=$n; field=7
			esac
			done
		done
		if [ -z "$nbdServer" ];then
			nbdServer=$SERVER
		fi
		if [ -z "$nbdDevice" ];then
			nbdDevice="/dev/nbd0"
		fi
		if [ -z "$nbdswapDevice" ];then
			nbdswapDevice="/dev/nbd1"
		fi
		if [ -z "$nbdPort" ];then
			nbdPort="2000"
		fi
		if [ -z "$nbdwriteDevice" ];then
			nbdwriteDevice="/dev/ram1"
		fi
		waitForBlockDevice $nbdDevice
		if [ ! -b $nbdDevice ];then
			systemException "Device $nbdDevice doesn't appear" "reboot"
		fi
		if [ ! -z "$nbdwritePort" ];then
			waitForBlockDevice $nbdwriteDevice
			if [ ! -b $nbdwriteDevice ];then
				systemException "Device $nbdwriteDevice doesn't appear" "reboot"
			fi
		fi
		if [ ! -z "$nbdswapPort" ];then
			waitForBlockDevice $nbdswapPort
			if [ ! -b $nbdswapDevice ];then
				systemException "Device $nbdswapDevice doesn't appear" "reboot"
			fi
		fi
		# /.../
		# try to get swap from the server if we dont have
		# enough ram (less than 62MB)
		# ----
		if [ ! -z "$nbdswapPort" ];then
			min_ram=63488
			real_ram=$(cat /proc/meminfo |grep MemTotal|tr -d " [a-z][A-Z]:")
			if [ ${real_ram} -lt ${min_ram} ];then
				Echo "NBD: memory is below required 62M"
				Echo "NBD: swap: $nbdServer $nbdswapPort [$nbdswapDevice]"
				if ! nbd-client $nbdServer $nbdswapPort $nbdswapDevice -persist
				then
					systemException \
						"Failed to setup $nbdswapDevice device" \
					"reboot"
				fi
				Echo "NBD: Waiting for server to create swap space..."; sleep 3
				swapon $nbdswapDevice || true
			fi
		fi
		# /.../
		# try to mount a remote read/write location based on NBD
		# this is then overlayed via $unionFST
		# ----
		if [ ! -z "$nbdwritePort" ];then
			Echo "NBD: read/write $nbdServer $nbdwritePort [$nbdwriteDevice]..."
			if ! nbd-client $nbdServer $nbdwritePort $nbdwriteDevice -persist
			then
				systemException \
					"Failed to setup $nbdwriteDevice device" \
				"reboot"
			fi
		fi
		# /.../
		# mount basic root filesystem exported via NBD
		# ----
		Echo "Mounting NBD root system: $nbdServer $nbdPort [$nbdDevice]..."
		if ! nbd-client $nbdServer $nbdPort $nbdDevice -persist;then
			systemException "Failed to setup $nbdDevice device" "reboot"
		fi
		# /.../
		# setup union if basic root filesystem is read-only
		# ----
		imageRootDevice=$nbdDevice
		probeFileSystem $imageRootDevice
		Echo "Filesystem of remote root system is: $FSTYPE"
		if [ -z "$COMBINED_IMAGE" ];then
			if isFSTypeReadOnly;then
				setupUnionFS "$nbdwriteDevice" "$imageRootDevice" $unionFST
			fi
		fi
		imageRootName="NBDRoot-System"
		systemIntegrity="clean"
	fi
	#======================================
	# 14.5) Check for AOE root
	#--------------------------------------
	if [ ! -z "$AOEROOT" ];then
		aoeRODevice=`echo $AOEROOT | cut -d , -f 1`
		aoeRWDevice=`echo $AOEROOT | cut -d , -f 2`
		if [ -z "$aoeRWDevice" ] || [ "$aoeRODevice" = "$aoeRWDevice" ];then
			aoeRWDevice=/dev/ram1
		fi
		if ! modprobe aoe;then
			systemException "Failed to load AoE module" "reboot"
		fi
		waitForBlockDevice $aoeRODevice
		if [ ! -b $aoeRODevice ];then
			systemException "Device $aoeRODevice doesn't appear" "reboot"
		fi
		# /.../
		# check ram space, if we don't have more than 62MB
		# we can't use Ata over Ethernet and reboot
		# ----
		min_ram=63488
		real_ram=$(cat /proc/meminfo |grep MemTotal|tr -d " [a-z][A-Z]:")
		if [ ${real_ram} -lt ${min_ram} ];then
			Echo "AoE: memory is below required 62M"
			systemException "Not enough ram" "reboot"
		fi
		Echo "Mounting AoE root system: $aoeRODevice..."
		imageRootDevice=$aoeRODevice
		probeFileSystem $imageRootDevice
		Echo "Filesystem of remote root system is: $FSTYPE"
		if [ -z "$COMBINED_IMAGE" ];then
			if isFSTypeReadOnly;then
				setupUnionFS "$aoeRWDevice" "$imageRootDevice" $unionFST
			fi
		fi
		imageRootName="AOERoot-System"
		systemIntegrity="clean"
	fi
fi
runHook postdownload

#======================================
# 15) Mount OS image to /mnt
#--------------------------------------
runHook premount
if ! mountSystem;then
	systemException "Failed to mount root filesystem" "reboot"
fi
validateRootTree
runHook postmount

#======================================
# 16) Import fixed configuration files
#--------------------------------------
runHook preconfig
if [ $LOCAL_BOOT = "no" ] || [ ! -z "$RELOAD_CONFIG" ];then
	mkdir -p /config
	#=======================================
	# 16.1) Get files from CONF, VENDOR_CONF
	#---------------------------------------
	IFS="," ; for i in $CONF $VENDOR_CONF;do
		field=0
		IFS=";" ; for n in $i;do
		case $field in
			0) configSource=$n ; field=1 ;;
			1) configDest=$n   ; field=2 ;;
			2) configServer=$n ; field=3 ;;
			3) configBlkSize=$n;
		esac
		done
		Echo "Import configuration file: $configDest"
		dirs=`dirname  $configDest`
		mkdir -p /config/$dirs
		fetchFile $configSource /config/$configDest uncomp $configServer
	done
	IFS=$IFS_ORIG
	#=======================================
	# 16.2) Check for KIWI_INITRD
	#---------------------------------------
	if [ $haveDisk = "1" ] && [ $systemIntegrity = "clean" ];then
		if [ ! -z "$KIWI_INITRD" ];then
			Echo "Import KIWI initrd file: $KIWI_INITRD"
			rm -f /mnt/boot/initrd* && mkdir -p /mnt/boot >/dev/null 2>&1
			fetchFile $KIWI_INITRD /mnt/boot/initrd.kiwi
			if [ ! -z "$KIWI_KERNEL" ];then
				Echo "Import KIWI kernel file: $KIWI_KERNEL"
				rm -f /mnt/boot/linux*
				fetchFile $KIWI_KERNEL /mnt/boot/linux.kiwi
			fi
			KIWI_INITRD_PARAMS="IMAGE=local"
			if [ ! -z "$COMBINED_IMAGE" ]; then
				SPLIT="COMBINED_IMAGE=$COMBINED_IMAGE"
				KIWI_INITRD_PARAMS="$KIWI_INITRD_PARAMS $SPLIT"
			fi
		fi
		if [ ! -z "$UNIONFS_CONFIG" ]; then
			unionFST=`echo $UNIONFS_CONFIG | cut -d , -f 3`
			UNIONED="UNIONFS_CONFIG=$unionFST"
			KIWI_INITRD_PARAMS="$KIWI_INITRD_PARAMS $UNIONED"
		fi
	fi
fi
runHook postconfig

#======================================
# 17) check filesystem and kernels
#--------------------------------------
if [ $LOCAL_BOOT = "no" ] && [ $systemIntegrity = "clean" ];then
	if [ "$FSTYPE" != "nfs" ];then
		probeFileSystem $imageRootDevice
	fi
	kernelList /mnt
fi

#======================================
# 18) Create system dependant files
#--------------------------------------
if [ $LOCAL_BOOT = "no" ] && [ $systemIntegrity = "clean" ];then
	mkdir -p /config
	setupDefaultPXENetwork /config
	setupDefaultFstab /config
	updateRootDeviceFstab /config "$imageRootDevice"
	if test ! -z $DISK;then
		updateSwapDeviceFstab /config ${DISK}1
		updateOtherDeviceFstab /config
		if [ "$haveLVM" = "yes" ];then
			updateLVMBootDeviceFstab /config $imageBootDevice
		elif [ "$haveClicFS" = "yes" ];then
			updateClicBootDeviceFstab /config $imageBootDevice
		elif [ "$haveBtrFS" = "yes" ];then
			updateBtrBootDeviceFstab /config $imageBootDevice
		elif [ "$haveXFS" = "yes" ];then
			updateXfsBootDeviceFstab /config $imageBootDevice
		fi
		setupBootLoader /mnt /config $(($bootid - 1)) \
			$imageRootDevice NET $imageSwapDevice
		setupKernelModules /config
	fi
fi

#======================================
# 19) If image is new, notify
#--------------------------------------
runHook prenotify
if [ $LOCAL_BOOT = "no" ] && [ $systemIntegrity = "clean" ];then
	pxeNotifyNewImage
fi
runHook postnotify

#======================================
# 20) send DHCP_RELEASE, reset cache
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	releaseNetwork
fi

#======================================
# 21) copy system dependant files
#--------------------------------------
if [ $LOCAL_BOOT = "no" ];then
	setupConfigFiles
fi

#======================================
# 22) update system dependant files
#--------------------------------------
setupInittab /mnt

echo 256 > /proc/sys/kernel/real-root-dev
#======================================
# 23) umount system filesystems
#--------------------------------------
umountSystemFilesystems

#======================================
# 24) copy initrd files to image
#--------------------------------------
if [ $LOCAL_BOOT = "no" ] && [ $systemIntegrity = "clean" ];then
	if canWrite /mnt;then
		importBranding
		cp /preinit /mnt
		cp /include /mnt
	fi
fi

#======================================
# 25) check if reboot is required
#--------------------------------------
kernelCheck /mnt

#======================================
# 26) kill boot shell
#--------------------------------------
killShell
killBlogD

#======================================
# 27) Activate new root
#--------------------------------------
runHook preactivate
activateImage

#======================================
# 28) Unmount initrd / system init
#--------------------------------------
bootImage $@
