<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>openSUSE-KIWI Image System</title><link rel="stylesheet" type="text/css" href="susebooks.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book"><div class="titlepage"><div><div><h1 class="title"><a name="idm139781534766624"></a>openSUSE-KIWI Image System</h1></div><div><h2 class="subtitle">Cookbook</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Marcus</span> <span class="surname">Schäfer</span></h3><span class="contrib">Project, Design and Implementation</span> <div class="affiliation"><span class="jobtitle">Software Engineer<br></span><span class="orgname">SUSE LINUX GmbH<br></span></div><code class="email">&lt;<a class="email" href="mailto:ms@suse.com">ms@suse.com</a>&gt;</code></div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Thomas</span> <span class="surname">Schraitle</span></h3><span class="contrib">Various text improvements, migration to DocBook</span> <div class="affiliation"><span class="jobtitle">Documentation Specialist<br></span><span class="orgname">SUSE LINUX GmbH<br></span></div><code class="email">&lt;<a class="email" href="mailto:toms@suse.com">toms@suse.com</a>&gt;</code></div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Frank</span> <span class="surname">Sundermeyer</span></h3><span class="contrib">Editorial review</span> <div class="affiliation"><span class="jobtitle">Documentation Specialist<br></span><span class="orgname">SUSE LINUX GmbH<br></span></div><code class="email">&lt;<a class="email" href="mailto:fs@suse.com">fs@suse.com</a>&gt;</code></div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Robert</span> <span class="surname">Schweikert</span></h3><span class="contrib">Various text improvements, implementation</span> <div class="affiliation"><span class="orgname">SUSE LLC<br></span></div><code class="email">&lt;<a class="email" href="mailto:rjschwei@suse.com">rjschwei@suse.com</a>&gt;</code></div></div></div><div><p class="releaseinfo">KIWI Version 7.03
  </p></div><div><div class="legalnotice"><a name="idm139781533917968"></a><p>
  Copyright © 2006–2016
  SUSE LLC and contributors. All rights reserved.
 </p><p>
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.2 or (at
  your option) version 1.3; with the Invariant Section being this copyright
  notice and license. A copy of the license version 1.2 is included in the
  section entitled <span class="quote">“<span class="quote">GNU Free Documentation License</span>”</span>.
 </p><p>
  For SUSE and Novell trademarks, see the Novell Trademark and Service
  Mark list
  <a class="ulink" href="http://www.novell.com/company/legal/trademarks/tmlist.html" target="_top">http://www.novell.com/company/legal/trademarks/tmlist.html</a>.
  All other third party trademarks are the property of their respective
  owners. A trademark symbol (®, ™ etc.) denotes a SUSE or
  Novell trademark; an asterisk (*) denotes a third party trademark.
 </p><p>
  All information found in this book has been compiled with utmost attention
  to detail. However, this does not guarantee complete accuracy. Neither
  SUSE LLC, its affiliates, the authors nor the translators shall be held
  liable for possible errors or the consequences thereof.
 </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="part"><a href="#part.basics">I. Concepts and Basics</a></span></dt><dd><dl><dt><span class="chapter"><a href="#chap.introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.introduction.whatiskiwi">1.1. What is KIWI?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.whatdoeskiwido">1.2. What does KIWI do?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.howtousekiwi">1.3. How to use KIWI?</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.installation">2. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.installation.rpminstall">2.1. Installing KIWI Packages</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.installation.rpminstall.latest">2.1.1. Installing the Latest Version Available</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.installation.fromsource">2.2. Running KIWI from a Source Checkout</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.workflow">3. Basic Workflow</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.workflow.buildprocess">3.1. Building Images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.workflow.buildprocess.prepare">3.1.1. The Prepare Step</a></span></dt><dt><span class="sect2"><a href="#sec.workflow.buildprocess.create">3.1.2. The Create Step</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.workflow.bootprocess">3.2. Customizing the Boot Process</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.hooks">3.2.1. Boot Image Hook-Scripts</a></span></dt><dt><span class="sect2"><a href="#sec.bootcustomization">3.2.2. FAQ: Boot Image Customization</a></span></dt><dt><span class="sect2"><a href="#sec.workflow.bootparameters">3.2.3. Boot Parameters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.workflow.common-specific-code">3.3. Distribution-Specific Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.description">4. KIWI Image Description</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.description.config.xml">4.1. The config.xml File</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.description.image">4.1.1. <code class="sgmltag-element">image</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.description">4.1.2. <code class="sgmltag-element">description</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.profiles">4.1.3. <code class="sgmltag-element">profiles</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.preferences">4.1.4. <code class="sgmltag-element">preferences</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.users">4.1.5. <code class="sgmltag-element">users</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.drivers">4.1.6. <code class="sgmltag-element">drivers</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.repository">4.1.7. <code class="sgmltag-element">repository</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.packages">4.1.8. <code class="sgmltag-element">packages</code> Element</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.adv_setup">5. Advanced Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#chap.caches">5.1. Image Caches</a></span></dt><dt><span class="sect1"><a href="#chap.raid">5.2. KIWI RAID Support</a></span></dt><dt><span class="sect1"><a href="#chap.partitions">5.3. KIWI Custom Partitions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#chap.partitions.lvm">5.3.1. Custom Partitioning via LVM</a></span></dt><dt><span class="sect2"><a href="#chap.partitions.btrfs">5.3.2. Custom Partitioning via Btrfs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#chap.encryption">5.4. KIWI Encryption Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.maintenance">6. Maintaining Appliance Images</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.maintenance.packages">6.1. Image Maintenance: Updating Software Packages</a></span></dt><dt><span class="sect1"><a href="#sec.maintenance.config">6.2. Image Maintenance: Modifying the Configuration</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#part.usecases">II. Usecases</a></span></dt><dd><dl><dt><span class="chapter"><a href="#chap.iso">7. ISO Image / Live System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.iso.cd">7.1. Building Live CD/DVD Images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.split-mode">7.1.1. Split mode</a></span></dt><dt><span class="sect2"><a href="#sec.iso.hybrid-mode">7.1.2. Hybrid mode</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.iso.usb">7.2. Building Live Images for Removable USB Devices</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.usb.hybrid">7.2.1. Hybrid ISO Image</a></span></dt><dt><span class="sect2"><a href="#sec.iso.tmpfs">7.2.2. In RAM ISO Image</a></span></dt><dt><span class="sect2"><a href="#sec.iso.usb.oem">7.2.3. OEM Virtual Disk Image</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.vmx">8. VMX Image / Virtual Disks</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.vmx.building">8.1. Building VMX Images</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.vmware-support">8.2. VMware support</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.lvm">8.3. LVM Support</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.bootpartition">8.4. Extra Boot Partition</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.docker">9. Docker images</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.docker.building">9.1. Building Docker Images</a></span></dt><dt><span class="sect1"><a href="#sec.docker.details">9.2. Image Configuration Details</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.vagrant">10. Vagrant boxes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.vagrant.building">10.1. Building Vagrant Boxes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.pxe">11. PXE Image / Thin Clients</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.pxe.building">11.1. Building PXE Images</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.files">11.2. PXE Configuration Files</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.client-config-file">11.3. The PXE Client Configuration File Syntax</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.another-user">11.3.1. Use a Different Download Protocol</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.ram-only-image">11.3.2. RAM Only Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.union-image">11.3.3. Union Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.split-image">11.3.4. Split Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.remote-root">11.3.5. Mounting the Root File System from a Remote Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.groups">11.4. Hardware Grouping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.groups.def_file">11.4.1. The Group Definition File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.groups.group_file">11.4.2. The Group Configuration File</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.oem">12. OEM Image / Preload Systems</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.oem.building">12.1. Building an OEM System and an Installation Image</a></span></dt><dt><span class="sect1"><a href="#sec.oem.testing">12.2. Testing the Images</a></span></dt><dt><span class="sect1"><a href="#sec.oem.flavours">12.3. Installation Image Flavors</a></span></dt><dt><span class="sect1"><a href="#sec.oem.customize">12.4. Customizing the OEM Images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.oem.customize.installation">12.4.1. Customizing the OEM Install Process</a></span></dt><dt><span class="sect2"><a href="#sec.oem.customize.parameters">12.4.2. OEM Customizing Parameters</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partition-based-installation">12.4.3. Partition Based Installation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.oem.pxe-based-installation">12.5. Network Based Installation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.xen">13. Xen Para- and Full virtual Images</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.xen.dom0.building">13.1. Building a Dom0 Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.dom0.using">13.2. Testing the Dom0 Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.pv.building">13.3. Building a Paravirtualized Xen Guest Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.hvm.building">13.4. Building a Fully Virtualized Xen Guest</a></span></dt><dt><span class="sect1"><a href="#sec.xen.using">13.5. Using the Guest Images</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.appliance">14. Creating Appliances</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.appliance.kiwi-model">14.1. The KIWI Model</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.migration">15. System Analysis/Migration</a></span></dt></dl></dd><dt><span class="appendix"><a href="#appendix">A. KIWI Man Pages</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwi">kiwi</a></span><span class="refpurpose"> — Creating Operating System Images</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.config.sh">kiwi::config.sh</a></span><span class="refpurpose"> — Customization File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.images.sh">kiwi::images.sh</a></span><span class="refpurpose"> — Customization File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwirc">kiwi::kiwirc</a></span><span class="refpurpose"> — Resource file for the Kiwi imaging system</span></dt></dl></dd><dt><span class="appendix"><a href="#app.bootserver">B. Setting Up a Network Boot Server</a></span></dt><dt><span class="appendix"><a href="#idm139781526504624">C. GNU Licenses</a></span></dt><dd><dl><dt><span class="sect1"><a href="#idm139781526503200">C.1. GNU Free Documentation License</a></span></dt></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>3.1. <a href="#fig.imagecreationarch">Image Creation Architecture</a></dt><dt>3.2. <a href="#fig.imagetypes">Image Types</a></dt><dt>3.3. <a href="#fig.workflow.imagedescriptions">Image Descriptions</a></dt><dt>4.1. <a href="#fig.description.imagedescrdir">Image Description Directory</a></dt><dt>5.1. <a href="#fig.imagecachingarch">Image Caching Architecture</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>4.1. <a href="#tab.description.supported-types">Supported Package Manager Repository Types</a></dt><dt>8.1. <a href="#tab.vmx.supported-disk-formats">Supported Virtual Disk Formats</a></dt><dt>11.1. <a href="#tab.configuration.files.synchronization">Configuration Files Synchronization Possibilities</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>5.1. <a href="#sec.caches.example">Building Multiple VMX Images</a></dt><dt>5.2. <a href="#ex.lvm">Examples for Configuring LVM</a></dt><dt>11.1. <a href="#ex.pxe.union.local.local">
      Download Compressed Image to Local Storage, Write to Local Storage
     </a></dt><dt>11.2. <a href="#ex.pxe.union.local.ram">
      Download Compressed Image to Local Storage, Write to RAM
     </a></dt><dt>11.3. <a href="#ex.pxe.union.remote.local">
      Mount Compressed Image from Remote, Write to Local Storage
     </a></dt><dt>11.4. <a href="#ex.pxe.union.remote.ram">
      Mount Compressed Image from Remote, Write to RAM
     </a></dt><dt>11.5. <a href="#ex.pxe.union.remote.remote">
      Mount Compressed Image from Remote, Write to Remote
     </a></dt><dt>11.6. <a href="#ex.pxe.remote-root.aoe">Root Tree Over AoE</a></dt><dt>11.7. <a href="#ex.pxe.root-tree-over-nbd">Root Tree Over NBD</a></dt><dt>11.8. <a href="#ex.pxe.root-tree-over-nfs">Root Tree Over NFS</a></dt><dt>11.9. <a href="#ex.pxe.groups.group_file.overrides.example.group">The Group Definition File <code class="filename">config.group</code></a></dt><dt>11.10. <a href="#ex.pxe.groups.group_file.overrides.example.group_config">
      The Group Configuration File <code class="filename">config.myvendor</code>
     </a></dt><dt>11.11. <a href="#ex.pxe.groups.group_file.overrides.example.hw_config">
      The Hardware Mapping Details File
      <code class="filename">hardware_config.myvendor_foo2000</code>
     </a></dt><dt>A.1. <a href="#idm139781526761824">Template for config.sh</a></dt><dt>A.2. <a href="#idm139781526625296">Template for images.sh</a></dt><dt>A.3. <a href="#idm139781526549600">Template for .kiwi.rc</a></dt></dl></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="part.basics"></a>Part I. Concepts and Basics</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#chap.introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.introduction.whatiskiwi">1.1. What is KIWI?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.whatdoeskiwido">1.2. What does KIWI do?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.howtousekiwi">1.3. How to use KIWI?</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.installation">2. Installation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.installation.rpminstall">2.1. Installing KIWI Packages</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.installation.rpminstall.latest">2.1.1. Installing the Latest Version Available</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.installation.fromsource">2.2. Running KIWI from a Source Checkout</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.workflow">3. Basic Workflow</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.workflow.buildprocess">3.1. Building Images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.workflow.buildprocess.prepare">3.1.1. The Prepare Step</a></span></dt><dt><span class="sect2"><a href="#sec.workflow.buildprocess.create">3.1.2. The Create Step</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.workflow.bootprocess">3.2. Customizing the Boot Process</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.hooks">3.2.1. Boot Image Hook-Scripts</a></span></dt><dt><span class="sect2"><a href="#sec.bootcustomization">3.2.2. FAQ: Boot Image Customization</a></span></dt><dt><span class="sect2"><a href="#sec.workflow.bootparameters">3.2.3. Boot Parameters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.workflow.common-specific-code">3.3. Distribution-Specific Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.description">4. KIWI Image Description</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.description.config.xml">4.1. The config.xml File</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.description.image">4.1.1. <code class="sgmltag-element">image</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.description">4.1.2. <code class="sgmltag-element">description</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.profiles">4.1.3. <code class="sgmltag-element">profiles</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.preferences">4.1.4. <code class="sgmltag-element">preferences</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.users">4.1.5. <code class="sgmltag-element">users</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.drivers">4.1.6. <code class="sgmltag-element">drivers</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.repository">4.1.7. <code class="sgmltag-element">repository</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.packages">4.1.8. <code class="sgmltag-element">packages</code> Element</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.adv_setup">5. Advanced Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#chap.caches">5.1. Image Caches</a></span></dt><dt><span class="sect1"><a href="#chap.raid">5.2. KIWI RAID Support</a></span></dt><dt><span class="sect1"><a href="#chap.partitions">5.3. KIWI Custom Partitions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#chap.partitions.lvm">5.3.1. Custom Partitioning via LVM</a></span></dt><dt><span class="sect2"><a href="#chap.partitions.btrfs">5.3.2. Custom Partitioning via Btrfs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#chap.encryption">5.4. KIWI Encryption Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.maintenance">6. Maintaining Appliance Images</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.maintenance.packages">6.1. Image Maintenance: Updating Software Packages</a></span></dt><dt><span class="sect1"><a href="#sec.maintenance.config">6.2. Image Maintenance: Modifying the Configuration</a></span></dt></dl></dd></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.introduction"></a>Chapter 1. Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.introduction.whatiskiwi">1.1. What is KIWI?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.whatdoeskiwido">1.2. What does KIWI do?</a></span></dt><dt><span class="sect1"><a href="#sec.introduction.howtousekiwi">1.3. How to use KIWI?</a></span></dt></dl></div><a class="indexterm" name="idm139781530064720"></a><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.introduction.whatiskiwi"></a>1.1. What is KIWI?<span class="permalink"><a alt="Permalink" title="1.1. What is KIWI?" href="#sec.introduction.whatiskiwi">¶</a></span></h2></div></div></div><p>
   KIWI is a command line tool, written in Perl, for building images for Linux.
   It supports a variety of image formats. KIWI is used as a back-end for the
   appliance builder <a class="ulink" href="http://susestudio.com/" target="_top">SUSE Studio</a>.
   It is also used to build images in the <a class="ulink" href="http://build.opensuse.org/" target="_top">openSUSE Build Service</a>, among them
   images for all SUSE products.
  </p><p>
   Images for Linux are available in many different formats. A Linux <code class="filename">*.iso</code><a class="indexterm" name="idm139781531668496"></a> file, that can be burned to an optical
   medium to install Linux, is an image. A file used by virtualization systems
   such as KVM, Xen, or VMware is an image. The installation of a Linux system
   on your hard drive can be turned into an image using the
   <span class="command"><strong>dd</strong></span> command.
  </p><p>
   Basically, an image is a Linux system in a file. Depending on the type of
   the image, there are different use cases for it. It can be used to burn an
   iso image to an optical medium with which the computer can be booted. An
   image can also be used to run a Virtual Machine from the
   <code class="filename">*.iso</code><a class="indexterm" name="idm139781531943168"></a> file (image) stored on your
   hard drive. KIWI supports the following image types and formats:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
     ISO
    </p></li><li class="listitem"><p>
     Live CD/DVD
    </p></li><li class="listitem"><p>
     PXEBoot
    </p></li><li class="listitem"><p>
     Hard Disk
    </p></li><li class="listitem"><p>
     USB
    </p></li><li class="listitem"><p>
     Amazon EC2 (<code class="filename">.ami</code><a class="indexterm" name="idm139781532600800"></a>)
    </p></li><li class="listitem"><p>
     Docker
    </p></li><li class="listitem"><p>
     Google Cloud Format (<code class="filename">..gce</code><a class="indexterm" name="idm139781531350512"></a>)
    </p></li><li class="listitem"><p>
     KVM/Qemu (<code class="filename">.qcow2</code><a class="indexterm" name="idm139781529211952"></a>)
    </p></li><li class="listitem"><p>
     Open Virtualization Format (<code class="filename">.ovf</code><a class="indexterm" name="idm139781530009376"></a>, <code class="filename">.ova</code><a class="indexterm" name="idm139781530859600"></a>)
    </p></li><li class="listitem"><p>
     Vagrant (<code class="filename">.vagrant</code><a class="indexterm" name="idm139781530076800"></a>
    </p></li><li class="listitem"><p>
     VirtualBox (<code class="filename">.vdi</code><a class="indexterm" name="idm139781529312320"></a>)
    </p></li><li class="listitem"><p>
     Virtual Hard Disk (<code class="filename">.vhd</code><a class="indexterm" name="idm139781531561120"></a>)
    </p></li><li class="listitem"><p>
     VMware (<code class="filename">.vmdk</code><a class="indexterm" name="idm139781531886672"></a>)
    </p></li><li class="listitem"><p>
     XEN
    </p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.introduction.whatdoeskiwido"></a>1.2. What does KIWI do?<span class="permalink"><a alt="Permalink" title="1.2. What does KIWI do?" href="#sec.introduction.whatdoeskiwido">¶</a></span></h2></div></div></div><p>
   KIWI allows you to configure, build, and deploy your own operating system
   images in a variety of formats. The KIWI workflow is divided into two
   distinct stages. For a detailed description of this process refer to <a class="xref" href="#chap.workflow" title="Chapter 3. Basic Workflow">Chapter 3, <i>Basic Workflow</i></a>.
  </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p><b>Preparation. </b>
      Create a root directory holding the contents of the new file
      system. Install the required packages from a software package source
      such as the installation media for SUSE Linux Enterprise Server, or
      an online repository. Create an image description file,
      (<code class="filename">config.xml</code>) and optionally apply
      customizations. This operation results in the <span class="quote">“<span class="quote">unpacked root
      tree</span>”</span>.
     </p></li><li class="step"><p><b>Creation. </b>
      The image itself is created using the unpacked root tree created in the
      previous step. The image creation process does not require user
      interaction, but can be fine-tuned by modifying the <code class="filename">images.sh</code>
      script that is called during the creation process.
     </p></li></ol></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.introduction.howtousekiwi"></a>1.3. How to use KIWI?<span class="permalink"><a alt="Permalink" title="1.3. How to use KIWI?" href="#sec.introduction.howtousekiwi">¶</a></span></h2></div></div></div><p>
   KIWI is a command line tool that is invoked with the
   <span class="command"><strong>kiwi</strong></span> command in your shell. KIWI needs to be executed
   as the <code class="systemitem">root</code><a class="indexterm" name="idm139781532464288"></a> user, as
   administrative privileges are required for many operations that need to
   take place to create an image. Therefore, when using KIWI you need to be
   aware of what you are doing and a certain amount of caution is in order.
   Running KIWI on your system is not inherently dangerous to your system,
   just keep in mind that you are running as the
   <code class="systemitem">root</code><a class="indexterm" name="idm139781532309872"></a> user.
  </p><p>
   The two phases of the image creation process outlined in <a class="xref" href="#sec.introduction.whatdoeskiwido" title="1.2. What does KIWI do?">Section 1.2, “What does KIWI do?”</a> can be started with the
   commands <span class="command"><strong>kiwi --prepare</strong></span> for the first step and
   <span class="command"><strong>kiwi --create</strong></span> for the second step. For convenience KIWI
   also has the <code class="option">--build</code> that combines the
   <span class="emphasis"><em>prepare</em></span> and <span class="emphasis"><em>create</em></span> steps.
  </p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.installation"></a>Chapter 2. Installation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.installation.rpminstall">2.1. Installing KIWI Packages</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.installation.rpminstall.latest">2.1.1. Installing the Latest Version Available</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.installation.fromsource">2.2. Running KIWI from a Source Checkout</a></span></dt></dl></div><a class="indexterm" name="idm139781532598496"></a><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.installation.rpminstall"></a>2.1. Installing KIWI Packages<span class="permalink"><a alt="Permalink" title="2.1. Installing KIWI Packages" href="#sec.installation.rpminstall">¶</a></span></h2></div></div></div><p>
   KIWI is shipped with all SUSE distributions, but not installed by
   default. With SUSE Linux Enterprise 11, KIWI is included in the 
   software development kit (SDK), not the main installation media.
   A minimum KIWI installation requires installing the 
   <span class="package">kiwi</span> package and at least one package containing
   the boot descriptions for the various image types:
  </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
    <span class="package">kiwi-desc-isoboot</span>: Live ISO boot templates
   </td></tr><tr><td>
    <span class="package">kiwi-desc-netboot</span>: PXE network boot templates
   </td></tr><tr><td>
    <span class="package">kiwi-desc-oemboot</span>: Expandable Virtual Machine boot
    templates
   </td></tr><tr><td>
    <span class="package">kiwi-desc-vmxboot</span>: Virtual Machine boot templates
   </td></tr></table><p>
   It is also recommended to install the package <span class="package">kiwi-doc</span>
   containing the documentation. For a complete list of KIWI packages run the
   command <span class="command"><strong>zypper se kiwi</strong></span>.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.installation.rpminstall.latest"></a>2.1.1. Installing the Latest Version Available<span class="permalink"><a alt="Permalink" title="2.1.1. Installing the Latest Version Available" href="#sec.installation.rpminstall.latest">¶</a></span></h3></div></div></div><p>
    KIWI is an active project and new releases are published
    regularly. Packages with the latest KIWI version for all SUSE
    distributions that are actively maintained can be obtained from the
    Virtualization:Appliances repository at <a class="ulink" href="http://download.opensuse.org/repositories/Virtualization:/Appliances/" target="_top">http://download.opensuse.org/repositories/Virtualization:/Appliances/</a>.
   </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.installation.fromsource"></a>2.2. Running KIWI from a Source Checkout<span class="permalink"><a alt="Permalink" title="2.2. Running KIWI from a Source Checkout" href="#sec.installation.fromsource">¶</a></span></h2></div></div></div><p>
   KIWI is developed and maintained in a repository on GitHub. You can
   clone the source code using the following command.
  </p><pre class="screen">git clone https://github.com/openSUSE/kiwi.git</pre><p>
   Before running KIWI make sure all its dependencies are fullfilled. Get a list
   of required packages by running the following command in the checkout
   directory (<code class="filename">kiwi/</code><a class="indexterm" name="idm139781532465248"></a>):
  </p><pre class="screen">awk '/BuildRequires:/ { print $2 | "sort" }' rpm/kiwi.spec</pre><p>
   Once all dependent packages are installed run the test suite from the
   checkout directory as follows
  </p><pre class="screen"><span class="command"><strong>make</strong></span> test</pre><p>
   If all tests pass, all dependencies are fullfilled and KIWI can be run with
   from the checkout directory with the following command:
  </p><pre class="screen"><span class="command"><strong>./kiwi</strong></span></pre><p>
   To update to the latest version available, run <span class="command"><strong>git pull</strong></span>
   from the KIWI checkout directory.
  </p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.workflow"></a>Chapter 3. Basic Workflow</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.workflow.buildprocess">3.1. Building Images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.workflow.buildprocess.prepare">3.1.1. The Prepare Step</a></span></dt><dt><span class="sect2"><a href="#sec.workflow.buildprocess.create">3.1.2. The Create Step</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.workflow.bootprocess">3.2. Customizing the Boot Process</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.hooks">3.2.1. Boot Image Hook-Scripts</a></span></dt><dt><span class="sect2"><a href="#sec.bootcustomization">3.2.2. FAQ: Boot Image Customization</a></span></dt><dt><span class="sect2"><a href="#sec.workflow.bootparameters">3.2.3. Boot Parameters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.workflow.common-specific-code">3.3. Distribution-Specific Code</a></span></dt></dl></div><a class="indexterm" name="idm139781532770080"></a><div class="abstract"><p class="title"><b>Abstract</b></p><p>
   Installation of a Linux system generally occurs by booting the target
   system from an installation source such as an installation CD/DVD, a live
   CD/DVD, or a network boot environment (PXE). The installation process is
   often driven by an installer that interacts with the user to collect
   information about the installation. This information generally includes the
   <span class="emphasis"><em>software to be installed</em></span>, the
   <span class="emphasis"><em>timezone</em></span>, system <span class="emphasis"><em>user</em></span> data, and
   other information. Once all the information is collected, the installer
   installs the software onto the target system using packages from the
   software sources (repositories) available. After the installation is
   complete the system usually reboots and enters a configuration procedure
   upon start-up. The configuration may be fully automatic or it may include
   user interaction.
  </p></div><p>
  A system image (usually called <span class="quote">“<span class="quote">image</span>”</span>), is a
  <span class="emphasis"><em>complete installation</em></span> of a Linux system within a
  file. The image represents an operational system and—optionally
  contains the <span class="quote">“<span class="quote">final</span>”</span> configuration.
 </p><p>
  The behavior of the image upon deployment varies depending on the image type
  and the image configuration since KIWI allows you to completely customize
  the initial start-up behavior of the image. Among others, this includes
  images that
 </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
    can be deployed inside an existing virtual environment without requiring
    configuration at start-up.
   </p></li><li class="listitem"><p>
    automatically configure themselves in a known target environment.
   </p></li><li class="listitem"><p>
    prompt the user for an interactive system configuration.
   </p></li></ul></div><p>
  The image creation process with KIWI is automated and does not require any
  user interaction. The information required for the image creation process is
  provided by the primary configuration file named
  <code class="filename">config.xml</code>. In addition, the image can optionally be
  customized using the <code class="filename">config.sh</code> and
  <code class="filename">images.sh</code> scripts and by using an <span class="emphasis"><em>overlay
  tree (directory)</em></span> called <span class="quote">“<span class="quote">root</span>”</span>.
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Previous Knowledge</h3><p>
    This manual assumes that you are familiar with the general concepts of
    Linux, including the boot process, and distribution concepts such as
    package management.
   </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.buildprocess"></a>3.1. Building Images<span class="permalink"><a alt="Permalink" title="3.1. Building Images" href="#sec.workflow.buildprocess">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781530661376"></a><a class="indexterm" name="idm139781533097360"></a><p>
   KIWI creates images in a two step process. The first step, the
   <code class="literal">prepare</code> operation, generates a so-called
   <span class="emphasis"><em>unpacked image</em></span> tree (directory) using the information
   provided in the <code class="filename">config.xml</code> configuration file. The
   <code class="filename">config.xml</code> file is part of the <span class="emphasis"><em>configuration
   directory (tree)</em></span> that describes the image to be created by
   KIWI.
  </p><p>
   The second step, the <code class="literal">create</code> operation, creates
   the <span class="emphasis"><em>packed image</em></span> or <span class="emphasis"><em>image</em></span> in the
   specified format based on the unpacked image and the information provided
   in the <code class="filename">config.xml</code> configuration file.
  </p><div class="figure"><a name="fig.imagecreationarch"></a><p class="title"><b>Figure 3.1. Image Creation Architecture</b><span class="permalink"><a alt="Permalink" title="Figure 3.1. Image Creation Architecture" href="#fig.imagecreationarch">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><img src="images/intro.png" alt="Image Creation Architecture"></div></div></div><br class="figure-break"><div class="variablelist"><dl class="variablelist"><dt><span class="term">(1) Unpacked Image</span></dt><dd><p>
      Encapsulated system reachable via chroot
     </p></dd><dt><span class="term">(2) Packed Image</span></dt><dd><p>
      Encapsulated system reachable via kernel file system/extension drivers
      such as loopback mounts, etc.
     </p></dd></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.workflow.buildprocess.prepare"></a>3.1.1. The Prepare Step<span class="permalink"><a alt="Permalink" title="3.1.1. The Prepare Step" href="#sec.workflow.buildprocess.prepare">¶</a></span></h3></div></div></div><p>
    The creation of an image with KIWI is a two step process. The first step
    is called the <code class="literal">prepare</code> step and it must complete
    successfully before the second step, the <code class="literal">create</code> step
    can be executed.
   </p><p>
    During the prepare step, KIWI creates an <span class="emphasis"><em>unpacked
    image</em></span>, also called <span class="quote">“<span class="quote">root tree</span>”</span>. The new root tree
    is created in a directory specified on the command line with the
    <code class="option">--root</code> argument or the value of the <code class="sgmltag-element">defaultroot</code> element in the
    <code class="filename">config.xml</code> file. This directory will be the
    installation target for software packages to be installed during the image
    creation process.
   </p><p>
    For package installation, KIWI relies on the package manager specified
    with the <code class="sgmltag-element">packagemanager</code> element in the
    <code class="filename">config.xml</code> file. KIWI supports the following package
    managers: <code class="systemitem">smart</code>, <code class="systemitem">zypper</code>
    (default), <code class="systemitem">yum</code> and <code class="systemitem">apt</code>.
   </p><p>
    The prepare step consists of the following substeps::
   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><b>Create Target Root Directory. </b><a class="indexterm" name="idm139781533527008"></a>
       KIWI will exit with an error if the target root tree already exists to
       prevent accidental deletion of an existing unpacked image. Using the
       <code class="option">--force-new-root</code> command line argument will force kiwi
       to delete the existing target directory and create a new unpacked image
       in a new directory with the same name.
      </p></li><li class="listitem"><p><b>Install Packages. </b><a class="indexterm" name="idm139781529987936"></a>
       Initially KIWI configures the package manager to use the repositories
       specified in the configuration file and/or the command line. Following
       the repository setup the packages specified in the <code class="sgmltag-attribute">bootstrap</code><a class="indexterm" name="idm139781531470352"></a> section of the configuration file
       are installed in a temporary workspace external to the target root
       tree. This establishes the initial environment, to support the
       completion of the process in chroot setting. The essential packages to
       specify as part of the bootstrap environment are the
       <span class="package">filesystem</span> and <span class="package">glibc-locale</span>
       packages. The dependency chain of these two packages is sufficient to
       populate the bootstrap environment with all required software to
       support the installation of packages into the new root tree.
      </p><p>
      The installation of software packages through the selected package
      manager may install unwanted packages. Removing such packages can
      be accomplished by marking them for deletion in the configuration
      file. To do so specify a configuration entry like:
     </p><pre class="screen">&lt;package type="delete"&gt;<em class="replaceable"><code>package_to_be_deleted</code></em>&lt;/package&gt;</pre></li><li class="listitem"><p><b>Apply The Overlay Tree. </b><a class="indexterm" name="idm139781531910352"></a>
      After the package installation is complete, KIWI will apply all files
      and directories present in the overlay directory named
      <span class="emphasis"><em>root</em></span> to the target root tree. Files already present
      in the target root directory will be overwritten, others will be
      added. This allows you to overwrite any file that was installed by one
      of the packages during the installation phase.
     </p></li><li class="listitem"><p><b>Apply Archives. </b><a class="indexterm" name="idm139781530973248"></a>
      Any archive specified with the <code class="sgmltag-element">archive</code> element in the
      <code class="filename">config.xml</code> file is applied in the specified order
      (top to bottom) after the overlay tree copy operation is complete. Files
      and directories will be extracted relative to the top level of the new
      root tree. As with the overlay tree, it is possible to overwrite files
      already existing in the target root tree.
     </p></li><li class="listitem"><p><b>
      Execute the User-defined Script <code class="filename">config.sh</code>
     . </b><a class="indexterm" name="idm139781529153328"></a>
      At the end of the preparation stage the script named
      <code class="filename">config.sh</code> is executed if present. It is executed on
      the top level of the target root tree. The script's primary function is to
      complete the system configuration, for example by activating services.
      For a detailed description of pre-defined configuration functions
      consult the <a class="xref" href="#ref.kiwi.config.sh" title="kiwi::config.sh"><span class="refentrytitle">kiwi::config.sh</span>(1)</a> man page.
     </p></li><li class="listitem"><p><b>Manage The New Root Tree. </b><a class="indexterm" name="idm139781529882016"></a>
      The unpacked image directory is a directory, as far as the build system
      is concerned and you can manipulate the content of this directory
      according to your needs. Since it represents a system installation you
      can <span class="quote">“<span class="quote">chroot</span>”</span> into this directory for testing purposes. The
      file system contains an additional directory named <code class="filename">/image</code><a class="indexterm" name="idm139781532578320"></a> that is not present in a regular
      system. It contains information KIWI requires during the create step,
      including a copy of the <code class="filename">config.xml</code> file.
     </p><p>
     Do not make any changes to the system, since they will get lost when
     re-running the <code class="literal">prepare</code> step again. Whats more, you may
     introduce errors that will occur during the <code class="literal">create</code>
     step, that are difficult to track. The recommended way to apply changes
     to the unpacked image directory is to change the configuration and re-run
     the <code class="literal">prepare</code> step.
    </p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.workflow.buildprocess.create"></a>3.1.2. The Create Step<span class="permalink"><a alt="Permalink" title="3.1.2. The Create Step" href="#sec.workflow.buildprocess.create">¶</a></span></h3></div></div></div><p>
   The successful completion of the <code class="literal">prepare</code> step is a
   prerequisite for the <code class="literal">create</code> step. It ensures the
   unpacked root tree is complete and consistent. Creating the packed, or
   final, image is done in the <code class="literal">create</code> step. Multiple
   images can be created using the same unpacked root tree. It is, for
   example, possible to create a self installing OEM image and a virtual
   machine image from a single unpacked root tree. The only prerequisite is
   that both image types are specified in the <code class="filename">config.xml</code>
   before the prepare step is executed.
  </p><p>
   During the <code class="literal">create</code> step the following major operations
   are performed by kiwi:
  </p><div class="orderedlist"><a class="indexterm" name="idm139781532988208"></a><ol class="orderedlist" type="1"><li class="listitem"><p><b>
      Execute the User-defined Script <code class="filename">images.sh</code>
     . </b><a class="indexterm" name="idm139781532985216"></a>
      At the beginning of the image creation process the script named
      <code class="filename">images.sh</code> is executed if present. It is executed on
      the top level of the target root tree. The script is usually used to
      remove files that are no needed in the final image. For example, if an
      appliance is being built for a specific hardware, unnecessary kernel
      drivers can be removed using this script. Consult the <a class="xref" href="#ref.kiwi.images.sh" title="kiwi::images.sh"><span class="refentrytitle">kiwi::images.sh</span>(1)</a> man page for a detailed description of
      pre-defined functions available in the <code class="filename">images.sh</code>
      script.
     </p></li><li class="listitem"><p><b>Create Requested Image Type. </b><a class="indexterm" name="idm139781532979920"></a>
      The image types that can be created from a prepared image tree depend on
      the types specified in the image description
      <code class="filename">config.xml</code> file. The configuration file must
      contain at least one <code class="sgmltag-element">type</code>
      element. The figure below shows the currently supported image types:
     </p><div class="figure"><a name="fig.imagetypes"></a><p class="title"><b>Figure 3.2. Image Types</b><span class="permalink"><a alt="Permalink" title="Figure 3.2. Image Types" href="#fig.imagetypes">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><img src="images/types.png" alt="Image Types"></div></div></div><br class="figure-break"><div class="variablelist"><dl class="variablelist"><dt><span class="term">(1) Live Image</span></dt><dd><p>
        For CDs, DVDs or flash disks.
       </p></dd><dt><span class="term">(2) Disk Image</span></dt><dd><p>
        Virtual system disk that can be used in virtual environments such as
        VMware, Xen, Amazon Cloud, KVM, and others. Depending on the format a
        guest configuration file is created.
       </p></dd><dt><span class="term">(3) OEM Image</span></dt><dd><p>
        Preload system for install media CD/DVD or flash disk.
       </p></dd><dt><span class="term">(4) PXE Image</span></dt><dd><p>
        Network boot image. KIWI also provides the bootp environment via the
        package <span class="package">kiwi-pxeboot</span>.
       </p></dd></dl></div></li></ol></div><p>
   Detailed information, including step-by-step instructions on building
   specific images can be found in <a class="xref" href="#part.usecases" title="Part II. Usecases">Part II, “Usecases”</a>. That part
   of the manual explains how to build a <span class="quote">“<span class="quote">Just enough Operation
   System</span>”</span> (JeOS) image from a KIWI template for all supported image
   types.
  </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.bootprocess"></a>3.2. Customizing the Boot Process<span class="permalink"><a alt="Permalink" title="3.2. Customizing the Boot Process" href="#sec.workflow.bootprocess">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781532960352"></a><p>
   Most Linux systems use a special boot image to control the system boot
   process after the system firmware, BIOS or UEFI, hands control of the
   hardware to the operating system. This boot image is called the
   <span class="emphasis"><em>initrd</em></span>. The Linux kernel loads the initrd, a
   compressed cpio initial RAM disk, into the RAM and executes
   <span class="emphasis"><em>init</em></span> or, if present, <span class="emphasis"><em>linuxrc</em></span>.
  </p><p>
   Depending on the image type, KIWI creates the boot image automatically
   during the <span class="emphasis"><em>create</em></span> step. Each image type has
   its own description for the boot image. Common functionality is shared
   between the boot images through a set of functions. The boot image
   descriptions follow the same principles as the system image descriptions,
   KIWI ships with pre-defined boot image descriptions.
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Boot Image Descriptions provided by KIWI</h3><p>
    The boot image descriptions provided by KIWI cover almost all use cases.
    Creating custom boot descriptions should not be necessary, unless you have
    special requirements.
   </p></div><div class="figure"><a name="fig.workflow.imagedescriptions"></a><p class="title"><b>Figure 3.3. Image Descriptions</b><span class="permalink"><a alt="Permalink" title="Figure 3.3. Image Descriptions" href="#fig.workflow.imagedescriptions">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><img src="images/activation.png" alt="Image Descriptions"></div></div></div><br class="figure-break"><div class="variablelist"><dl class="variablelist"><dt><span class="term">(1) Boot Image</span></dt><dd><p>
      Boot image descriptions are provided by KIWI, use is recommended but
      not required.
     </p></dd><dt><span class="term">(2) System Image</span></dt><dd><p>
      The system image description is created by the KIWI user, or a KIWI
      provided template may be used.
     </p></dd></dl></div><p>
   The boot image descriptions are stored in the
   <code class="filename">/usr/share/kiwi/image/*boot</code><a class="indexterm" name="idm139781532944240"></a>
   directories. KIWI selects the boot image based on the value of
   the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm139781529112000"></a> attribute of the
   <code class="sgmltag-element">type</code> element. The attribute value is
   expected in the general form of <span class="emphasis"><em>
   <em class="replaceable"><code>boottype</code></em>/<em class="replaceable"><code>distribution</code></em>
   </em></span>. For example to select the OEM boot image for SLES version 12
   the element would look like the following:
  </p><pre class="screen">&lt;type boot="oemboot/suse-SLES12"&gt;</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Difference Between Boot Image and System Image Descriptions</h3><p>
    The <span class="emphasis"><em>boot image description</em></span> only represents the initrd
    used to boot the system and as such serves a limited purpose. The boot image
    descriptions is used to build the boot image independently from the
    system image. Usually a pre-defined boot image descriptions shipped with
    KIWI is used.
   </p><p>
    The system image description is used to build the image running on the
    target system. It is manually created and usually tailor-made for a
    specific use case.
   </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">De-activating Hooks at Boot Time</h3><p>
    The execution of hooks can be globally deactivated by passing the
    following variable to the kernel command line:
   </p><pre class="screen">KIWI_FORBID_HOOKS=1</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.hooks"></a>3.2.1. Boot Image Hook-Scripts<span class="permalink"><a alt="Permalink" title="3.2.1. Boot Image Hook-Scripts" href="#sec.hooks">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781529103024"></a><a class="indexterm" name="idm139781529101888"></a><p>
   All KIWI created boot images contain kiwi boot code that gets executed
   when the image is booted for the first time. This boot code differs from
   image type to image type. It provides hooks to execute user defined
   shell scripts.
  </p><p>
   These scripts may extend the firstboot process and are expected to exist
   inside the boot image in a specific location with specific names. The
   following instructions explain the concept of hook scripts, which is common
   to all image types, and how to include the scripts in the initrd.
  </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.hooks.types"></a>3.2.1.1. Script Types<span class="permalink"><a alt="Permalink" title="3.2.1.1. Script Types" href="#sec.hooks.types">¶</a></span></h4></div></div></div><p>
    Hook scripts are executed using a predetermined name that is hard coded
    into the kiwi boot code. This name is extended using the
    <code class="filename">.sh</code> extension and differs by boot image type.
    Therefore, the boot script naming in the archive must be exact. Boot
    scripts are sourced in the kiwi boot code. This provides the hook script
    access to all variables set in the boot environment. This also implies
    that no separate shell process is started and the boot scripts do not need
    to have the executable bit set. Encoding the interpreter location with the
    <code class="literal">#!</code> comment is superfluous.
   </p><p>
    The following list provides information about the hook names, timing of
    the execution, and the applicable boot image.
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-element">handleSplash</code></span></dt><dd><p>
       This hook is called prior to any dialog/exception message or progress
       dialog. The hook can be used to customize the behavior of the splash
       screen. KIWI automatically hides a plymouth or kernel based splash
       screen if there is only one active console.
      </p></dd><dt><span class="term"><code class="sgmltag-element">init</code></span></dt><dd><p>
       This hook is called before udev is started. It exists only for the
       <span class="emphasis"><em>PXE</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preconfig</code>|<code class="sgmltag-element">postconfig</code></span></dt><dd><p>
       The hooks are called before and after the client configuration files
       (CONF contents) are setup, respectively. The hooks only exist for the
       <span class="emphasis"><em>PXE</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">predownload</code>|<code class="sgmltag-element">postdownload</code></span></dt><dd><p>
       The hooks are called before and after the client image receives the
       root file system, respectively. The hooks only exist for the
       <span class="emphasis"><em>PXE</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preImageDump</code>|<code class="sgmltag-element">postImageDump</code></span></dt><dd><p>
       The hooks are called before and after the install image is dumped on
       the target disk, respectively. The hooks only exist for the
       <span class="emphasis"><em>OEM</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preLoadConfiguration</code>|<code class="sgmltag-element">postLoadConfiguration</code></span></dt><dd><p>
       The hooks are called before and after the client configuration file
       <code class="filename">config.MAC</code> is loaded, respectively. The hooks only
       exist for the <span class="emphasis"><em>PXE</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">premount</code>|<code class="sgmltag-element">postmount</code></span></dt><dd><p>
       The hooks are called before and after the client root file system is
       mounted, respectively. The hooks only exist for the
       <span class="emphasis"><em>PXE</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">prenetwork</code>|<code class="sgmltag-element">postnetwork</code></span></dt><dd><p>
       The hooks are called before and after the client network is setup,
       respectively. The hooks only exist for the <span class="emphasis"><em>PXE</em></span>
       image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">prepartition</code>|<code class="sgmltag-element">postpartition</code></span></dt><dd><p>
       The hooks are called before and after the client creates the partition
       table on the target disk, respectively. The hooks only exist for the
       <span class="emphasis"><em>PXE</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preprobe</code>|<code class="sgmltag-element">postprobe</code></span></dt><dd><p>
       The hooks are called before and after the loading of modules not
       handled by udev, respectively. The hooks only exist for the
       <span class="emphasis"><em>PXE</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preswap</code>|<code class="sgmltag-element">postswap</code></span></dt><dd><p>
       The hooks are called before and after the creation of the swap space,
       respectively. The hooks only exist for the <span class="emphasis"><em>PXE</em></span>
       image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preactivate</code></span></dt><dd><p>
       This hook is called before the root file system is moved to
       <code class="filename">/</code>. The hook only exists for the
       <span class="emphasis"><em>pxe</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preCallInit</code></span></dt><dd><p>
       This hook is called before the initialization process, init or systemd,
       is started. At call time the root file system has already been moved to
       <code class="filename">/</code>.. The hook only exists for the
       <span class="emphasis"><em>OEM</em></span> and <span class="emphasis"><em>VMX</em></span> image types.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preRecovery</code>|<code class="sgmltag-element">postRecovery</code></span></dt><dd><p>
       This hook is called before and after the recovery code is processed.
       At call time of preRecovery the recovery partition is not yet mounted.
       At call time of postRecovery the recovery partition is still mounted
       on <code class="filename">/reco-save</code>. The hook only exists for the
       <span class="emphasis"><em>OEM</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preRecoverySetup</code>|<code class="sgmltag-element">postRecoverySetup</code></span></dt><dd><p>
       This hook is called before and after the recovery setup is processed.
       At call time of preRecoverySetup the recovery partition is not yet
       mounted. At call time of postRecoverySetup the recovery partition is
       still mounted on <span class="emphasis"><em>/reco-save</em></span>. The hook only exists
       for the <span class="emphasis"><em>OEM</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preException</code></span></dt><dd><p>
       This hook is called before a system error is handled. The error
       message is passed as parameter. This hook can be used for all image
       types.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preHWdetect</code>|<code class="sgmltag-element">postHWdetect</code></span></dt><dd><p>
       The hooks are called before and after the install image boot code
       detects the possible target storage device(s). The hooks only exist
       for the <span class="emphasis"><em>OEM</em></span> image type.
      </p></dd><dt><span class="term"><code class="sgmltag-element">preNetworkRelease</code></span></dt><dd><p>
       This hook is called before the network connection is released. The
       hook only exists for the <span class="emphasis"><em>PXE</em></span> image type.
      </p></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.hooks.include"></a>3.2.1.2. Including Hook Scripts into the Boot Image<span class="permalink"><a alt="Permalink" title="3.2.1.2. Including Hook Scripts into the Boot Image" href="#sec.hooks.include">¶</a></span></h4></div></div></div><p>
    All hook scripts must be located in the <code class="filename">kiwi-hooks</code><a class="indexterm" name="idm139781529030688"></a> directory at the top level of the
    initrd. The best approach to including the hook scripts in the initrd is
    to create an archive of a <code class="filename">kiwi-hooks</code><a class="indexterm" name="idm139781529028784"></a> directory that contains the custom
    boot scripts.
    </p><pre class="screen"><span class="command"><strong>mkdir</strong></span> kiwi-hooks
<em class="replaceable"><code>place all scripts inside kiwi-hooks</code></em>
<span class="command"><strong>tar</strong></span> -cf kiwi-hooks.tgz kiwi-hooks/</pre><p>
     The TAR archive must be located at the top level of the image description
     directory, this is the same level that contains the
     <code class="filename">config.xml</code> file.
   </p><p>
     Hook scripts are only executed from within kiwi's boot code and must
     therefore be part of the KIWI created boot image. Including the content
     of a TAR archive in the initrd is accomplished by setting the value of
     the <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm139781529023264"></a> attribute of the
     <code class="sgmltag-element">archive</code> element to <code class="sgmltag-attvalue">true</code> in the <code class="filename">config.xml</code>
     file as shown below:
    </p><pre class="screen">&lt;packages type="image"&gt;
  &lt;archive name="kiwi-hooks.tgz" bootinclude="true"/&gt;
&lt;/packages&gt;</pre><p>
     The concept of including an archive in the boot image follows the same
     concepts described for the system image previously. To use an
     archive in a pre-built boot image the archive must be part of the boot
     image description in which case it is not necessary to set the
     <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm139781529018368"></a>
     attribute.
    </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.hooks.post"></a>3.2.1.3. Post Commands<span class="permalink"><a alt="Permalink" title="3.2.1.3. Post Commands" href="#sec.hooks.post">¶</a></span></h4></div></div></div><p>
    In addition to the hook script itself it is also possible to run a post
    command after the hook script was called. This allows to run commands tied
    to a hook script without changing the initrd and thus provides a certain
    flexibility when writing the hook. The post command execution is based on
    variables that can be passed to the kernel command line. The following
    rules for the processing post commands apply:
   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      Command post processing needs to be activated within the corresponding
      hook script. this is achieved by setting the variable
      <code class="envar">KIWI_ALLOW_HOOK_CMD_<em class="replaceable"><code>HOOKNAME</code></em></code><a class="indexterm" name="idm139781529013472"></a>
      to <code class="literal">1</code>. For example:
     </p><pre class="screen">KIWI_ALLOW_HOOK_CMD_preHWdetect=1</pre><p>
      This will activate the post command execution for the
      <code class="literal">preHWdetect</code> hook. If this variable is not set, the
      post command will not be executed.
     </p></li><li class="listitem"><p>
      The corresponding variable
      <code class="envar">KIWI_HOOK_CMD_<em class="replaceable"><code>HOOKNAME</code></em></code><a class="indexterm" name="idm139781529008752"></a> needs
      to passed to the Kernel command line. Its value contains the command
      that is to be executed, for example:
     </p><pre class="screen">KIWI_HOOK_CMD_preHWdetect="ls -l"</pre><p>
      This will cause the <code class="literal">preHWdetect</code> hook to call
      <span class="command"><strong>ls -l</strong></span> at the end of the hook script code.
     </p></li><li class="listitem"><p>

     </p></li></ol></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Disable Post Command Execution at Boot Time</h3><p>
     To disable all post commands for the current boot process pass the
     following variable to the Kernel command line:
    </p><pre class="screen">KIWI_FORBID_HOOK_CMDS=1</pre></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.bootcustomization"></a>3.2.2. FAQ: Boot Image Customization<span class="permalink"><a alt="Permalink" title="3.2.2. FAQ: Boot Image Customization" href="#sec.bootcustomization">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781529001264"></a><a class="indexterm" name="idm139781529000128"></a><p>
   The KIWI provided boot image descriptions should satisfy the requirements
   for a majority of image builds and the environments in which these images
   are deployed. In case a customized boot image is needed, KIWI provides
   appropriate  configuration options in <code class="filename">config.xml</code>.
  </p><p>
   Using these options allows users to base the boot image on
   the KIWI provided descriptions rather than having to define a configuration
   from scratch (however, this is possible if wanted). The following
   question and answer section provides solutions to the most common
   scenarios that require a customized boot image.
  </p><div class="qandaset"><a name="idm139781528997216"></a><dl><dt>Q: <a href="#idm139781528996720">
      Why is the boot image so big? Can I reduce its size ?
     </a></dt><dt>Q: <a href="#idm139781528989200">
      Can drivers be added to the boot image?
     </a></dt><dt>Q: <a href="#idm139781528980016">
      How to add missing tools or libraries?
     </a></dt><dt>Q: <a href="#idm139781528968768">
      Is it possible to add boot code?
     </a></dt><dt>Q: <a href="#idm139781528965840">
      Is it possible to include completely customized boot code?
     </a></dt><dt>Q: <a href="#idm139781528963456"></a></dt></dl><table border="0" style="width: 100%;"><colgroup><col align="left" width="1%"><col></colgroup><tbody><tr class="question"><td align="left" valign="top"><a name="idm139781528996720"></a><a name="idm139781528996464"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
      Why is the boot image so big? Can I reduce its size ?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
      KIWI includes all required tools and libraries to boot the image under
      all circumstances in all target environments supported by the image
      type. In case the target environment is well defined it is possible to
      remove libraries, drivers and tools not needed in the target
      environment.
     </p><p>
      This will decrease the size of the initrd and will also decrease boot
      time. Removing files in the boot image is accomplished by adding a
      <code class="sgmltag-element">strip</code> section to the system image in
      the <code class="filename">config.xml</code> file, with the <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781528992464"></a> attribute set to <code class="sgmltag-attvalue">delete</code>, as shown below:
     </p><pre class="screen">&lt;strip type="delete"&gt;
    &lt;file name="..."/&gt;
&lt;/strip&gt;</pre><p>
      Removing files that are needed may result in an image that cannot be
      booted.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139781528989200"></a><a name="idm139781528988944"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
      Can drivers be added to the boot image?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
      KIWI uses a subset of the Kernel. Therefore drivers shipped with the
      Kernel that have not been included by the KIWI build process, can be
      added. Do so by adding a <code class="sgmltag-element">drivers</code>
      section to the system image configuration file
      <code class="filename">config.xml</code>, as follows:
     </p><pre class="screen">&lt;drivers&gt;
  &lt;file name="drivers/..."/&gt;
&lt;/drivers&gt;</pre><p>
      If the driver is provided by a package, the package itself needs to be
      specified as part of the <code class="sgmltag-attvalue">image</code>
      package section. Additionally, it must be marked for boot image
      inclusion by setting the value of the <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm139781528983664"></a> attribute of the <code class="sgmltag-element">package</code> element to <code class="sgmltag-attvalue">true</code>, as follows:
     </p><pre class="screen">&lt;packages type="image"/&gt;
  &lt;package name="<em class="replaceable"><code>PACKAGE</code></em>" bootinclude="true"/&gt;
&lt;/packages&gt;</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139781528980016"></a><a name="idm139781528979760"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
      How to add missing tools or libraries?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
      Additional software can be added to the boot image with the use of the
      <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm139781528977888"></a> attribute of the
      <code class="sgmltag-element">package</code> or the <code class="sgmltag-element">archive</code> element. At the end of the boot image
      creation process kiwi attempts to reduce the size of the boot image by
      removing files that are not part of a known list of required files or
      their dependencies.
     </p><p>
      The list of required files is hard coded in the
      <code class="filename">/usr/share/kiwi/modules/KIWIConfig.txt</code> file.  If
      you added files to the boot image that are needed for your specific use
      case, you need to instruct kiwi to not strip them from the image. This
      is accomplished by adding a <code class="sgmltag-element">strip</code>
      section to the system image <code class="filename">config.xml</code> file, with
      the <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781528972336"></a> attribute set to <code class="sgmltag-attvalue">tools</code>, as follows:
     </p><pre class="screen">&lt;strip type="tools"/&gt;
  &lt;file name="<em class="replaceable"><code>FILENAME</code></em>"/&gt;
&lt;/strip&gt;</pre><p>
      The removal/preservation of files is name-based only, so you do not need
      to specify a complete path, but rather the file name.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139781528968768"></a><a name="idm139781528968512"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
      Is it possible to add boot code?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
      Yes, as described in the <a class="xref" href="#sec.hooks" title="3.2.1. Boot Image Hook-Scripts">Section 3.2.1, “Boot Image Hook-Scripts”</a> section above,
      KIWI supports the execution of boot code at various times for various
      image types using <span class="emphasis"><em>hook</em></span> scripts.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139781528965840"></a><a name="idm139781528965584"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
      Is it possible to include completely customized boot code?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
      No. In cases where the provided hooks are insufficient and the KIWI
      provided boot code needs to be replaced completely, it is necessary to
      create a custom boot image description. In this case, all parts of the
      boot image description must be created by the user. It is best to use
      one of the KIWI provided boot descriptions as a template.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a name="idm139781528963456"></a><a name="idm139781528963200"></a><p><b>Q:</b></p></td><td align="left" valign="top"><a class="indexterm" name="idm139781528962944"></a><a class="indexterm" name="idm139781528961552"></a><p>
      My customized boot image refuses to boot. How to debug?
     </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
      An initrd created by KIWI that is based on one of the KIWI- provided
      boot image descriptions recognizes kernel parameters that are useful for
      debugging purposes, in case the image does not boot. These parameters
      may not work if the image contains a custom boot image where the kiwi
      boot code has been completely.
     </p></td></tr></tbody></table></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.workflow.bootparameters"></a>3.2.3. Boot Parameters<span class="permalink"><a alt="Permalink" title="3.2.3. Boot Parameters" href="#sec.workflow.bootparameters">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781528957680"></a><a class="indexterm" name="idm139781528956544"></a><p>
   A KIWI created initrd based on one of the KIWI provided boot image
   descriptions recognizes kernel parameters that are useful for debugging
   purposes, should the image not boot. These parameters may not work if the
   image contains a custom boot image where the kiwi boot code has been
   replaced, and the parameters are not recognized after the initial KIWI
   created initrd has been replaced by the "regular" distribution created
   initrd after the initial boot of the image.
  </p><p>
   If the boot process encounters a fatal error, the default behavior is
   to reboot the system after 120 seconds. Prevent this behavior by specifying
  </p><pre class="screen">kiwidebug=1</pre><p>
   on the Kernel command line. With that parameter set to
   <code class="literal">1</code>, the system will enter a limited shell environment in
   case of a fatal during boot. The shell contains a basic set of commands.
   The first place to look for debugging information should be the boot log
   file <code class="filename">/var/log/kiwi.boot</code>.
  </p><p>
   In addition to the shell, KIWI also starts the <code class="systemitem">dropbear</code><a class="indexterm" name="idm139781528950160"></a> SSH server if the environment is
   suitable. Support for <code class="systemitem">dropbear</code><a class="indexterm" name="idm139781528948336"></a> can
   be added to the netboot and oemboot (in PXE boot mode) boot images. For
   isoboot and vmxboot boot images there is no remote login support because
   they do not set up a network. It is required that the repository setup
   provides <span class="package">dropbear</span>.
  </p><p>
   To have dropbear installed as part of the boot image the following
   needs to be added to the system image configuration:
  </p><pre class="screen">&lt;packages type="image"/&gt;
  &lt;package name="dropbear" bootinclude="true"/&gt;
&lt;/packages&gt;</pre><p>
   It might be useful to also include a tool for copying remote files, such
   as <span class="command"><strong>scp</strong></span> or <span class="command"><strong>rsync</strong></span> into the boot
   image. Note that the required packages need to be provided by the
   repositories configured. To include <span class="command"><strong>rsync</strong></span>, for example,
   add the line
   <code class="literal">&lt;package name="rsync" bootinclude="true"/&gt;</code>
   to the listing above.
  </p><p>
   To access the boot image via SSH it is required to provide a
   public key on the PXE server in the directory:
   <code class="filename"><em class="replaceable"><code>SERVER-ROOT</code></em>/KIWI/debug_ssh.pub</code>. KIWI
   exclusively searches for that file name, so it is required to name it
   <code class="filename">debug_ssh.pub</code>. <em class="replaceable"><code>SERVER-ROOT</code></em>
   depends on what server type was configured to download the image. By
   default this is done via TFTP. In that case
   <em class="replaceable"><code>SERVER-ROOT</code></em> translates to
   <code class="filename">/srv/tftpboot</code> ion the PXE server. Adjust the path
   accordingly if having used HTTP or FTP.
  </p><p>
   Adding more than one public key to file is possible, the file uses the same
   format as the common SSH file <span class="quote">“<span class="quote">authorized_keys</span>”</span>. If a public
   key was found you can login as follows:
  </p><pre class="screen">ssh root@<em class="replaceable"><code>IP-ADDRESS</code></em></pre><p>
   In case <span class="command"><strong>rsync</strong></span> is available, you can copy the KIWI boot
   log to your local machine as follows:
  </p><pre class="screen">RSYNC_RSH='ssh -l root'
rsync -avz &lt;ip&gt;:/var/log/boot.kiwi</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.common-specific-code"></a>3.3. Distribution-Specific Code<span class="permalink"><a alt="Permalink" title="3.3. Distribution-Specific Code" href="#sec.workflow.common-specific-code">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781528933536"></a><p>
   KIWI is designed to be distribution-independent. However, Linux
   distributions differ from each other, primarily in the package management
   area and in the area of creation and composition of the boot image. Within
   the KIWI code base major areas of Linux distribution differences are
   isolated into specific regions of the code. The remainder of the code is
   common and distribution- independent.
  </p><p>
   KIWI-provided functions that are distribution-specific contain the
   distribution name as a prefix, such as
   <code class="literal">suseStripKernel</code>. Scripts that are part of the boot
   code and are distribution-specific are identified by a prefix of the
   distribution name followed by a <span class="quote">“<span class="quote">-</span>”</span>, for example
   <code class="literal">suse-linuxrc</code>. When KIWI creates a boot
   image for a SUSE distribution the <span class="command"><strong>suse-linuxrc</strong></span> file
   from the boot description is used as the <span class="command"><strong>linuxrc</strong></span> file
   that the Linux kernel calls.
  </p><p>
   With this design it is possible to maintain distribution-specific code in
   the project while also providing explicit hints to the user when
   distribution specific code is being used.  The implementation of
   SUSE-specific code can be used as a guideline to support other
   distributions.
  </p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.description"></a>Chapter 4. KIWI Image Description</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.description.config.xml">4.1. The config.xml File</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.description.image">4.1.1. <code class="sgmltag-element">image</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.description">4.1.2. <code class="sgmltag-element">description</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.profiles">4.1.3. <code class="sgmltag-element">profiles</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.preferences">4.1.4. <code class="sgmltag-element">preferences</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.users">4.1.5. <code class="sgmltag-element">users</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.drivers">4.1.6. <code class="sgmltag-element">drivers</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.repository">4.1.7. <code class="sgmltag-element">repository</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.packages">4.1.8. <code class="sgmltag-element">packages</code> Element</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm139781528925696"></a><p>
  To be able to create an image with KIWI, a so called image
  description must be created. The image description is represented by a
  directory which needs to contain at least one file named
  <code class="filename">config.xml</code> or
  <code class="filename">*.kiwi</code><a class="indexterm" name="idm139781528922608"></a>. A good start for such
  a description can be found in the examples provided in
  <code class="filename">/usr/share/doc/packages/kiwi/examples</code>.
 </p><p class="remark"><em><span class="remark">
  2015-07-24 - fs: TODO
 </span></em></p><p class="remark"><em><span class="remark">
  1. Explain templates (packages, overview of templates, where to find them, how to use them, how to customize)
 </span></em></p><p class="remark"><em><span class="remark">
  2. How to manually validate, editor support (loading schema or DTD)
 </span></em></p><p class="remark"><em><span class="remark">
  3. Shorten, restructure for a better readability
 </span></em></p><p class="remark"><em><span class="remark">
  4. Point to schema description, explain how to use/read it
 </span></em></p><div class="figure"><a name="fig.description.imagedescrdir"></a><p class="title"><b>Figure 4.1. Image Description Directory</b><span class="permalink"><a alt="Permalink" title="Figure 4.1. Image Description Directory" href="#fig.description.imagedescrdir">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="40%"><tr><td><img src="images/description.png" width="100%" alt="Image Description Directory"></td></tr></table></div></div></div><br class="figure-break"><p>
  The following additional information is optional for the process of
  building an image, but most often mandatory for the functionality of the
  created operating system:
 </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="filename">images.sh</code>
   </span></dt><dd><p>
     Optional configuration script while creating the packed image. This
     script is called at the beginning of the image creation process. It is
     designed to clean-up the image system. Affected are all the programs
     and files only needed while the unpacked image exists.
    </p></dd><dt><span class="term"><code class="filename">config.sh</code>
   </span></dt><dd><p>
     Optional configuration script while creating the unpacked image. This
     script is called at the end of the installation, but
     <span class="emphasis"><em>before</em></span> the package scripts have run. It is
     designed to configure the image system, such as the activation or
     deactivation of certain services
     (<code class="systemitem">insserv</code><a class="indexterm" name="idm139781528906224"></a>). The
     call is not made until after the switch to the image has been made with
     chroot.
    </p></dd><dt><span class="term"><code class="filename">root</code><a class="indexterm" name="idm139781528903600"></a>
   </span></dt><dd><p>
     Subdirectory that contains special files, directories, and scripts for
     adapting the image environment <span class="emphasis"><em>after</em></span> the
     installation of all the image packages. The entire directory is copied
     into the root of the image tree using <span class="command"><strong>cp</strong></span>
     <code class="option">-a</code>.
    </p></dd><dt><span class="term"><code class="filename">config-yast-autoyast.xml</code>
   </span></dt><dd><p>
     Configuration file which has been created by AutoYaST. To be able to
     create such an AutoYaST profile, run:
    </p><pre class="screen"><span class="command"><strong>yast2</strong></span> autoyast</pre><p>
     Once you have saved the information from the AutoYaST UI as
     <code class="filename">config-yast-autoyast.xml</code> file in your image
     description directory KIWI will process on the file and setup your
     image as follows:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
       While booting the image YaST is started in AutoYaST mode
       automatically
      </p></li><li class="listitem"><p>
       The AutoYaST description is parsed and the instructions are handled
       by YaST. In other words the <span class="emphasis"><em>system configuration</em></span>
       is performed
      </p></li><li class="listitem"><p>
       If the process finished successfully the environment is cleaned and
       AutoYaST won’t be called at next reboot.
      </p></li></ol></div></dd><dt><span class="term"><code class="filename">config-cdroot.tgz</code>
   </span></dt><dd><p>
     Archive which is used for ISO images only. The data in the archive is
     uncompressed and stored in the CD/DVD root directory. This archive can
     be used, for example, to integrate a license file or information
     directly readable from the CD or DVD.
    </p></dd><dt><span class="term"><code class="filename">config-cdroot.sh</code>
   </span></dt><dd><p>
     Along with the <code class="filename">config-cdroot.tgz</code> one can provide a
     script which allows to manipulate the extracted data.
    </p></dd><dt><span class="term"><code class="filename">config/</code><a class="indexterm" name="idm139781528885120"></a>
   </span></dt><dd><p>
     Optional subdirectory that contains Bash scripts that are called after
     the installation of all the image packages, primarily to
     remove the parts of a package that are not needed for the operating
     system. The name of the Bash script must resemble the package name
     listed in the config.xml.
    </p></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.description.config.xml"></a>4.1. The config.xml File<span class="permalink"><a alt="Permalink" title="4.1. The config.xml File" href="#sec.description.config.xml">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781528881872"></a><p>
   The mandatory image definition file is divided into different sections
   which describes information like the image name and type as well as the
   packages and patterns the image should consist of.
  </p><p>
   The following information explains the basic structure of the XML
   document. When KIWI is executed, the XML structure is validated by the
   KIWI RELAX NG based schema. For details on attributes and values
   please refer to the schema documentation file at
   <code class="filename">/usr/share/doc/packages/kiwi/kiwi.rng.html</code>.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.image"></a>4.1.1. <code class="sgmltag-element">image</code> Element<span class="permalink"><a alt="Permalink" title="4.1.1. image Element" href="#sec.description.image">¶</a></span></h3></div></div></div><pre class="screen">&lt;image schemaversion="6.2" name="iname"
  displayname="text"
  kiwirevision="number"
  id="10 digit number"&gt;
  <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code>
&lt;/image&gt;</pre><p>
    The image definition starts with an <code class="sgmltag-element">image</code> tag and
    requires the schema format at version 2.0. The attribute
    <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm139781528874592"></a> specifies the name of the
    image which is also used for the filenames created by KIWI. Because we
    don’t want spaces in filenames the
    <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm139781528872784"></a> attribute must not
    have any spaces in its name.
   </p><p>
    The following optional attributes can be inserted in the
    <code class="sgmltag-element">image</code> tag:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">displayname</code><a class="indexterm" name="idm139781528869584"></a>
     </span></dt><dd><p>
       Allows setup of the boot menu title for the selected boot loader. So
       you can have <span class="emphasis"><em>suse-SLED-foo</em></span> as the image name but
       a different name as the boot display name. Spaces are not allowed in
       the display name because it causes problems for some boot loaders and
       kiwi did not take the effort to separate the ones which can display
       them correctly from the ones which can't
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">kiwirevision</code><a class="indexterm" name="idm139781528865856"></a>
     </span></dt><dd><p>
       specifies a KIWI git revision number which is known to build a
       working image from this description. If the KIWI git revision doesn't
       match the specified value, the process will exit. The currently used
       git revision can be queried by calling <span class="command"><strong>kiwi</strong></span>
       <code class="option">--version</code>.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">id</code><a class="indexterm" name="idm139781528861648"></a>
     </span></dt><dd><p>
       sets an identification number which appears as file
       <code class="filename">/etc/ImageID</code> within the image.
      </p></dd></dl></div><p>
    Inside the <code class="sgmltag-element">image</code> section the following mandatory and
    optional subelements exists. The simplest image description must define
    the elements <code class="sgmltag-element">description</code>,
    <code class="sgmltag-element">preferences</code>, <code class="sgmltag-element">repository</code> and
    <code class="sgmltag-element">packages</code> (at least one of
    <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781528855968"></a>="<code class="sgmltag-attvalue">bootstrap</code>").
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.description"></a>4.1.2. <code class="sgmltag-element">description</code> Element<span class="permalink"><a alt="Permalink" title="4.1.2. description Element" href="#sec.description.description">¶</a></span></h3></div></div></div><pre class="screen">&lt;description type="system"&gt;
  &lt;author&gt;an author&lt;/author&gt;
  &lt;contact&gt;mail&lt;/contact&gt;
  &lt;specification&gt;short info&lt;/specification&gt;
&lt;/description&gt;</pre><p>
    The mandatory <code class="sgmltag-element">description</code> section contains
    information about the creator of this image description. The attribute
    <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781528850784"></a> could be either of
    the value system which indicates this is a system image description or
    at value boot for boot image descriptions.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.profiles"></a>4.1.3. <code class="sgmltag-element">profiles</code> Element<span class="permalink"><a alt="Permalink" title="4.1.3. profiles Element" href="#sec.description.profiles">¶</a></span></h3></div></div></div><pre class="screen">&lt;profiles&gt;
   &lt;profile name="name" description="text"/&gt;
   <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code>
&lt;/profiles&gt;</pre><p>
    The optional <code class="sgmltag-element">profiles</code> section lets you maintain one
    image description while allowing for variation of the sections packages
    and drivers that are included. A separate profile element must be
    specified for each variation. The <code class="sgmltag-element">profile</code> child
    element, which has <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm139781528845104"></a>
    and <code class="sgmltag-attribute">description</code><a class="indexterm" name="idm139781528843600"></a>
    attributes, specifies an alias name used to mark sections as belonging
    to a profile, and a short description explaining what this profile does.
   </p><p>
    To mark a set of packages/drivers as belonging to a profile, simply
    annotate them with the
    <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="idm139781528841408"></a> attribute. It
    is also possible to mark sections as belonging to multiple profiles by
    separating the names in the
    <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="idm139781528839760"></a> attribute with a comma. If
    a <code class="sgmltag-element">packages</code> or <code class="sgmltag-element">drivers</code> tag does not
    have a <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="idm139781528837488"></a>
    attribute, it is assumed to be present for all profiles.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.preferences"></a>4.1.4. <code class="sgmltag-element">preferences</code> Element<span class="permalink"><a alt="Permalink" title="4.1.4. preferences Element" href="#sec.description.preferences">¶</a></span></h3></div></div></div><pre class="screen">&lt;preferences profiles="name"&gt;
  &lt;version&gt;1.1.2&lt;/version&gt;
  &lt;packagemanager&gt;zypper&lt;/packagemanager&gt;
  &lt;type image="name" ...&gt;
    &lt;machine|oemconfig|pxedeploy|size|split|systemdisk|vagrantconfig&gt;
  &lt;/type&gt;
&lt;/preferences&gt;</pre><p>
    The mandatory <code class="sgmltag-element">preferences</code> section contains
    information about the supported image type(s), the used package manager,
    the version of this image, and optional attributes. The image version
    must be a three-part version number of the format:
    <span class="bold"><strong>Major</strong></span>.<span class="bold"><strong>Minor</strong></span>.<span class="bold"><strong>Release</strong></span>.
    <a class="indexterm" name="idm139781528831328"></a> In case of changes to the image description the following
    rules should apply:
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      For smaller image modifications that do not add or remove any new
      packages, only the release number is incremented. The
      <code class="filename">config.xml</code> file remains unchanged.
     </p></li><li class="listitem"><p>
      For image changes that involve the addition or removal of packages the
      minor number is incremented and the release number is reset.
     </p></li><li class="listitem"><p>
      For image changes that change the size of the image file the major
      number is incremented.
     </p></li></ul></div><p>
    By default, KIWI uses the <span class="command"><strong>zypper</strong></span> package manager but
    it is also possible to use the non SUSE native package manager called
    <span class="command"><strong>smart</strong></span>.
   </p><p>
    In general the specification of one <code class="sgmltag-element">preferences</code>
    section is sufficient. However, it’s possible to specify multiple
    <code class="sgmltag-element">preferences</code> sections and distinguish between the
    sections via the <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="idm139781528822432"></a>
    attribute. Data may also be shared between different profiles. Using
    profiles it is possible to, for example, configure specific preferences
    for OEM image generation. Activation of a given
    <code class="sgmltag-element">preferences</code> during image generation is triggered by
    the use of the <code class="option">--add-profile</code> command line argument.
   </p><p>
    For each <code class="sgmltag-element">preferences</code> block at least one
    <code class="sgmltag-element">type</code> element must be defined. It is possible to
    specify multiple <code class="sgmltag-element">type</code> elements in any
    <code class="sgmltag-element">preferences</code> block. To set a given
    <code class="sgmltag-element">type</code> description as the default image use the boolean
    attribute <code class="sgmltag-attribute">primary</code><a class="indexterm" name="idm139781528817392"></a> and
    set its value to <code class="sgmltag-attvalue">true</code>. The
    image type to be created is determined by the value of the
    <code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528815168"></a> attribute. The
    following list describes the supported types and possible values of the
    image attribute:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528812768"></a>="<code class="sgmltag-attvalue">lxc|docker</code>"</span></dt><dd><p>
       Use the lxc or docker image type to build a linux container image. For
       additional information refer to the <a class="xref" href="#chap.docker" title="Chapter 9. Docker images">Chapter 9, <i>Docker images</i></a>
       chapter.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528808592"></a>="<code class="sgmltag-attvalue">[filesystem]</code>"</span></dt><dd><p>
       Use one of the following image types to build a plain filesystem
       image. This will create a file containing the data in the specified
       filesystem and you can loop mount the image to view the contents e.g
       image="ext3":
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
         ext2
        </p></li><li class="listitem"><p>
         ext3
        </p></li><li class="listitem"><p>
         ext4
        </p></li><li class="listitem"><p>
         btrfs
        </p></li><li class="listitem"><p>
         squashfs
        </p></li><li class="listitem"><p>
         xfs
        </p></li></ul></div></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528799792"></a>="<code class="sgmltag-attvalue">tbz</code>"</span></dt><dd><p>
       Use the tbz image type to just pack the unpacked image tree into a
       tarball.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528796144"></a>="<code class="sgmltag-attvalue">cpio</code>"</span></dt><dd><p>
       Use the cpio image type to specify the generation of a boot image
       (initrd). When generating a boot image, it is possible to specify a
       specific boot profile and boot kernel using the optional
       <code class="sgmltag-attribute">bootprofile</code><a class="indexterm" name="idm139781528793136"></a>="<code class="sgmltag-attvalue">default</code>"
       and
       <code class="sgmltag-attribute">bootkernel</code><a class="indexterm" name="idm139781528791008"></a>="<code class="sgmltag-attvalue">std</code>"
       attributes.
      </p><p>
       A boot image should group the various supported kernels into
       profiles. If the user chooses not to use the profiles supplied by
       KIWI, it is required that one profile named std be created. This
       profile will be used if no other bootkernel is specified. Further it
       is required to create a profile named default. This profile is used
       when no bootprofile is specified.
      </p><p>
       It is recommended that special configurations that omit drivers, use
       special drivers and/or special packages be specified as profiles.
      </p><p>
       The bootprofile and bootkernel attribute are respected within the
       definition of a system image. Us the attribute and value
       <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781528786960"></a>="<code class="sgmltag-attvalue">system</code>"
       of the <code class="sgmltag-element">description</code> element to specify the creation
       of a system image. The values of the bootprofile and bootkernel
       attributes are used by KIWI when generating the boot image.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528783488"></a>="<code class="sgmltag-attvalue">iso</code>"</span></dt><dd><p>
       Specify the key-value pair
       <code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528780720"></a>="<code class="sgmltag-attvalue">iso</code>"
       to generate a live system suitable for deployment on optical media
       (CD or DVD). Use the
       <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm139781528778464"></a>="<code class="sgmltag-attvalue">isoboot/suse-*</code>"
       attribute when generating this image type to select the appropriate
       boot image for optical media. In addition the optional
       <code class="sgmltag-attribute">flags</code><a class="indexterm" name="idm139781528776176"></a> attribute may be set to
       the following values with the effects described below:
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attvalue">seed</code>
        </span></dt><dd><p>
          Creates a btrfs based compressed read-only filesystem which allows
          write operations into a btrfs seed device.
         </p></dd><dt><span class="term"><code class="sgmltag-attvalue">overlay</code>
        </span></dt><dd><p>
          Creates a squashfs based compressed read-only filesystem which is
          combined with a write space via the overlayfs filesystem.
          overlayfs is part of the kernel since version 3.7
         </p></dd><dt><span class="term"><code class="sgmltag-attvalue">compressed</code>
        </span></dt><dd><p>
          Creates a split ext3 plus squashfs filesystem and combines them
          via a symlink system to a complete system it is recommended to
          specify a <code class="sgmltag-element">split</code> section as a child of this type
          element.
         </p></dd></dl></div><p>
       If the flags attribute is not used the filesystem will be squashfs
       compressed for /bin /boot /lib /lib64 /opt /sbin and /usr. The rest
       of the filesystem is packed into a tmpfs and linked via symbolic
       links
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528765632"></a>="<code class="sgmltag-attvalue">oem</code>"</span></dt><dd><p>
       Use this type to create a virtual disk system suitable in a preload
       setting. In addition specify the attributes
       <code class="sgmltag-attribute">filesystem</code><a class="indexterm" name="idm139781528762720"></a>, and
       <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm139781528761216"></a>="<code class="sgmltag-attvalue">oemboot/suse-*</code>"
       to control the filesystem used for the virtual and to specify the
       proper boot image. Using the optional
       <code class="sgmltag-attribute">format</code><a class="indexterm" name="idm139781528758944"></a> attribute
       and setting, the value to iso or usb will create self installing
       images suitable for optical media or a USB stick, respectively.
       Booting from the media will deploy the OEM preload image onto the
       selected storage device of the system. It is also possible to
       configure the system to use logical volumes. Use the optional
       <code class="sgmltag-attribute">lvm</code><a class="indexterm" name="idm139781528757056"></a> attribute
       and specify the logical volume configuration with the
       <code class="sgmltag-element">systemdisk</code> child element. The default volume group
       name is kiwiVG. Further configuration of the image is performed using
       the appropriate <code class="sgmltag-element">*config</code> child block.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528753760"></a>="<code class="sgmltag-attvalue">pxe</code>"</span></dt><dd><p>
       Creating a network boot image is supported by KIWI with the
       image="pxe" type. When specifying the creation of a network boot
       image use the
       <code class="sgmltag-attribute">filesystem</code><a class="indexterm" name="idm139781528750800"></a> and
       boot="netboot/suse-*" attributes to specify the filesystem of the
       image and the proper boot image. To compress the image file set the
       <code class="sgmltag-attribute">compressed</code><a class="indexterm" name="idm139781528749120"></a> boolean attribute to
       true. This setting will compress the image file and has no influence
       on the filesystem used within the image. The compression is often use
       to support better transfer times when the pxe image is pushed to the
       boot server over a network connection. The pxe image layout is
       controlled by using the <code class="sgmltag-element">pxedeploy</code> child element.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528746096"></a>="<code class="sgmltag-attvalue">split</code>"</span></dt><dd><p>
       The split image support allows the creation of an image as split
       files. Using this technique one can assign different file systems and
       different read-write properties to the different sections of the
       image. The <code class="sgmltag-element">oem</code>, <code class="sgmltag-element">pxe</code>,
       <code class="sgmltag-element">usb</code>, and <code class="sgmltag-element">vmx</code> types can be
       created as a split system image. Use the
       <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm139781528741456"></a>="<code class="sgmltag-attvalue">oem|netboot|usb|vmx/suse-*</code>"
       attribute to select the underlying type of the split image. The
       attributes
       <code class="sgmltag-attribute">fsreadwrite</code><a class="indexterm" name="idm139781528739216"></a>,
       <code class="sgmltag-attribute">fsreadonly</code><a class="indexterm" name="idm139781528737712"></a> are
       used to control the read-write properties of the filesystem specified
       as the attributes value. Use the appropriate
       <code class="sgmltag-element">*config</code> child block to specify the properties of
       the underlying image. For example when building a OEM based split
       image use the <code class="sgmltag-element">oemconfig</code> child section.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528734352"></a>="<code class="sgmltag-attvalue">vmx</code>"</span></dt><dd><p>
       Creation of a virtual disk system is enabled with the vmx value of
       the image attribute. Set the filesystem of the virtual disk with the
       filesystem attribute and select the appropriate boot image by setting
       <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm139781528731328"></a>="<code class="sgmltag-attvalue">vmxboot/suse-*</code>"
       The optional format attribute is used to specify one of the
       virtualization formats supported by QEMU, such as vmdk (also the
       VMware format) or qcow2. For the virtual disk image the optional vga
       attribute may be used to configure the kernel framebuffer device.
       Acceptable values can be found in the Linux kernel documentation for
       the framebuffer device (see
       <code class="filename">Documentation/fb/vesafb.txt</code>). KIWI also supports
       the selection of the boot loader for the virtual disk according to the
       rules indicated for the USB system. Last but not least the virtual
       disk system may also be created with a LVM based layout by using the
       <code class="sgmltag-attribute">lvm</code><a class="indexterm" name="idm139781528727872"></a> attribute. The previously
       indicated rules apply. Use the <code class="sgmltag-element">machine</code> child
       element to specify appropriate configuration of the virtual disk
       system.
      </p></dd></dl></div><p>
    Within the type section, there could be other optional attributes which
    are either universally valid or can be used for different image types in
    the same way. The following list explains these attributes:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">kernelcmdline</code><a class="indexterm" name="idm139781528724016"></a>
     </span></dt><dd><p>
       Specifies additional kernel parameters. The following example
       disables kernel messages: <code class="literal">kernelcmdline="quiet"</code>
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">mdraid</code><a class="indexterm" name="idm139781528720368"></a>
     </span></dt><dd><p>
       For disk based image types, aka oem and vmx, mdraid activates the
       creation of a software raid image. The raid inside the image is
       created in degraded mode because at creation time we only know about
       one disk. It's in the hand of the user to add devices to the raid
       after the image runs on the target machine. The value for mdraid can
       be either <span class="emphasis"><em>mirroring</em></span> or
       <span class="emphasis"><em>striping</em></span>, which means the raid level is set to
       RAID1 (mirroring) or RAID0 (striping).
      </p></dd></dl></div><p>
    Within the preferences section, there are the following optional
    elements:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">showlicense</code><a class="indexterm" name="idm139781528715312"></a>
     </span></dt><dd><p>
       Specifies the base name of a license file which is displayed in oem
       images before the installation happens. It's possible to add more
       showlicense sections to display more licenses one after the other. If
       no such element is specified the default 'license' and 'EULA' files
       are searched. The search algorithm will append the .txt or
       .locale.txt suffix to the license name to form the license file name.
       You should make sure that you license files contains this suffix.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">rpm-check-signatures</code><a class="indexterm" name="idm139781528711856"></a>
     </span></dt><dd><p>
       Specifies whether RPM should check the package signature or not
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">rpm-excludedocs</code><a class="indexterm" name="idm139781528708848"></a>
     </span></dt><dd><p>
       Specifies whether RPM should skip installing package documentation
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">rpm-force</code><a class="indexterm" name="idm139781528705840"></a>
     </span></dt><dd><p>
       Specifies whether RPM should be called with <code class="option">--force</code>
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">keytable</code><a class="indexterm" name="idm139781528702544"></a>
     </span></dt><dd><p>
       Specifies the name of the console keymap to use. The value
       corresponds to a map file in
       <code class="filename">/usr/share/kbd/keymaps</code>. The
       <code class="varname">KEYTABLE</code> variable in
       <code class="filename">/etc/sysconfig/keyboard</code> file is set according to
       the keyboard mapping.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">timezone</code><a class="indexterm" name="idm139781528697792"></a>
     </span></dt><dd><p>
       Specifies the time zone. Available time zones are located in the
       <code class="filename">/usr/share/zoneinfo</code><a class="indexterm" name="idm139781528695312"></a>
       directory. Specify the attribute value relative to
       <code class="filename">/usr/share/zoneinfo</code><a class="indexterm" name="idm139781528693488"></a>.
       For example, specify Europe/Berlin for
       <code class="filename">/usr/share/zoneinfo/Europe/Berlin</code>. KIWI uses
       this value to configure the timezone in
       <code class="filename">/etc/localtime</code> for the image.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">locale</code><a class="indexterm" name="idm139781528689888"></a>
     </span></dt><dd><p>
       Specifies the name of the UTF-8 locale to use, which defines the
       contents of the <code class="envar">RC_LANG</code><a class="indexterm" name="idm139781528687872"></a> system environment variable in
       <code class="filename">/etc/sysconfig/language</code>. Please note only UTF-8
       locales are supported here which also means that the encoding must
       <span class="emphasis"><em>not</em></span> be part of the locale information. The KIWI
       schema validates the locale string according to the following
       pattern:<code class="literal">[a-z]{2}_[A-Z]{2}(,[a-z]{2}_[A-Z]{2})*</code>.
       This means you need to specify the locale like the following example:
       en_US or en_US,de_DE
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">bootsplash-theme</code><a class="indexterm" name="idm139781528683568"></a>
     </span></dt><dd><p>
       Specifies the name of the bootsplash theme to use
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">bootloader-theme</code><a class="indexterm" name="idm139781528680576"></a>
     </span></dt><dd><p>
       Specifies the name of the gfxboot theme to use
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">defaultdestination</code><a class="indexterm" name="idm139781528677584"></a>
     </span></dt><dd><p>
       Used if the <code class="option">--destdir</code> option is not specified when
       calling KIWI
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">defaultroot</code><a class="indexterm" name="idm139781528674208"></a>
     </span></dt><dd><p>
       Used if the option <code class="option">--root</code> is not specified when
       calling KIWI
      </p></dd></dl></div><p>
    The <code class="sgmltag-element">type</code> element may contain child elements to
    provide specific configuration information for the given type. The
    following lists the supported child elements:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-element">systemdisk</code>
     </span></dt><dd><p>
       Using the optional systemdisk section it is possible to create a LVM
       (Logical Volume Management) based storage layout or a btrfs based
       layout using sub volumes. See chapter 17 for details.
      </p><p>
       By default, the
       volume group is named <span class="emphasis"><em>kiwiVG</em></span>. It is possible to
       change the name of the group by setting the
       <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm139781528667456"></a> attribute to the desired
       name. Individual volumes within the volume group are specified using
       the <code class="sgmltag-element">volume</code> element.
      </p><p>
       The following example shows the creation of a volume named
       <span class="italic">usr</span> and a volume named
       <span class="italic">var</span> inside the volume group
       systemVG.
      </p><pre class="screen"> &lt;systemdisk name="systemVG"&gt;
  &lt;volume name="usr" freespace="100M"/&gt;
  &lt;volume name="var" size="200M"/&gt;
&lt;/systemdisk&gt;</pre><p>
       The optional attribute <code class="sgmltag-attribute">freespace</code><a class="indexterm" name="idm139781528662256"></a>
       controls the amount of unused space available after software has been
       installed in the given volume. By default the available space of a
       created volume is between 10% and 20%. Using the optional
       <code class="sgmltag-attribute">size</code><a class="indexterm" name="idm139781528660512"></a> attribute the absolute size
       of the given volume is specified. The
       <code class="sgmltag-attribute">size</code><a class="indexterm" name="idm139781528658912"></a> attribute takes precedence
       over the <code class="sgmltag-attribute">freespace</code><a class="indexterm" name="idm139781528657408"></a> attribute. If
       the specified size is insufficient, based on the estimated software
       install size for the given volume, the specified value will be
       ignored and a volume with default settings will be created. This
       implies that the volume will be 80% to 90% full.
      </p></dd><dt><span class="term"><code class="sgmltag-element">oemconfig</code>
     </span></dt><dd><p>

       <em><span class="remark">
        2015-11-30 - fs: This whole section has also been copied to the OEM chapter
       </span></em>

       By default, the oemboot process will create or modify a swap, and
       <code class="filename">/</code> partition. It is possible to influence the
       behavior by the <code class="filename">oem-*</code> elements explained below.
      </p><pre class="screen">&lt;oemconfig&gt;
   &lt;oem-systemsize&gt;2000&lt;/oem-systemsize&gt;
   &lt;oem-... &gt;
&lt;/oemconfig&gt;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-boot-title&gt;</code>text<code class="sgmltag-endtag">&lt;/oem-boot-title&gt;</code>
        </span></dt><dd><p>
          By default, the string
          <span class="phrase">OEM</span> will be
          used as the boot manager menu entry when KIWI creates the GRUB
          configuration during deployment. The
          <code class="sgmltag-element">oem-boot-title</code> element allows you to set a
          custom name for the grub menu entry. This value is represented by
          the <code class="varname">kiwi_oemtitle</code> variable in the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-bootwait&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-bootwait&gt;</code>
        </span></dt><dd><p>
          Specify if the system should wait for user interaction prior to
          continuing the boot process after the oem image has been dumped to
          the designated storage device (default value is false). This value
          is represented by the <code class="varname">kiwi_oembootwait</code> variable
          in the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-inplace-recovery&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-inplace-recovery&gt;</code>
        </span></dt><dd><p>
          Specify if the recovery archive is stored as part of the image or
          if the archive is to be created at the time the image is deployed
          to the target storage device.
          <code class="varname">kiwi_oemrecoveryInPlace</code> variable in the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-kiwi-initrd&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-kiwi-initrd&gt;</code>
        </span></dt><dd><p>
          If this element is set to true (default value is false) the
          oemboot boot image (initrd) will <span class="emphasis"><em>not</em></span> be
          replaced by the system (mkinitrd) created initrd. This option is
          useful when the system is installed on removable storage such as a
          USB stick or a portable external drive. For movable devices it is
          potentially necessary to detect the storage location during every
          boot. This detection process is part of the oemboot boot image.
          This value is represented by the <code class="varname">kiwi_oemkboot</code>
          variable in the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-partition-install&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-partition-install&gt;</code>
        </span></dt><dd><p>
          Specify if the image is to be installed into a free partition on
          the target storage device. By default the value is false and Kiwi
          installs images to a target device which causes data loss on the
          device. With
          <code class="sgmltag-element">oem-partition-install</code> set to
          true any other settings that have influence on the partition
          table, such as <code class="sgmltag-element">oem-swap</code> are
          ignored. This value is represented by the
          <code class="varname">kiwi_oempartition_install</code> variable in the
          initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-reboot&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-reboot&gt;</code>
        </span></dt><dd><p>
          Specify if the system is to be rebooted after the oem image has
          been deployed to the designated storage device (default value is
          false). This value is represented by the
          <code class="varname">kiwi_oemreboot</code> variable in the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-reboot-interactive&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-reboot-interactive&gt;</code>
        </span></dt><dd><p>
          Specify if the system is to be rebooted after the oem image has
          been deployed to the designated storage device (default value is
          false). Prior to reboot a message is posted and must be
          acknowledged by the user in order for the system to reboot. This
          value is represented by the
          <code class="varname">kiwi_oemrebootinteractive</code> variable in the
          initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-recovery&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-recovery&gt;</code>
        </span></dt><dd><p>
          If this element is set to true (default value is false), KIWI will
          create a recovery archive from the prepared root tree. The archive
          will appear as <code class="filename">/recovery.tar.bz2</code> in the image
          file. During first boot of the image a single recovery partition
          will be created and the recovery archive will be moved to the
          recovery partition. An additional boot menu entry is created that
          when selected restores the original root tree on the system. The
          user information on the
          <code class="filename">/home</code><a class="indexterm" name="idm139781528620432"></a>
          partition or in the <code class="filename">/home</code><a class="indexterm" name="idm139781528618688"></a>
          directory is not affected by the recovery process. This value is
          represented by the kiwi_oemrecovery variable in the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-recoveryID&gt;</code>partition-id<code class="sgmltag-endtag">&lt;/oem-recoveryID&gt;</code>
        </span></dt><dd><p>
          Specify the partition type for the recovery partition. The default
          is to create a Linux partition (id = 83). This value is
          represented by the <code class="varname">kiwi_oemrecoveryID</code> variable
          in the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-silent-boot&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-silent-boot&gt;</code>
        </span></dt><dd><p>
          Specify if the system should boot in silent mode after the oem
          image has been deployed to the designated storage device (default
          value is false). This value is represented by the
          <code class="varname">kiwi_oemsilentboot</code> variable in the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-shutdown&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-shutdown&gt;</code>
        </span></dt><dd><p>
          Specify if the system is to be powered down after the oem image
          has been deployed to the designated storage device (default value
          is false). This value is represented by the
          <code class="varname">kiwi_oemshutdown</code> variable in the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-shutdown-interactive&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-shutdown-interactive&gt;</code>
        </span></dt><dd><p>
          Specify if the system is to be powered down after the oem image
          has been deployed to the designated storage device (default value
          is false). Prior to shutdown a message is posted and must be
          acknowledged by the user in order for the system to power off.
          This value is represented by the
          <code class="varname">kiwi_oemshutdowninteractive</code> variable in the
          initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-swap&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-swap&gt;</code>
        </span></dt><dd><p>
          Specify if a swap partition should be created. The creation of a
          swap partition is the default behavior. This value is represented
          by the <code class="varname">kiwi_oemswap</code> variable in the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-swapsize&gt;</code>number in MB<code class="sgmltag-endtag">&lt;/oem-swapsize&gt;</code>
        </span></dt><dd><p>
          Set the size of the swap partition. If a swap partition is to be
          created and the size of the swap partition is not specified with
          this optional element, KIWI will calculate the size of the swap
          partition and create a swap partition equal to two times the RAM
          installed on the system at initial boot time. This value is
          represented by the <code class="varname">kiwi_oemswapMB</code> variable in
          the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-systemsize&gt;</code>number in MB<code class="sgmltag-endtag">&lt;/oem-systemsize&gt;</code>
        </span></dt><dd><p>
          Set the size the operating system is allowed to consume on the
          target disk. The size limit does not include any consideration for
          swap space or a recovery partition. In a setup
          <span class="emphasis"><em>without</em></span> a
          <code class="sgmltag-element">systemdisk</code> element this value
          specifies the size of the root partition. In a setup
          <span class="emphasis"><em>including</em></span> a
          <code class="sgmltag-element">systemdisk</code> element this value
          specifies the size of the LVM partition which contains all
          specified volumes. Thus, the sum of all specified volume sizes
          plus the sum of the specified freespace for each volume must be
          smaller or equal to the size specified with the
          <code class="sgmltag-element">oem-systemsize</code>. This value is
          represented by the variable <code class="varname">kiwi_oemrootMB</code> in
          the initrd
         </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-unattended&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-unattended&gt;</code>
        </span></dt><dd><p>
          The installation of the image to the target system occurs
          automatically without requiring user interaction. If multiple
          possible target devices are discovered the image is deployed to
          the first device. <code class="varname">kiwi_oemunattended</code> in the
          initrd
         </p></dd></dl></div></dd><dt><span class="term"><code class="sgmltag-element">pxedeploy</code>
     </span></dt><dd><p>
       Information contained in the optional <code class="sgmltag-element">pxedeploy</code>
       section is only considered if the
       <code class="sgmltag-attribute">image</code><a class="indexterm" name="idm139781528584752"></a> attribute of the
       <code class="sgmltag-element">type</code> element is set to
       <code class="sgmltag-attvalue">pxe</code>. To use a PXE image
       it is necessary to create a network boot infrastructure. Creation of
       the network boot infrastructure is simplified by the KIWI provided
       package
       <span class="package">kiwi-pxeboot</span>
       . This package configures the basic PXE boot environment as expected
       by KIWI pxe images. The
       <span class="package">kiwi-pxeboot</span>
       package creates a directory structure in
       <code class="filename">/srv/tftpboot</code>. Files created by the KIWI create
       step need to be copied to the <code class="filename">/srv/tftpboot</code>
       directory structure. For additional details about the PXE image
       please refer to the PXE Image chapter later in this document.
      </p><p>
       In addition to the image files it is necessary that information be
       provided about the client setup. This information, such as the image
       to be used or the partitioning, is contained in a file with the name
       <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code> in the
       directory <code class="filename">/srv/tftpboot/KIWI</code>. The content of
       this file is created automatically by KIWI if the pxedeploy section
       is provided in the image description. A pxedeploy section is outlined
       below:
      </p><pre class="screen">&lt;pxedeploy server="IP" blocksize="4096"&gt;
   &lt;timeout&gt;seconds&lt;/timeout&gt;
   &lt;kernel&gt;kernel-file&lt;/kernel&gt;
   &lt;initrd&gt;initrd-file&lt;/initrd&gt;
   &lt;partitions device="/dev/sda"&gt;
     &lt;partition type="swap" number="1" size="MB"/&gt;
     &lt;partition type="L" number="2" size="MB"
              mountpoint="/" target="true"/&gt;
     &lt;partition type="fd"  number="3"/&gt;
   &lt;/partitions&gt;
   &lt;union ro="dev" rw="dev" type="clicfs"/&gt;
   &lt;configuration source="/KIWI/../file" dest="/../file" arch="..."/&gt;
   &lt;configuration .../&gt;
&lt;/pxedeploy&gt; </pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
         The <code class="sgmltag-attribute">server</code><a class="indexterm" name="idm139781528574928"></a> attribute is used
         to specify the IP address of the PXE server. The
         <code class="sgmltag-attribute">blocksize</code><a class="indexterm" name="idm139781528573328"></a>
         attributes specifies the blocksize for the image download. Other
         protocols are supported by KIWI but require the
         <em class="parameter"><code>kiwiserver</code></em> and
         <em class="parameter"><code>kiwiservertype</code></em> kernel parameters to be set
         when the client boots.
        </p></li><li class="listitem"><p>
         The value of the optional <code class="sgmltag-element">timeout</code> element
         specifies the grub timeout in seconds to be used when the KIWI
         initrd configures and installs the grub boot loader on the client
         machine after the first deployment to allow standalone boot.
        </p></li><li class="listitem"><p>
         Passing kernel parameters is possible with the use of the optional
         <code class="sgmltag-attribute">kernelcmdline</code><a class="indexterm" name="idm139781528568064"></a>
         attribute in the <code class="sgmltag-element">type</code> section. The value of this
         attribute is a string specifying the settings to be passed to the
         kernel by the GRUB bootloader. The KIWI initrd includes these
         kernel options when installing grub for standalone boot
        </p></li><li class="listitem"><p>
         The optional <code class="sgmltag-element">kernel</code> and
         <code class="sgmltag-element">initrd</code> elements are used to specify the file
         names for the kernel and initrd on the boot server respectively.
         When using a special boot method not supported by the
         distribution’s standard mkinitrd, it is imperative that the KIWI
         initrd remains on the PXE server and also be used for local boot.
         If the configured image uses the <code class="sgmltag-element">split</code> type or
         the <code class="sgmltag-element">pxedeploy</code> section includes any union
         information the kernel and initrd elements must be used.
        </p></li><li class="listitem"><p>
         The <code class="sgmltag-element">partitions</code> section is required if the system
         image is to be installed on a disk or other permanent storage
         device. Each partition is specified with one partition child
         element. The mandatory type attribute specifies the partition type
         id.
        </p><p>
         The required
         <code class="sgmltag-attribute">number</code><a class="indexterm" name="idm139781528560928"></a>
         attribute provides the number of the partition to be created. The
         size of the partition may be specified with the optional size
         attribute. The optional mountpoint attribute provides the value for
         the mount point of the partition. The optional boolean target
         attribute identifies the partition as the system image target
         partition. KIWI always generates the swap partition as the first
         partition of the netboot boot image. By default, the second
         partition is used for the system image. Use the boolean
         <code class="sgmltag-attribute">target</code><a class="indexterm" name="idm139781528558832"></a> attribute to change
         this behavior. Providing the value image for the
         <code class="sgmltag-attribute">size</code><a class="indexterm" name="idm139781528557216"></a>
         attribute triggers KIWI into calculating the required size for this
         partition. The calculated size is sufficient for the created image.
        </p></li><li class="listitem"><p>
         If the system image is based on a read-only filesystem such as
         squashfs and should be mounted in read-write mode use the optional
         union element. The type attribute is used to specify one of the
         supported overlay filesystem
         <code class="systemitem">clicfs</code><a class="indexterm" name="idm139781528554240"></a> Use the ro
         attribute to point to the read only device and the rw attribute to
         point to the read-write device.
        </p></li><li class="listitem"><p>
         The optional <code class="sgmltag-element">configuration</code> element is used to
         integrate a network client’s configuration files that are stored
         on the server. The source attribute specifies the path on the
         server for the file to be downloaded. The dest attribute specifies
         destination of the downloaded file on the network client starting
         at the root (/) of the filesystem. Multiple configuration elements
         may be specified such that multiple files can be transferred to the
         network client. In addition configuration files can be bound to a
         specific client architecture by setting the optional arch
         attribute. To specify multiple architectures use a comma separated
         string.
        </p></li></ul></div></dd><dt><span class="term"><code class="sgmltag-element">size</code>
     </span></dt><dd><p>
       Use the size element to specify the image size in Megabytes or
       Gigabytes. The unit attribute specifies whether the given value will
       be interpreted as Megabytes
       (<code class="sgmltag-attribute">unit</code><a class="indexterm" name="idm139781528547616"></a>="<code class="sgmltag-attvalue">M</code>")
       or Gigabytes
       (<code class="sgmltag-attribute">unit</code><a class="indexterm" name="idm139781528545488"></a>="<code class="sgmltag-attvalue">G</code>").
       The optional boolean attribute additive specifies whether or not the
       given size should be added to the size of the generated image or not.
      </p><p>
       In the event of a size specification that is too small for the
       generated image, KIWI will expand the size automatically unless the
       image size exceeds the specified size by 100 MB or more. In this
       case KIWI will generate an error and exit.
      </p><p>
       Should the given size exceed the necessary size for the image KIWI
       will not alter the image size as the free space might be required for
       proper execution of components within the image.
      </p><p>
       If the size element is not used, KIWI will create an image containing
       approximately 30 % free space.
      </p><pre class="screen">&lt;size unit="M"&gt;1000&lt;/size&gt;</pre></dd><dt><span class="term"><code class="sgmltag-element">split</code>
     </span></dt><dd><p>
       For images of type split or iso the information provided in the
       optional <code class="sgmltag-element">split</code> section is considered if the
       compressed attribute is set to true. With the configuration in this
       block it is possible to determine which files are writable and
       whether these files should be persistently writable or temporarily.
       Note that for ISO images only temporary write access is possible.
      </p><p>
       When processing the provided configuration KIWI distinguishes between
       directories and files. For example, providing
       <code class="filename">/etc</code><a class="indexterm" name="idm139781528536912"></a> as the value of the name
       attribute indicates that the
       <code class="filename">/etc</code><a class="indexterm" name="idm139781528535088"></a> directory should be
       writable. However, this does not include any of the files or
       sub-directories within
       <code class="filename">/etc</code><a class="indexterm" name="idm139781528533200"></a>. The
       content of /etc is populated as symbolic links to the read-only
       files. The advantage of setting only a directory to read-write access
       is that any newly created files will be stored on the disk instead of
       in
       <code class="systemitem">tmpfs</code><a class="indexterm" name="idm139781528531184"></a>.
       Creating read-write access to a directory and it’s files requires
       two specifications as shown below.
      </p><pre class="screen">&lt;split&gt;
  &lt;temporary&gt;
    <code class="sgmltag-sgmlcomment">&lt;!-- read/write access to --&gt;</code>
    &lt;file name="/var"/&gt;
    &lt;file name="/var/*"/&gt;
    <code class="sgmltag-sgmlcomment">&lt;!-- but not on this file: --&gt;</code>
    &lt;except name="/etc/shadow"/&gt;
  &lt;/temporary&gt;
  &lt;persistent&gt;
    <code class="sgmltag-sgmlcomment">&lt;!-- persistent read/write access to: --&gt;</code>
    &lt;file name="/etc"/&gt;
    &lt;file name="/etc/*"/&gt;
    <code class="sgmltag-sgmlcomment">&lt;!-- but not on this file: --&gt;</code>
    &lt;except name="/etc/passwd"/&gt;
  &lt;/persistent&gt;
&lt;/split&gt;</pre><p>
       Use the except element to specify exceptions to previously configured
       rules.
      </p></dd><dt><span class="term"><code class="sgmltag-element">machine</code>
     </span></dt><dd><p>
       The optional machine section serves to specify information about a VM
       guest machine. Using the data provided in this section, KIWI will
       create a guest configuration file required to run the image on the
       target machine.
      </p><p>
       If the target is a VMware virtual machine indicated by the format
       attribute set to vmdk, KIWI creates a VMware configuration file. If
       the target is a Xen virtual machine indicated by the domain attribute
       in the machine section KIWI will create a Xen guest config file.
      </p><p>
       The sample block below shows the general outline of the information
       that can be specified to generate the configuration file
      </p><pre class="screen">&lt;machine arch="arch" memory="MB"
  HWversion="number" guestOS="suse|sles"
  domain="dom0|domU"/&gt;
   &lt;vmconfig-entry&gt;Entry_for_VM_config_file&lt;\vmconfig-entry&gt;
   &lt;vmconfig-entry .../&gt;
   &lt;vmnic driver="name" interface="number" mode="mode"/&gt;
   &lt;vmnic ...&gt;
   &lt;vmdisk controller="ide|scsi" id="number"/&gt;
   &lt;vmdvd  controller="ide|scsi" id="number"/&gt;
&lt;/machine&gt; </pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">arch</code><a class="indexterm" name="idm139781528520240"></a>
        </span></dt><dd><p>
          The virtualized architecture. Supported values are
          <code class="sgmltag-attvalue">ix86</code> or
          <code class="sgmltag-attvalue">x86_64</code>. The default value is
          <code class="sgmltag-attvalue">ix86</code>.
         </p></dd><dt><span class="term"><code class="sgmltag-attribute">memory</code><a class="indexterm" name="idm139781528515360"></a>
        </span></dt><dd><p>
          The mandatory
          <code class="sgmltag-attribute">memory</code><a class="indexterm" name="idm139781528513216"></a>
          attribute specifies how much memory in MB should be allocated for
          the virtual machine
         </p></dd><dt><span class="term"><code class="sgmltag-attribute">HWversion</code><a class="indexterm" name="idm139781528510816"></a>
        </span></dt><dd><p>
          The VMware hardware version number, the default value is
          <code class="sgmltag-attvalue">3</code>.
         </p></dd><dt><span class="term"><code class="sgmltag-attribute">guestOS</code><a class="indexterm" name="idm139781528507184"></a>
        </span></dt><dd><p>
          The guest OS identifier. For the ix86 architecture the default
          value is suse and for the x86_64 architecture suse-64 is the
          default. At this point only the SUSE and SLES guestOS types are
          supported.
         </p></dd><dt><span class="term"><code class="sgmltag-attribute">domain</code><a class="indexterm" name="idm139781528504000"></a>
        </span></dt><dd><p>
          The Xen domain setup. This could be either a dom0 which is the
          host machine hosting the guests and therefore doesn’t require a
          configuration file, or it could be set to domU which indicates
          this is a guest and also requires a guest configuration which is
          created by KIWI.
         </p></dd></dl></div><p>
       Use the <code class="sgmltag-element">vmconfig-entry</code> element to
       create entries in the virtual machine's configuration file; .vmx for
       VMware images and .xenconfig for Xen images. You may specify as many
       configuration options as desired. The value of the
       <code class="sgmltag-element">vmconfig-entry</code> element is expected
       to be specified in the syntax required by the VM configuration file
       to be written. The value is free format text and is not validated by
       Kiwi in any way. The entry is written to the VM configuration file
       verbatim.
      </p><p>
       Use the <code class="sgmltag-element">vmdisk</code> element to setup
       the virtual main storage device.
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">controller</code><a class="indexterm" name="idm139781528496768"></a>
        </span></dt><dd><p>
          Supported values for the mandatory
          <code class="sgmltag-attribute">controller</code><a class="indexterm" name="idm139781528494544"></a>
          attribute are <code class="sgmltag-attvalue">ide</code> and
          <code class="sgmltag-attvalue">scsi</code>.
         </p></dd><dt><span class="term"><code class="sgmltag-attribute">id</code><a class="indexterm" name="idm139781528491024"></a>
        </span></dt><dd><p>
          The mandatory
          <code class="sgmltag-attribute">id</code><a class="indexterm" name="idm139781528488880"></a>
          attribute specifies the disk id. If only one disk is set the id
          value should be set to 0.
         </p></dd><dt><span class="term"><code class="sgmltag-attribute">device</code><a class="indexterm" name="idm139781528486464"></a>
        </span></dt><dd><p>
          The device attribute specifies the disk that should appear in the
          para virtual instance. Therefore only relevant for Xen
         </p></dd></dl></div><p>
       Use the <code class="sgmltag-element">vmdvd</code> element to setup a
       virtual optical drive (CD/DVD) connection
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">controller</code><a class="indexterm" name="idm139781528481904"></a>
        </span></dt><dd><p>
          Supported values for the mandatory
          <code class="sgmltag-attribute">controller</code><a class="indexterm" name="idm139781528479680"></a>
          attribute are <code class="sgmltag-attvalue">ide</code> and
          <code class="sgmltag-attvalue">scsi</code>.
         </p></dd><dt><span class="term"><code class="sgmltag-attribute">id</code><a class="indexterm" name="idm139781528476160"></a>
        </span></dt><dd><p>
          The mandatory
          <code class="sgmltag-attribute">id</code><a class="indexterm" name="idm139781528474016"></a>
          attribute specifies the disk id. If only one disk is set the id
          value should be set to 0.
         </p></dd></dl></div><p>
       Use the <code class="sgmltag-element">vmnic</code> element to setup the
       virtual network interface. Multiple
       <code class="sgmltag-element">vmnic</code> child elements may be
       specified to setup multiple virtual network interfaces.
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">driver</code><a class="indexterm" name="idm139781528469376"></a>
        </span></dt><dd><p>
          The mandatory
          <code class="sgmltag-attribute">driver</code><a class="indexterm" name="idm139781528467232"></a>
          attribute specifies the driver to be used for the virtual network
          card. The supported values are
          <code class="sgmltag-attvalue">e100</code>,
          <code class="sgmltag-attvalue">vlance</code>,
          and
          <code class="sgmltag-attvalue">vmxnet</code>.
          If the vmxnet driver is specified the vmware tools must be
          installed in the image.
         </p></dd><dt><span class="term"><code class="sgmltag-attribute">interface</code><a class="indexterm" name="idm139781528462816"></a>
        </span></dt><dd><p>
          The mandatory
          <code class="sgmltag-attribute">interface</code><a class="indexterm" name="idm139781528460672"></a>
          attribute specifies the interface number. If only one interface is
          set the value should be set to 0.
         </p></dd><dt><span class="term"><code class="sgmltag-attribute">mode</code><a class="indexterm" name="idm139781528458256"></a>
        </span></dt><dd><p>
          The network mode used to communicate outside the VM. In many cases
          the bridged mode is used.
         </p></dd></dl></div></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.users"></a>4.1.5. <code class="sgmltag-element">users</code> Element<span class="permalink"><a alt="Permalink" title="4.1.5. users Element" href="#sec.description.users">¶</a></span></h3></div></div></div><pre class="screen">&lt;users group="group_name" id="number"&gt;
  &lt;user home="dir" id="number" name="user" password="..."
        pwdformat="encrypted|plain" realname="string" shell="path"/&gt;
  <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code>
&lt;/users&gt;</pre><p>
    The optional <code class="sgmltag-element">users</code> element lists the users belonging
    to the group specified with the
    <code class="sgmltag-attribute">group</code><a class="indexterm" name="idm139781528451408"></a> attribute. At least one user
    child element must be specified as part of the <code class="sgmltag-element">users</code>
    element. Multiple users elements may be specified.
   </p><p>
    The attributes <code class="sgmltag-attribute">home</code><a class="indexterm" name="idm139781528448960"></a>,
    <code class="sgmltag-attribute">id</code><a class="indexterm" name="idm139781528447456"></a>,
    <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm139781528445952"></a>,
    <code class="sgmltag-attribute">pwd</code><a class="indexterm" name="idm139781528444448"></a>,
    <code class="sgmltag-attribute">realname</code><a class="indexterm" name="idm139781528442944"></a>, and
    <code class="sgmltag-attribute">shell</code><a class="indexterm" name="idm139781528441440"></a> specify the created users
    home directory, the user name, the user’s password, the user’s real
    name, and the user’s login shell, respectively. By default, the value
    of the password attribute is expected to be an encrypted string. An
    encrypted password can be created using <span class="command"><strong>kiwi</strong></span>
    <code class="option">--createpassword</code>. It is also possible to specify the
    password as a non encrypted string by using the pwdformat attribute and
    setting it’s value to <span class="quote">“<span class="quote">plain</span>”</span>. KIWI will then encrypt the
    password prior to the user being added to the system.
   </p><p>
    All specified users and groups will be created if they do not already
    exist. By default, the defined users will be part of the group specified
    with the group attribute of the users element and the default group
    called <span class="quote">“<span class="quote">users</span>”</span>. If it is desired to have the specified
    users to only be part of the given group it is necessary to specify the
    <code class="sgmltag-attribute">id</code><a class="indexterm" name="idm139781528436352"></a> attribute. It is
    recommended to use a group id greater than 100.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.drivers"></a>4.1.6. <code class="sgmltag-element">drivers</code> Element<span class="permalink"><a alt="Permalink" title="4.1.6. drivers Element" href="#sec.description.drivers">¶</a></span></h3></div></div></div><pre class="screen">&lt;drivers profiles="name"&gt;
  &lt;file name="filename"/&gt;
  <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code>
&lt;/drivers&gt;</pre><p>
    The optional <code class="sgmltag-element">drivers</code> element is only useful for boot
    images (initrd). As a boot image doesn’t need to contain the complete
    kernel one can save a lot of space if only the required drivers are part
    of the image. Therefore the drivers section exists. If present only the
    drivers which matches the file names or glob patterns will be included
    into the boot image. Each file is specified relative to the
    <code class="filename">/lib/modules/<em class="replaceable"><code>Version</code></em>/kernel</code><a class="indexterm" name="idm139781528429920"></a>
    directory.
   </p><p>
    According to the <code class="sgmltag-element">driver</code> element the specified files
    are searched in the corresponding directory. The information about the
    driver names is provided as environment variable named like the value of
    the <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781528427440"></a> attribute and
    is processed by the function <code class="function">suseStripKernel</code>.
    According to this along with a boot image description a script called
    <span class="command"><strong>images.sh</strong></span> must exist which calls this function in
    order to allow the driver information to have any effect.
   </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.repository"></a>4.1.7. <code class="sgmltag-element">repository</code> Element<span class="permalink"><a alt="Permalink" title="4.1.7. repository Element" href="#sec.description.repository">¶</a></span></h3></div></div></div><pre class="screen">&lt;repository type="type" alias="name" imageinclude="true|false"
              password="password" priority="number" status="replaceable"
              username="user-name"&gt; &lt;source path="URL"/&gt;
&lt;/repository&gt;</pre><p>
    The mandatory <code class="sgmltag-element">repository</code> element
    specifies the location and type of a repository to be used by the
    package manager as a package installation source. The mandatory
    <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781528421056"></a> attribute specifies the
    repository type. A specified repository can only be accessed by the
    chosen package manager if the given type is supported by the specified
    package manager. KIWI supports smart or zypper as package managers,
    specified with the <code class="sgmltag-element"> packagemanager</code>
    element. The default package manager is zypper. The following table
    shows the possible supported repository types for each package manager:
   </p><div class="table"><a name="tab.description.supported-types"></a><p class="title"><b>Table 4.1. Supported Package Manager Repository Types</b><span class="permalink"><a alt="Permalink" title="Table 4.1. Supported Package Manager Repository Types" href="#tab.description.supported-types">¶</a></span></p><div class="table-contents"><table summary="Supported Package Manager Repository Types" border="1"><colgroup><col><col><col><col><col></colgroup><thead><tr><th>Type</th><th>smart</th><th>zypper</th><th>apt</th><th>yum</th></tr></thead><tbody><tr><td>apt-deb</td><td>yes</td><td>no</td><td>yes</td><td>no</td></tr><tr><td>rpm-dir</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr><tr><td>rpm-md</td><td>yes</td><td>yes</td><td>no</td><td>yes</td></tr><tr><td>yast2</td><td>yes</td><td>yes</td><td>no</td><td>no</td></tr></tbody></table></div></div><br class="table-break"><p>
    The <code class="sgmltag-element">repository</code> element has the
    following optional attributes:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">alias</code><a class="indexterm" name="idm139781528402768"></a>="<code class="sgmltag-attvalue">name</code>"</span></dt><dd><p>
       Specifies an alternative name for the configured repository. If the
       attribute is not specified KIWI will generate an alias name by
       replacing any <span class="quote">“<span class="quote">/</span>”</span> in the given repository location with
       an <span class="quote">“<span class="quote">_</span>”</span>. It is helpful to set an alias name if the
       repository path is insufficient in expressing the purpose of the
       contained packages.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">imageinclude</code><a class="indexterm" name="idm139781528398128"></a>="<code class="sgmltag-attvalue">true|false</code>"</span></dt><dd><p>
       Specifies whether the given repository should be configured as a
       repository in the image or not. The default behavior is that
       repositories used to build an image are not configured as a
       repository inside the image. This feature allows you to change the
       behavior by setting the value to
       <code class="sgmltag-attvalue">true</code>. The
       repository is configured in the image according to the source path as
       specified with the <code class="sgmltag-attribute">path</code><a class="indexterm" name="idm139781528394256"></a>
       attribute of the <code class="sgmltag-element">source</code> element.
       Therefore, if the path is not a fully qualified URL, you may need to
       adjust the repository file in the image to accommodate the expected
       location. It is recommended that you use the
       <code class="sgmltag-attribute">alias</code><a class="indexterm" name="idm139781528391888"></a> attribute in combination
       with the <code class="sgmltag-attribute">imageinclude</code><a class="indexterm" name="idm139781528390384"></a> attribute
       to avoid having unpredictable random names assigned to the repository
       you wish to include in the image. This also facilitates modification
       of the "baseurl" entry in the .repo file from the config.sh script if
       you need to make adjustments to the path.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">password</code><a class="indexterm" name="idm139781528387792"></a>="<code class="sgmltag-attvalue">string</code>"</span></dt><dd><p>
       Specifies a password for the given repository. The
       <code class="sgmltag-attribute">password</code><a class="indexterm" name="idm139781528384944"></a> attribute must be used
       in combination with the <code class="sgmltag-attribute">
       username</code><a class="indexterm" name="idm139781528383440"></a> attribute. Dependent on the repository location
       this information may not be used.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">prefer-license</code><a class="indexterm" name="idm139781528381056"></a>="<code class="sgmltag-attvalue">true|false</code>"</span></dt><dd><p>
       The repository providing this attribute will be used primarily to
       install the license tarball if found on that repository. If no
       repository with a preferred license attribute exists, the search
       happens over all repositories. It's not guaranteed in that case that
       the search order follows the repository order like they are written
       into the XML description.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">priority</code><a class="indexterm" name="idm139781528377104"></a>="<code class="sgmltag-attvalue">number</code>"</span></dt><dd><p>
       Specifies the repository priority for this given repository. Priority
       values are treated differently by different package managers.
       Repository priorities allow the package management system to
       disambiguate packages that may be contained in more than one of the
       configured repositories. The smart package manager treats packages
       from repositories with the <span class="emphasis"><em>highest</em></span> priority
       number as preferable to packages from a repository with a lower
       priority number. The value 0 means <span class="quote">“<span class="quote">no priority is set</span>”</span>.
       The zypper package manager prefers packages from a repository with a
       <span class="emphasis"><em>lower</em></span> priority over packages from a repository
       with higher priority values. The value 99 means <span class="quote">“<span class="quote">no priority is
       set</span>”</span>.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">status</code><a class="indexterm" name="idm139781528371264"></a>="<code class="sgmltag-attvalue">replaceable</code>"</span></dt><dd><p>
       This attribute should only be applied in the context of a boot image
       description. Setting the <code class="sgmltag-attribute"> status</code><a class="indexterm" name="idm139781528368368"></a>
       to <code class="sgmltag-attvalue">replaceable </code> indicates that
       the specified repository my be replaced by the repositories specified
       in the image description. This is important as the KIWI generated
       boot image, if required, should be created based on packages from the
       same repositories used to build the system image.
      </p></dd><dt><span class="term"><code class="sgmltag-attribute">username</code><a class="indexterm" name="idm139781528365152"></a>="<code class="sgmltag-attvalue">name</code>"</span></dt><dd><p>
       Specifies a user name for the given repository. The
       <code class="sgmltag-attribute">username</code><a class="indexterm" name="idm139781528362304"></a> attribute must be used
       in combination with the <code class="sgmltag-attribute">
       password</code><a class="indexterm" name="idm139781528360800"></a> attribute. Dependent on the repository location
       this information may not be used.
      </p></dd></dl></div><p>
    When specifying an https location for a repository it is generally
    necessary to include the <span class="quote">“<span class="quote">openssl-certs</span>”</span> and
    <span class="quote">“<span class="quote">cracklib-dict-full</span>”</span> packages in the
    <code class="sgmltag-attvalue">bootstrap</code> section of the image
    configuration.
   </p><p>
    The location of a repository is specified by the
    <code class="sgmltag-attribute">path</code><a class="indexterm" name="idm139781528356448"></a> attribute of the mandatory
    <code class="sgmltag-element">source</code> child element. The location
    specification may include the
    <code class="systemitem">%arch</code><a class="indexterm" name="idm139781528354000"></a> macro which will expand to
    the architecture of the image building host. The value for the
    <code class="sgmltag-attribute">path</code><a class="indexterm" name="idm139781528352384"></a> attribute may begin with any
    of the following location indicators:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
      <code class="uri">dir:///local/path</code>
     </span></dt><dd><p>
       An absolute path to a directory accessible through the local file
       system. The <span class="quote">“<span class="quote">dir://</span>”</span> prefix may be omitted.
      </p></dd><dt><span class="term">
      <code class="uri">ftp://<em class="replaceable"><code>URL</code></em>
      </code>
     </span></dt><dd><p>
       A ftp protocol based network location.
      </p></dd><dt><span class="term">
      <code class="uri">http://<em class="replaceable"><code>URL</code></em>
      </code>
     </span></dt><dd><p>
       A http protocol based network location.
      </p></dd><dt><span class="term">
      <code class="uri">https://<em class="replaceable"><code>URL</code></em>
      </code>
     </span></dt><dd><p>
       A https protocol based network location. See the comment above about
       the handling of certificates and additional package requirements in
       the <code class="sgmltag-attvalue">bootstrap </code> section of the
       image configuration.
      </p></dd><dt><span class="term">
      <code class="uri">iso://<em class="replaceable"><code>path/to/isofile</code></em>
      </code>
     </span></dt><dd><p>
       An absolute path to an .iso file accessible via the local file
       system. KIWI will loop mount the the .iso file to a KIWI created
       directory with a generated name. The generated path is provided to
       the specified package manager as a repository location.
      </p><p>
       Using multiple .iso files from the same SLE product, requires that
       all .iso files are located in the same directory. Only the first .iso
       file is to be specified as a repository in the
       <code class="filename">config.xml</code>. The first .iso file contains all
       information necessary for the package manager to locate packages that
       are contained in other .iso files of the same product. Attempting to
       use multiple .iso files in a series as standalone repositories will
       result in an error.
      </p></dd><dt><span class="term">
      <code class="uri">obs://$dir1/$dir2</code>
     </span></dt><dd><p>
       A special network location used with the http protocol. The values of
       <code class="varname">$dir1</code> and <code class="varname">$dir2</code> represent the
       project location in the openSUSE build service. The location is
       evaluated as
       <code class="uri">this://repos/$dir1/$dir2</code>
       .
      </p><p>
       The <span class="quote">“<span class="quote">obs://</span>”</span> prefix is also valid as part of the value
       for the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm139781528332352"></a> attribute of the
       <code class="sgmltag-element">type</code>. If used with the
       <code class="sgmltag-attribute">boot</code><a class="indexterm" name="idm139781528330224"></a> attribute it is evaluated
       as
       <code class="uri">this://images/$dir1/$dir2</code>
       .
      </p></dd><dt><span class="term">
      <code class="uri">opensuse://<em class="replaceable"><code>PROJECTNAME</code></em>
      </code>
     </span></dt><dd><p>
       A special network location used with the http protocol. The given
       <em class="replaceable"><code>PROJECTNAME</code></em> specifies a project in the
       openSUSE Build Service. The repository is a repository of type
       <code class="sgmltag-attvalue">rpm-md</code>. For example:
       <code class="sgmltag-attribute">path</code><a class="indexterm" name="idm139781528324800"></a>=
       <code class="sgmltag-attvalue">"opensuse://openSUSE:10.3/standard"
       </code>.
      </p></dd><dt><span class="term">
      <code class="uri">plain://<em class="replaceable"><code>URI</code></em>
      </code>
     </span></dt><dd><p>
       A plain resource string. Everything following 'plain://' will be
       forwarded to the package manager without further modification. This
       type of location specification is useful when KIWI does not support a
       specific URI but the specified package manager does.
      </p></dd><dt><span class="term">
      <code class="uri">smb://<em class="replaceable"><code>Samba share pathname</code></em>
      </code>
     </span></dt><dd><p>
       A path to a samba share using the cifs protocol. KIWI creates a mount
       point and mounts the share including username and password, if
       specified. Access to the smb share from within the new root tree is
       provided via a cifs mount. Therefore, the package providing the cifs
       tools must be included in the package list for the
       <code class="sgmltag-attvalue">bootstrap </code> section of the image
       configuration. At the time of this writing the package providing the
       cifs tools is called <span class="emphasis"><em>cifs-utils</em></span>. If any packages
       provided by the Samba share are used as part of the boot image the
       cifs tools must also be included in the boot image. This is
       accomplished with the
       <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm139781528316016"></a> attribute of the
       <code class="sgmltag-element">package</code> element. This is shown in
       the example below:
      </p><pre class="screen">&lt;packages type="bootstrap"&gt;
  &lt;package name="cifs-utils" bootinclude="true"/&gt;
  &lt;/packages&gt;</pre></dd><dt><span class="term">
      <code class="uri">this://<em class="replaceable"><code>PATH</code></em>
      </code>
     </span></dt><dd><p>
       <em class="replaceable"><code>PATH</code></em> is the relative location to the image
       description directory for the current image.
      </p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.packages"></a>4.1.8. <code class="sgmltag-element">packages</code> Element<span class="permalink"><a alt="Permalink" title="4.1.8. packages Element" href="#sec.description.packages">¶</a></span></h3></div></div></div><pre class="screen">&lt;packages type="type" profiles="name" patternType="type"
   &lt;package name="name" arch="arch"/&gt;
   &lt;package name="name" replaces="name"/&gt;
   &lt;package name="name" bootinclude="true" bootdelete="true"/&gt;
   &lt;archive name="name" bootinclude="true"/&gt;
   &lt;package .../&gt;
   &lt;namedCollection name="name"/&gt;
   &lt;namedCollection .../&gt;
   &lt;opensuseProduct name="name"/&gt;
   &lt;opensuseProduct .../&gt;
   &lt;ignore name="name"/&gt;
   &lt;ignore .../&gt;
&lt;/packages&gt;</pre><p>
    The mandatory <code class="sgmltag-element">packages</code> element specifies the list of
    packages (element <code class="sgmltag-element">package</code>) and patterns (element
    <code class="sgmltag-element">namedCollection</code>) to be used with the image. The value
    of the <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781528305680"></a> attribute
    specifies how the packages and patterns listed are handled, supported
    values are as follows:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attvalue">bootstrap</code>
     </span></dt><dd><p>
       Bootstrap packages, list of packages for the new operating system
       root tree. The packages list the required components to support a
       chroot environment in the new system root tree, such as glibc.
      </p></dd><dt><span class="term"><code class="sgmltag-attvalue">delete</code>
     </span></dt><dd><p>
       Delete packages, list of packages to be deleted from the image being
       created.
      </p><p>
       When using the delete type only <code class="sgmltag-element">package</code> elements
       are considered, all other specifications such as
       <code class="sgmltag-element">namedCollection</code> are ignored. The given package
       names are stored in the $<code class="envar">delete</code><a class="indexterm" name="idm139781528298544"></a> environment variable
       of the <code class="filename">/.profile</code> file created by KIWI. The list
       of package names is returned by the
       <code class="function">baseGetPackagesForDeletion</code> function. This list
       can then be used to delete the packages ignoring requirements or
       dependencies. This can be accomplished in the
       <span class="command"><strong>config.sh</strong></span> or <span class="command"><strong>images.sh</strong></span> script
       by calling the following helper function:
      </p><pre class="screen"><span class="command"><strong>suseRemovePackagesMarkedForDeletion</strong></span></pre><p>
       Note, that the delete value is indiscriminate of the image type being
       built.
      </p></dd><dt><span class="term"><code class="sgmltag-attvalue">image</code>
     </span></dt><dd><p>
       Image packages, list of packages to be installed in the image.
      </p></dd><dt><span class="term"><code class="sgmltag-attvalue">iso</code>
     </span></dt><dd><p>
       Image packages, a list of additional packages to be installed when
       building an ISO image.
      </p></dd><dt><span class="term"><code class="sgmltag-attvalue">oem</code>
     </span></dt><dd><p>
       Image packages, a list of additional packages to be installed when
       building an OEM image.
      </p></dd><dt><span class="term"><code class="sgmltag-attvalue">pxe</code>
     </span></dt><dd><p>
       Image packages, a list of additional packages to be installed when
       building an PXE image.
      </p></dd><dt><span class="term"><code class="sgmltag-attvalue">vmx</code>
     </span></dt><dd><p>
       Image packages, a list of additional packages to be installed when
       building a vmx virtual image of any format.
      </p></dd></dl></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.descriptions.using-patterns"></a>4.1.8.1. Using Patterns<span class="permalink"><a alt="Permalink" title="4.1.8.1. Using Patterns" href="#sec.descriptions.using-patterns">¶</a></span></h4></div></div></div><a class="indexterm" name="idm139781528281152"></a><p>
     Using a pattern name allows you to considerably shorten the list of
     specified packages in the <code class="filename">config.xml</code> file. A named
     pattern, specified with the
     <code class="sgmltag-element">namedCollection</code> element
     is a representation of a predefined list of packages. Specifying a
     pattern will install all packages listed in the named pattern to be
     installed in the image. Support for patterns is distribution specific
     and available with SLES, openSUSE, CentOS and RHEL. The optional
     <code class="sgmltag-attribute">patternType</code><a class="indexterm" name="idm139781528277440"></a> attribute on the
     <code class="sgmltag-element">packages</code> element allows you to
     control the installation of dependent packages in the image. You may
     assign one of the following values to the
     <code class="sgmltag-attribute">patternType</code><a class="indexterm" name="idm139781528275152"></a> attribute:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">onlyRequired</code><a class="indexterm" name="idm139781528272880"></a>
      </span></dt><dd><p>
        Incorporates only patterns and packages that the specified patterns
        and packages require. This is a "hard dependency" only resolution.
       </p></dd><dt><span class="term"><code class="sgmltag-attribute">plusRecommended</code><a class="indexterm" name="idm139781528269792"></a>
      </span></dt><dd><p>
        Incorporates patterns and packages that are required and recommended
        by the specified patterns and packages in
        <code class="filename">config.xml</code>.
       </p></dd></dl></div><p>
     By default, only required patterns and packages are installed. KIWI
     depends on the package manager to resolve the specified list of
     patterns and packages against the specified repositories and complete
     the installation. Note that not all supported package managers support
     the use of named patterns, thus the value of the
     <code class="sgmltag-element">packageManager</code> element determines
     whether you are able to use named patterns or not. Should the list of
     specified packages result in a conflict the image creation process will
     stop and the information provided by the package manager will be
     captured in the build log and will be displayed in the terminal window
     where KIWI was started. The <code class="sgmltag-element">ignore</code>
     element may be of use in resolving such conflicts. However, the
     <code class="sgmltag-element">ignore</code> element is
     limited to effect packages named explicitly. Packages installed in the
     image through a named pattern are not effected by the
     <code class="sgmltag-element">ignore</code> element setting.
     Therefore, package conflicts created by packages within named patterns
     cannot be resolved using the ignore mechanism. Further, if a package is
     specified to be ignored, but is required by another package, then the
     required package is installed in the image via the automatic dependency
     resolution by the package manager in use.
    </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.description.architecture-restrictions"></a>4.1.8.2. Architecture Restrictions<span class="permalink"><a alt="Permalink" title="4.1.8.2. Architecture Restrictions" href="#sec.description.architecture-restrictions">¶</a></span></h4></div></div></div><a class="indexterm" name="idm139781528261696"></a><p>
     To restrict a package to a specific architecture, use the arch
     attribute to specify a comma separated list of allowed architectures.
     Such a package is only installed if the build systems architecture
     (<span class="command"><strong>uname</strong></span> <code class="option">-m</code>) matches one of the
     specified values of the arch attribute.
    </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.description.packages.to.become.included"></a>4.1.8.3. Packages to Become Included Into the Boot Image<span class="permalink"><a alt="Permalink" title="4.1.8.3. Packages to Become Included Into the Boot Image" href="#sec.description.packages.to.become.included">¶</a></span></h4></div></div></div><p>
     The optional attributes bootinclude and bootdelete can be used to mark
     a package inside the system image description to become part of the
     corresponding boot image (initrd). This feature is most often used to
     specify bootsplash and/or graphics boot related packages inside the
     system image description but they are required to be part of the boot
     image as the data is used at boot time of the image.
    </p><p>
     Packages included into the boot image with the
     <code class="sgmltag-attribute">bootinclude</code><a class="indexterm" name="idm139781528256048"></a> are still
     included into the system image as well. If packages should only be
     included into the boot image, but not the system image, they need to be
     added to the <code class="sgmltag-element">packages</code> section of
     <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781528253728"></a>=<code class="sgmltag-attvalue">delete</code>.
    </p><p>
     If the bootdelete attribute is specified along with the bootinclude
     attribute this means that the selected package will be marked as a
     <span class="quote">“<span class="quote">to become deleted</span>”</span> package and is removed by the contents
     of the <span class="command"><strong>images.sh</strong></span> script of the corresponding boot
     image description.
    </p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.description.data.not.available"></a>4.1.8.4. Data not Available as Packages to Become Included<span class="permalink"><a alt="Permalink" title="4.1.8.4. Data not Available as Packages to Become Included" href="#sec.description.data.not.available">¶</a></span></h4></div></div></div><p>
     With the optional <code class="sgmltag-element">archive</code> element it’s possible to
     include any kind of data into the image. The archive elements expects
     the name of a tarball which must exist as part of the system image
     description. KIWI then picks up the tarball and installs it into the
     image. If the bootinclude attribute is set along with the archive
     element the data will also become installed into the boot image.
    </p></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.adv_setup"></a>Chapter 5. Advanced Configuration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#chap.caches">5.1. Image Caches</a></span></dt><dt><span class="sect1"><a href="#chap.raid">5.2. KIWI RAID Support</a></span></dt><dt><span class="sect1"><a href="#chap.partitions">5.3. KIWI Custom Partitions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#chap.partitions.lvm">5.3.1. Custom Partitioning via LVM</a></span></dt><dt><span class="sect2"><a href="#chap.partitions.btrfs">5.3.2. Custom Partitioning via Btrfs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#chap.encryption">5.4. KIWI Encryption Support</a></span></dt></dl></div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
   In this chapter you will learn how to speed up image rebuilds by using
   images caches. It also deals with setting up images supporting complex
   storage scenarios such as RAID, LVM and encrypted partitions.
  </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="chap.caches"></a>5.1. Image Caches<span class="permalink"><a alt="Permalink" title="5.1. Image Caches" href="#chap.caches">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781528244768"></a><p>
   The process of creating an appliance could take quite some time and often
   the same software is installed over and over again. To speed up that
   process KIWI can create and re-use so called image caches. An image cache
   in KIWI is a partial root tree created from a cache image description.
  </p><div class="figure"><a name="fig.imagecachingarch"></a><p class="title"><b>Figure 5.1. Image Caching Architecture</b><span class="permalink"><a alt="Permalink" title="Figure 5.1. Image Caching Architecture" href="#fig.imagecachingarch">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><img src="images/cache.png" alt="Image Caching Architecture"></div></div></div><br class="figure-break"><p>
   A cache needs to be created before it can be used. This can be done using
   any standard kiwi image description, including boot image
   descriptions. That means you can simply use one of the template or *boot
   descriptions and create a cache from it. However, it is more efficient to
   create image descriptions for the sole purpose of caching. Such
   descriptions could represent a set of patterns for example. The less
   specific a cache is the more often it can be re-used
  </p><p>
   Once there are caches in the system KIWI selects the best match and
   mounts the cache in a way that all write actions (copy-on-write cache)
   are redirected to the new root system. That way the cache itself is never
   changed and can be re-used simultaneously for other build processes. As a
   result the build process does not start with an empty tree but with a tree
   filled with the contents of the cache. Only the missing parts need to be
   added, which speeds up the build considerably.
  </p><div class="example"><a name="sec.caches.example"></a><p class="title"><b>Example 5.1. Building Multiple VMX Images</b><span class="permalink"><a alt="Permalink" title="Example 5.1. Building Multiple VMX Images" href="#sec.caches.example">¶</a></span></p><div class="example-contents"><p>
   Assume we want to build some images of type 'vmx' based on the SLES 12 JeOS
   image description. Create image caches for the system and the boot image
   like follows:
  </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
     Build the boot image (initrd) cache:
    </p><pre class="screen">kiwi --init-cache /usr/share/kiwi/image/vmxboot/suse-SLES12</pre></li><li class="step"><p>
     Build the JeOS image cache:
    </p><pre class="screen">kiwi --init-cache /usr/share/kiwi/image/suse-SLE12-JeOS/</pre></li></ol></div><p>
   By default those caches will be created in
   <code class="filename">/var/cache/kiwi-images</code>. To run a build which uses
   caches, run the following command;
  </p><pre class="screen">kiwi --build suse-SLE12-JeOS -d /tmp/myimage --type vmx \
     --cache /var/cache/kiwi-images</pre><p>
   This call speeds up the build a lot compared to building without
   caches. It is important to understand that a cache based build will create a
   root tree which contains only the differences compared to the used
   cache. Thus at any time you want to create an image out of it you need to
   make sure that the cache exists and is accessible on the system.
  </p></div></div><br class="example-break"></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="chap.raid"></a>5.2. KIWI RAID Support<span class="permalink"><a alt="Permalink" title="5.2. KIWI RAID Support" href="#chap.raid">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781528226528"></a><p>
  KIWI supports three types of RAID systems:
 </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Real RAID Controllers with Their Own Firmware</span></dt><dd><p>
     KIWI only needs to make sure the drivers are part of the initrd e.g cciss
     for the smart array controllers built into some server boards.
    </p></dd><dt><span class="term">BIOS RAID Controllers</span></dt><dd><p>
     Cheap onboard controller devices with the RAID software inside the BIOS
     (so called fake RAID). Linux supports some of them with the 'dmraid'
     utility and the support is a mix of BIOS calls and some device mapper
     calls.
    </p><p>
     The check for these devices can be switched on and off with
     &lt;oem-ataraid-scan&gt;true|false&lt;/oem-ataraid-scan&gt;
    </p></dd><dt><span class="term">Linux Software RAID</span></dt><dd><p>
     There is no hardware involved. The Linux kernel can control any storage
     device by adding RAID capabilities. All the work done by a real
     hardware controller is done in software.
    </p><p>
     All this is done using the 'mdadm' utility. The metadata for the
     devices are stored in RAID blocks on the storage device which requires
     them to be of the correct partition type.
    </p><p>
     The software RAID is supported in a so called degraded mode. This means
     the RAID is created but not all devices to build it are attached. That is
     because an image initially only consists of a single disk. The user needs
     to add devices or change the RAID mode manually after deployment. This is
     an easy task if the system comes up prepared accordingly. To use
     Linux software raid in KIWI images you only need to set:
    </p><p>
     &lt;type ... mdraid="mirroring"&gt;
    </p><p>
     Currently kiwi supports a degraded mirroring (raid:1) or stripping
     (raid:0) configuratiom but you can change the mode to any supported raid
     level after deployment.
    </p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="chap.partitions"></a>5.3. KIWI Custom Partitions<span class="permalink"><a alt="Permalink" title="5.3. KIWI Custom Partitions" href="#chap.partitions">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781528215312"></a><a class="indexterm" name="idm139781528214176"></a><a class="indexterm" name="idm139781528213040"></a><p>
  KIWI supports custom partitioning via LVM, the logical volume manager
  for the Linux kernel, or on file systems with volume support like Btrfs or
  ZFS.
 </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="chap.partitions.lvm"></a>5.3.1. Custom Partitioning via LVM<span class="permalink"><a alt="Permalink" title="5.3.1. Custom Partitioning via LVM" href="#chap.partitions.lvm">¶</a></span></h3></div></div></div><p>
   To define an LVM volume, a <code class="sgmltag-element">systemdisk</code>
   element within the <code class="sgmltag-element">type</code> element in the
   <code class="filename">config.xml</code> file must be defined. The
   <code class="sgmltag-element">systemdisk</code> element has an optional
   attribute <code class="sgmltag-attribute">name</code><a class="indexterm" name="idm139781528207088"></a>, which specifies the
   volume group name.
  </p><p>
   For additional non root or swap volumes the
   <code class="sgmltag-element">systemdisk</code> element can contain the
   child element <code class="sgmltag-element">volume</code>, with four
   possible attributes:
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="sgmltag-attribute">name</code><a class="indexterm" name="idm139781528203184"></a>
    </span></dt><dd><p>
      A required attribute. The name of the volume. If <code class="sgmltag-attribute">mountpoint</code><a class="indexterm" name="idm139781528200960"></a> is not specified, a directory
      with the given name will be created by KIWI if it does not already exist
      inside the root tree. However, if the name contains the KIWI internal
      path field separator <span class="quote">“<span class="quote">_</span>”</span>, it is required to specify the
      path in an additional mount point attribute. The special value
      <span class="emphasis"><em>@root</em></span> can be combined with the <code class="sgmltag-attribute">size</code><a class="indexterm" name="idm139781528198336"></a> or <code class="sgmltag-attribute">freespace</code><a class="indexterm" name="idm139781528196832"></a> attribute to control the size of
      the root volume.
     </p></dd><dt><span class="term"><code class="sgmltag-attribute">size</code><a class="indexterm" name="idm139781528194480"></a>
    </span></dt><dd><p>
      An optional attribute. Absolute size of the volume. If the size value is
      too small to store all data kiwi will exit. If no suffix is used, the
      value will be considered as Megabytes, otherwise add
      <code class="literal">M</code> (Megabyte) or <code class="literal">G</code> (Gigabyte) as
      suffix.
     </p></dd><dt><span class="term"><code class="sgmltag-attribute">freespace</code><a class="indexterm" name="idm139781528190080"></a>
    </span></dt><dd><p>
      An optional attribute. Free space to be added to this volume.  If no
      suffix is used, the value will be considered as Megabytes, otherwise add
      <code class="literal">M</code> (Megabyte) or <code class="literal">G</code> (Gigabyte) as
      suffix.
     </p></dd><dt><span class="term"><code class="sgmltag-attribute">mountpoint</code><a class="indexterm" name="idm139781528185744"></a>
    </span></dt><dd><p>
      An optional attribute. Specifies a path which needs to exist inside the
      root directory.
     </p></dd></dl></div><div class="example"><a name="ex.lvm"></a><p class="title"><b>Example 5.2. Examples for Configuring LVM</b><span class="permalink"><a alt="Permalink" title="Example 5.2. Examples for Configuring LVM" href="#ex.lvm">¶</a></span></p><div class="example-contents"><p>
   The following example will create a logical volume named
   <code class="literal">LVtmp</code> with minimal size to store the content of
   <code class="filename">/tmp</code><a class="indexterm" name="idm139781528180880"></a> of the image at build time.
   The volume is mounted to <code class="filename">/tmp</code><a class="indexterm" name="idm139781528179056"></a>:
  </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type ...&gt;
      &lt;systemdisk name="vgroup-name"&gt;
        &lt;volume name="tmp"/&gt;
      &lt;/systemdisk&gt;
      ...
    &lt;/type&gt;
    ...
  &lt;/preferences&gt;
  ...
&lt;/image&gt;</pre><p>
   To set the volume size to 200 MB use:
  </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type ...&gt;
      &lt;systemdisk name="vgroup-name"&gt;
        &lt;volume name="tmp" size="200M"/&gt;
      &lt;/systemdisk&gt;
      ...
    &lt;/type&gt;
    ...
  &lt;/preferences&gt;
  ...
&lt;/image&gt;</pre><p>
   To create the logical volume named <code class="literal">foo</code> with 500 MB of free space mounted as <code class="filename">/tmp</code><a class="indexterm" name="idm139781528173856"></a>, use:
  </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type ...&gt;
      &lt;systemdisk name="vgroup-name"&gt;
        &lt;volume name="tmp" freespace="500M" mountpoint="tmp"/&gt;
      &lt;/systemdisk&gt;
      ...
    &lt;/type&gt;
    ...
  &lt;/preferences&gt;
  ...
&lt;/image&gt;</pre><p>
   The volumes <code class="literal">LVRoot</code> and <code class="literal">LVSwap</code> for the
   root file system and for swap, will always be generated. To control the
   size if <code class="literal">LVRoot</code>, use the special name
   <code class="literal">@root</code>.
  </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type ...&gt;
      &lt;systemdisk name="vgroup-name"&gt;
        &lt;volume name="@root" size="2M"/&gt;
      &lt;/systemdisk&gt;
      ...
    &lt;/type&gt;
    ...
  &lt;/preferences&gt;
  ...
&lt;/image&gt;</pre></div></div><br class="example-break"></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="chap.partitions.btrfs"></a>5.3.2. Custom Partitioning via Btrfs<span class="permalink"><a alt="Permalink" title="5.3.2. Custom Partitioning via Btrfs" href="#chap.partitions.btrfs">¶</a></span></h3></div></div></div><p>
   If Btrfs is used as a file system, the subvolume management is configured
   via the same <code class="sgmltag-element">systemdisk</code> element as
   explained in <a class="xref" href="#chap.partitions.lvm" title="5.3.1. Custom Partitioning via LVM">Section 5.3.1, “Custom Partitioning via LVM”</a>. Also the same rules as
   explained for lvm volumes applies to Btrfs subvolumes with the following
   exception;
  </p><p><b>There is no @root volume and no size setup. </b>
    The Btrfs file system is created with an initial size which can be
    specified by the <code class="sgmltag-element">size</code> element All
    subvolumes are part of the file system itself and managed by a
    namespace. The overall size is shared across the entire file system and the
    size of an entity can be controlled by a Btrfs quota which is not applied
    by kiwi at the moment
   </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="chap.encryption"></a>5.4. KIWI Encryption Support<span class="permalink"><a alt="Permalink" title="5.4. KIWI Encryption Support" href="#chap.encryption">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781528161584"></a><a class="indexterm" name="idm139781528160448"></a><p>
  KIWI supports Linux Unified Key Setup (LUKS) encrypted images. To set up an
  encrypted volume , add the attribute <code class="sgmltag-attribute">luks</code><a class="indexterm" name="idm139781528158304"></a> to the <code class="sgmltag-element">type</code> element in
  <code class="filename">config.xml</code>. The value of the attribute represents the
  password string which will be required to mount the file system while
  booting:
 </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type ... luks="<em class="replaceable"><code>password</code></em>"/&gt;
  &lt;/preferences&gt;
  ...
&lt;/image&gt;</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.maintenance"></a>Chapter 6. Maintaining Appliance Images</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.maintenance.packages">6.1. Image Maintenance: Updating Software Packages</a></span></dt><dt><span class="sect1"><a href="#sec.maintenance.config">6.2. Image Maintenance: Modifying the Configuration</a></span></dt></dl></div><a class="indexterm" name="idm139781528153680"></a><div class="abstract"><p class="title"><b>Abstract</b></p><p>
   Whenever you create an appliance as described in <a class="xref" href="#chap.appliance" title="Chapter 14. Creating Appliances">Chapter 14, <i>Creating Appliances</i></a>, you are using a snapshot of the software
   repositories. As time goes by, the software continues to develop and the
   image becomes outdated. Something similar applies to the appliance
   configuration, which may become outdated when, for example, the network
   setup has changed or services have been replaced. Last, it may be necessary
   to update the image description itself, for example to add or change
   repositories. To prevent an image from becoming outdated, KIWI provides
   means to <span class="emphasis"><em>maintain</em></span> existing images.
  </p></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="command"><strong>kiwi --upgrade</strong></span></span></dt><dd><p>
     The <code class="option">--upgrade</code> option can be used to update a previously
     built image without making any changes to the image description. It
     requires an existing unpacked root tree. This option can be used to update
     software packages within an image. Since it only modifies an existing
     root tree, it is faster than re-building an image from scratch.
    </p></dd><dt><span class="term">kiwi --prepare</span></dt><dd><p>
     In case the appliance configuration or the image description needs to be
     changed, the image root tree needs to be rebuilt with
     <code class="option">--prepare</code> to make these changes permanent. We
     using this method to upgrade an existing image, it is recommended to put
     the image description under a version control system such as git or
     subversion. This allows to track the changes and to easily switch between
     image versions.
    </p></dd></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.maintenance.packages"></a>6.1. Image Maintenance: Updating Software Packages<span class="permalink"><a alt="Permalink" title="6.1. Image Maintenance: Updating Software Packages" href="#sec.maintenance.packages">¶</a></span></h2></div></div></div><p>
   The quickest way to produce an updated image containing the latest software
   versions from the repositories configured in the image description is to
   use KIWI's <code class="option">--upgrade</code> option. It optionally allows to
   specify additional repositories (such as an update repository) or packages
   on the command line. Using <code class="option">--upgrade</code> requires an existing
   unpacked image tree from a previous run of <span class="command"><strong>kiwi
   --prepare</strong></span>.
  </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
     Make sure you know the path to the existing unpacked root tree. In the
     following we assume it is located at <code class="filename">/tmp/myISO</code><a class="indexterm" name="idm139781528139872"></a>. If you need to add additional
     repositories, note down the paths and types.
    </p></li><li class="step"><p>
     Run the following command to update the unpacked root tree from the
     repositories configured in the image description:
    </p><pre class="screen">kiwi --upgrade /tmp/myISO</pre><p>
     You can optionally specify additional repositories not yet configured in
     the image description, or additional packages and/or patterns. The latter
     two can be part of the added repositories or the ones already configured.
    </p><pre class="screen">kiwi --upgrade /tmp/myISO --add-repo <em class="replaceable"><code>REPO</code></em> --add-repotype <em class="replaceable"><code>REPO_TYPE</code></em> \
--add-package <em class="replaceable"><code>PACKAGE</code></em> --add-pattern <em class="replaceable"><code>PATTERN</code></em></pre></li><li class="step"><p>
     Run <span class="command"><strong>kiwi --create</strong></span> to build the final image. The
     following example assumes that the image is created in
     <code class="filename">/tmp</code>:
    </p><pre class="screen">kiwi --create /tmp/myISO --destdir /tmp</pre></li></ol></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Adding Repositories, Packages or Patterns</h3><p>
    Repositories, packages or patterns that you specify with the --add-*
    commands are not added to the image description! Therefore these additions
    are not permanent and need to be specified again with the next run. If you
    want to make these additions permanent, proceed as described in <a class="xref" href="#sec.maintenance.config" title="6.2. Image Maintenance: Modifying the Configuration">Section 6.2, “Image Maintenance: Modifying the Configuration”</a>.
   </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Configuration Changes</h3><p>
    Running KIWI with the <code class="option">--upgrade</code> option does not rebuild
    the root tree—it only manipulates the existing version that was
    created with the last <code class="option">--prepare</code>-run. Changes to the image
    description that have been made after the last
    <code class="option">--prepare</code>-run, have no effect when running the
    <code class="option">--upgrade</code> option.
   </p><p>
    In case of un-applied configuration changes, rebuild the unpacked root
    tree from scratch with <span class="command"><strong>kiwi --prepare</strong></span>.
   </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.maintenance.config"></a>6.2. Image Maintenance: Modifying the Configuration<span class="permalink"><a alt="Permalink" title="6.2. Image Maintenance: Modifying the Configuration" href="#sec.maintenance.config">¶</a></span></h2></div></div></div><p>
   In case you need to change the configuration of the appliance (see <a class="xref" href="#sec.appliance.kiwi-model" title="14.1. The KIWI Model">Section 14.1, “The KIWI Model”</a>) or the image description (see <a class="xref" href="#chap.description" title="Chapter 4. KIWI Image Description">Chapter 4, <i>KIWI Image Description</i></a> you need to rebuild the complete image tree by
   running <span class="command"><strong>kiwi --prepare</strong></span>, to make your changes
   permanent. It is strongly recommended to put your image description under a
   version control system to enable tracking of changes and different version
   builds.
  </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
     Put your image description directory under a version control system such
     as git. This step is optional, but strongly recommended.
    </p></li><li class="step"><p>
     Change the image description as needed. Stick to the following general
     rules:
    </p><ol type="a" class="substeps"><li class="step"><p>
       To add packages or patterns, modify the respective entries in
       <code class="filename">configuration.xml</code>. See <a class="xref" href="#sec.description.packages" title="4.1.8. packages Element">Section 4.1.8, “<code class="sgmltag-element">packages</code> Element”</a> for details.
      </p></li><li class="step"><p>
       To change the list of repositories, modify the respective entries in
       <code class="filename">configuration.xml</code>. See <a class="xref" href="#sec.description.repository" title="4.1.7. repository Element">Section 4.1.7, “<code class="sgmltag-element">repository</code> Element”</a> for details.
      </p></li><li class="step"><p>
       To change the configuration of your appliance, modify the respective
       files in the overlay tree or provide an updated archive.
      </p></li><li class="step"><p>
       To change the user-defined tasks that will be carried out after the
       installation (for example activating services), adjust the
       <code class="filename">configuration.sh</code> script.
      </p></li></ol></li><li class="step"><p>
     Create an unpacked root tree by running <span class="command"><strong>kiwi
     --prepare</strong></span>. The following example assumes that the image
     description is located under
     <code class="filename">/tmp/myISO_config</code> and that the result is
     written to <code class="filename">/tmp/myISO</code>:
    </p><pre class="screen">kiwi --prepare /tmp/myISO_config --root /tmp/myISO</pre></li><li class="step"><p>
     Run <span class="command"><strong>kiwi --create</strong></span> to build the final image. The
     following example assumes that the image is created in
     <code class="filename">/tmp</code>:
    </p><pre class="screen">kiwi --create /tmp/myISO --destdir /tmp</pre></li><li class="step"><p>
     When the final version of your changes has been applied, make sure to
     check this state in to the version control system.
    </p></li></ol></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Do not Manipulate the Unpacked Root Image</h3><p>
    The unpacked image directory is a directory, as far as the build system is
    concerned and you can manipulate the content of this directory according
    to your needs. Since it represents a system installation you can “chroot”
    into this directory for testing purposes. The file system contains an
    additional directory named /image that is not present in a regular
    system. It contains information KIWI requires during the create step,
    including a copy of the config.xml file.
   </p><p>
    Do not make any changes to the system, since they will get lost when
    re-running the prepare step again. Whats more, you may introduce errors
    that will occur during the create step, that are difficult to track. The
    recommended way to apply changes to the unpacked image directory is to
    change the configuration and re-run the prepare step as described above.
   </p></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a name="part.usecases"></a>Part II. Usecases</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#chap.iso">7. ISO Image / Live System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.iso.cd">7.1. Building Live CD/DVD Images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.split-mode">7.1.1. Split mode</a></span></dt><dt><span class="sect2"><a href="#sec.iso.hybrid-mode">7.1.2. Hybrid mode</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.iso.usb">7.2. Building Live Images for Removable USB Devices</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.usb.hybrid">7.2.1. Hybrid ISO Image</a></span></dt><dt><span class="sect2"><a href="#sec.iso.tmpfs">7.2.2. In RAM ISO Image</a></span></dt><dt><span class="sect2"><a href="#sec.iso.usb.oem">7.2.3. OEM Virtual Disk Image</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.vmx">8. VMX Image / Virtual Disks</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.vmx.building">8.1. Building VMX Images</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.vmware-support">8.2. VMware support</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.lvm">8.3. LVM Support</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.bootpartition">8.4. Extra Boot Partition</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.docker">9. Docker images</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.docker.building">9.1. Building Docker Images</a></span></dt><dt><span class="sect1"><a href="#sec.docker.details">9.2. Image Configuration Details</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.vagrant">10. Vagrant boxes</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.vagrant.building">10.1. Building Vagrant Boxes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.pxe">11. PXE Image / Thin Clients</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.pxe.building">11.1. Building PXE Images</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.files">11.2. PXE Configuration Files</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.client-config-file">11.3. The PXE Client Configuration File Syntax</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.another-user">11.3.1. Use a Different Download Protocol</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.ram-only-image">11.3.2. RAM Only Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.union-image">11.3.3. Union Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.split-image">11.3.4. Split Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.remote-root">11.3.5. Mounting the Root File System from a Remote Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.groups">11.4. Hardware Grouping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.groups.def_file">11.4.1. The Group Definition File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.groups.group_file">11.4.2. The Group Configuration File</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.oem">12. OEM Image / Preload Systems</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.oem.building">12.1. Building an OEM System and an Installation Image</a></span></dt><dt><span class="sect1"><a href="#sec.oem.testing">12.2. Testing the Images</a></span></dt><dt><span class="sect1"><a href="#sec.oem.flavours">12.3. Installation Image Flavors</a></span></dt><dt><span class="sect1"><a href="#sec.oem.customize">12.4. Customizing the OEM Images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.oem.customize.installation">12.4.1. Customizing the OEM Install Process</a></span></dt><dt><span class="sect2"><a href="#sec.oem.customize.parameters">12.4.2. OEM Customizing Parameters</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partition-based-installation">12.4.3. Partition Based Installation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.oem.pxe-based-installation">12.5. Network Based Installation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.xen">13. Xen Para- and Full virtual Images</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.xen.dom0.building">13.1. Building a Dom0 Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.dom0.using">13.2. Testing the Dom0 Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.pv.building">13.3. Building a Paravirtualized Xen Guest Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.hvm.building">13.4. Building a Fully Virtualized Xen Guest</a></span></dt><dt><span class="sect1"><a href="#sec.xen.using">13.5. Using the Guest Images</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.appliance">14. Creating Appliances</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.appliance.kiwi-model">14.1. The KIWI Model</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.migration">15. System Analysis/Migration</a></span></dt></dl></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.iso"></a>Chapter 7. ISO Image / Live System</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.iso.cd">7.1. Building Live CD/DVD Images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.split-mode">7.1.1. Split mode</a></span></dt><dt><span class="sect2"><a href="#sec.iso.hybrid-mode">7.1.2. Hybrid mode</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.iso.usb">7.2. Building Live Images for Removable USB Devices</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.usb.hybrid">7.2.1. Hybrid ISO Image</a></span></dt><dt><span class="sect2"><a href="#sec.iso.tmpfs">7.2.2. In RAM ISO Image</a></span></dt><dt><span class="sect2"><a href="#sec.iso.usb.oem">7.2.3. OEM Virtual Disk Image</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm139781528098000"></a><a class="indexterm" name="idm139781528096864"></a><a class="indexterm" name="idm139781528095728"></a><div class="abstract"><p class="title"><b>Abstract</b></p><p>
   A live system image is an operating System on CD, DVD or removable USB
   storage. It can bee booted directly from the media. A CD/DVD live system is
   read-only—all changes to the system are done in RAM will be lost as
   soon as the computer shuts down. A removable USB storage can optionally be
   set up with an additional partition (hybrid ISO image) which can be used for
   writing data.
  </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">ISO Image Description Templates</h3><p>
   KIWI comes with many image description templates. It is
   recommended to use them as a basis for your own image descriptions. To do
   so, copy the respective directory containing the image description of your
   choice to you working directory and adjust it according to your needs.
  </p><p>
   ISO image templates are shipped with the package
   <span class="package">kiwi-desc-isoboot</span>. They are installed to
   <code class="filename">/usr/share/kiwi/image/isoboot</code>.
  </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Just Enough Operating System (JeOS) Templates</h3><p>
   The package <span class="package">kiwi-templates</span> contains ready-to-use JeOS
   templates. They are installed to <code class="filename">/usr/share/kiwi/image/*-JeOS/</code><a class="indexterm" name="idm139781528088224"></a>. These
   templates can be used without any modification to build images containing
   a minimal operating system. The template directory is in KIWI's search
   path, therefore it is sufficient to only specify the name of the
   <code class="filename">*-JeOS</code> directory on the KIWI command line. Get a list
   of available templates with the following command:
  </p><pre class="screen">(cd /usr/share/kiwi/image/ &amp;&amp; ls -d1 *-JeOS)</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.iso.cd"></a>7.1. Building Live CD/DVD Images<span class="permalink"><a alt="Permalink" title="7.1. Building Live CD/DVD Images" href="#sec.iso.cd">¶</a></span></h2></div></div></div><p>
   The following example shows how to build a Just enough Operating
   System (JeOS) based on SUSE Linux Enterprise 12:
  </p><pre class="screen">kiwi --build suse-SLE12-JeOS -d /tmp/myiso-result --type iso</pre><p>
   There are two possibilities to use the ISO image generated above:
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
     Burn the <code class="filename">.iso</code><a class="indexterm" name="idm139781528080688"></a> file on a CD or
     DVD with your preferred burn program. Plug in the CD or DVD into a test
     computer and (re)boot the machine. Make sure the computer boots from the
     CD drive as first boot device.
    </p></li><li class="listitem"><p>
     Use a virtualization system to test the image directly. Testing an ISO
     image can be done with any full virtual system for example
     <code class="literal">QEMU</code>:
    </p><pre class="screen">qemu -cdrom /tmp/myiso-result/LimeJeOS-SLE12.x86_64-1.13.1.iso</pre></li></ol></div><p>
   KIWI supports different flavors of file systems and boot methods along with
   the ISO image type. The template <code class="literal">suse-SLE12-JeOS</code> from
   the example above, uses an <code class="systemitem">overlayfs</code><a class="indexterm" name="idm139781528075072"></a>-based compressed root
   file system. Set the file system type with the <code class="sgmltag-attribute">flags</code><a class="indexterm" name="idm139781528073472"></a> attribute in
   <code class="filename">config.xml</code>:
  </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type image="iso" flags="<em class="replaceable"><code>FSTYPE</code></em>" .../&gt;
    ...
  &lt;/preferences
  ...
&lt;/image&gt;</pre><p>
   The following values can be set for <em class="replaceable"><code>FSTYPE</code></em>:
  </p><div class="informaltable"><table border="1"><colgroup><col class="1"><col class="2"></colgroup><thead><tr><th><p>Value</p></th><th><p>Description</p></th></tr></thead><tbody><tr><td>
       <p>
        <code class="sgmltag-attvalue">compressed</code>
       </p>
      </td><td>
       <p>
        Does file system compression with squashfs, but does not use an
        overlay file system for write support. A symbolic link list is used
        instead and thus a <code class="sgmltag-element">split</code> element is
        required in <code class="filename">config.xml</code>. See <a class="xref" href="#sec.iso.split-mode" title="7.1.1. Split mode">Section 7.1.1, “Split mode”</a> for details.
       </p>
      </td></tr><tr><td>
       <p>
        <code class="sgmltag-attvalue">overlay</code>
       </p>
      </td><td>
       <p>
        <code class="systemitem">overlayfs</code><a class="indexterm" name="idm139781528057728"></a> allows to
        combine two file systems into one. The root file system exists as a
        compressed <code class="systemitem">squashfs</code><a class="indexterm" name="idm139781528055856"></a> file
        system and all write operations are redirected to the RAM or to a
        persistent area on a disk. The result is a fully writable
        live-system.
       </p>
      </td></tr><tr><td>
       <p>
        <code class="sgmltag-attvalue">seed</code>
       </p>
      </td><td>
       <p>
        Creates a <code class="systemitem">Btrfs</code><a class="indexterm" name="idm139781528051376"></a> image and
        allows write operations into a cow (seed) file. In case of an ISO
        image the seed device is created on a RAM disk.
       </p>
      </td></tr><tr><td><p><span class="emphasis"><em>unset</em></span></p></td><td>
       <p>
        If the <code class="sgmltag-attribute">flags</code><a class="indexterm" name="idm139781528047920"></a> attribute is not
        set, no compressed nor overlay file system will be used. The root tree
        will be directly part of the ISO file system and the paths:
        <code class="filename">/bin</code>, <code class="filename">/boot</code>,
        <code class="filename">/lib</code>, <code class="filename">/lib64</code>,
        <code class="filename">/opt</code>, <code class="filename">/sbin</code>, and
        <code class="filename">/usr</code> will be read-only.
       </p>
      </td></tr></tbody></table></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.iso.split-mode"></a>7.1.1. Split mode<span class="permalink"><a alt="Permalink" title="7.1.1. Split mode" href="#sec.iso.split-mode">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781528040832"></a><a class="indexterm" name="idm139781528039696"></a><p>
    If no overlay file system is in use but the image file system is based on
    a compressed file system, KIWI allows toc onfigure which files and
    directories should be writable in a so-called split section. To allow
    login in to the system, at least the <code class="filename">/var</code><a class="indexterm" name="idm139781528037152"></a> directory needs to be writable. This is
    because the PAM authentication requires to be able to report any login
    attempt to <code class="filename">/var/log/messages</code> which therefore needs to
    be writable. The following example ensures that <code class="filename">/boot</code><a class="indexterm" name="idm139781528034544"></a>, <code class="filename">/etc</code><a class="indexterm" name="idm139781528032800"></a>, <code class="filename">/home</code><a class="indexterm" name="idm139781528031056"></a>, and <code class="filename">/var</code><a class="indexterm" name="idm139781528029312"></a> are writable:
   </p><pre class="screen">&lt;image ...&gt;
  ...
  &lt;preferences&gt;
    &lt;type image="iso" flags="compressed" .../&gt;
    &lt;split&gt;
      &lt;persistent&gt;
        &lt;file name="/var"/&gt;
        &lt;file name="/var/*"/&gt;
        &lt;file name="/boot"/&gt;
        &lt;file name="/boot/*"/&gt;
        &lt;file name="/etc"/&gt;
        &lt;file name="/etc/*"/&gt;
        &lt;file name="/home"/&gt;
        &lt;file name="/home/*"/&gt;
        &lt;file name="/tmp"/&gt;
        &lt;file name="/tmp/*"/&gt;
      &lt;/persistent&gt;
    &lt;/split&gt;
    ...
  &lt;/type&gt;
&lt;/image&gt;</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.iso.hybrid-mode"></a>7.1.2. Hybrid mode<span class="permalink"><a alt="Permalink" title="7.1.2. Hybrid mode" href="#sec.iso.hybrid-mode">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781528025712"></a><a class="indexterm" name="idm139781528024576"></a><p>
    A hybrid image is an ISO image including a partition table.  therefore it
    cab be attached as a CD/DVD <span class="emphasis"><em>and</em></span> as a normal disk to
    the system. This has the advantage that a hybrid ISO live system can be
    burned to a CD/DVD and uploaded to a flash disk. To activate the hybrid
    feature the <code class="sgmltag-attribute">hybrid</code><a class="indexterm" name="idm139781528021840"></a> attribute must be
    set to <code class="sgmltag-attvalue">true</code> as follows:
   </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type image="iso" hybrid="true" .../&gt;
    ...
  &lt;/preferences
  ...
&lt;/image&gt;</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.iso.usb"></a>7.2. Building Live Images for Removable USB Devices<span class="permalink"><a alt="Permalink" title="7.2. Building Live Images for Removable USB Devices" href="#sec.iso.usb">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781528018224"></a><p>
   KIWI supports two types of images for removable USB devices. Hybrid ISO
   images are the same as the live CD/DVD images. The second type are OEM
   virtual disk images. The deployment of both types can be performed from any
   OS including Windows as long as a tool to dump data onto a disk device
   exists and is used.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.iso.usb.hybrid"></a>7.2.1. Hybrid ISO Image<span class="permalink"><a alt="Permalink" title="7.2.1. Hybrid ISO Image" href="#sec.iso.usb.hybrid">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781528015472"></a><p>
    As indicated above a hybrid ISO image also works as an image for removable
    USB devices. If a hybrid ISO image is used like a disk image on a writable
    medium like a flash disk, it is possible to write into a persistent area
    on the stick instead of the RAM. KIWI creates an additional Ext2 partition
    for this purpose if the attribute <code class="sgmltag-attribute">hybridpersistent</code><a class="indexterm" name="idm139781528013088"></a> is set to <code class="sgmltag-attvalue">true</code>.
   </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type image="iso" hybrid="true" .../&gt;
    ...
  &lt;/preferences
  ...
&lt;/image&gt;&lt;</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.iso.tmpfs"></a>7.2.2. In RAM ISO Image<span class="permalink"><a alt="Permalink" title="7.2.2. In RAM ISO Image" href="#sec.iso.tmpfs">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781528009600"></a><p>
    Any live CD iso image supports the <em class="replaceable"><code>toram</code></em> mode.
    In this mode the contents on the ISO are copied into a tmpfs on the
    system.  In the standard live image mode the ISO is only mounted to the
    system.  Reading the data from a tmpfs is however much faster than reading
    the data from CD/DVD drive or flash disk. An additional benefit of the
    toram mode is the ability to disconnect the CD/DVD drive or USB slot the
    live system originally existed. However the costs for the performance win
    are a slower initial start-up time and more RAM requirements. A minimum
    2GB of RAM is recommended to boot 700M compressed live image. To activate
    the toram mode place the following option at the boot prompt when the
    system starts up.
   </p><pre class="screen">toram</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.iso.usb.oem"></a>7.2.3. OEM Virtual Disk Image<span class="permalink"><a alt="Permalink" title="7.2.3. OEM Virtual Disk Image" href="#sec.iso.usb.oem">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781528005328"></a><p>
    In contrast to the hybrid ISO image it is also possible to create an OEM
    virtual disk image. This image type allows to create the
    live operating system plus a data partition for custom data. The data
    partition is a fat partition also recognized by Windows. To create such a
    partition use the option <code class="option">--fat-storage
    <em class="replaceable"><code>size-in-MB</code></em></code> on the KIWI command line:
   </p><pre class="screen">kiwi --create ... --fat-storage 500</pre><p>
    If this option is set, KIWI will use the syslinux boot loader for the
    image and for the first FAT partition with the specified size. The live
    operating system itself will be hosted on a logical volume (LVM), which
    allows to easily manipulate the logical root volume. For further
    information about the OEM image type refer <a class="xref" href="#chap.oem" title="Chapter 12. OEM Image / Preload Systems">Chapter 12, <i>OEM Image / Preload Systems</i></a>.
   </p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.iso.usb.oem.ro"></a>7.2.3.1. OEM compressed / Read-only removable USB Media<span class="permalink"><a alt="Permalink" title="7.2.3.1. OEM compressed / Read-only removable USB Media" href="#sec.iso.usb.oem.ro">¶</a></span></h4></div></div></div><a class="indexterm" name="idm139781528000096"></a><p>
     If a compressed file system type like <code class="systemitem">overlayfs</code><a class="indexterm" name="idm139781527997840"></a> is used for the image
     root directory,  it is also possible to choose whether to write on a
     partition or to the RAM. KIWI provides the attribute <code class="sgmltag-attribute">ramonly</code><a class="indexterm" name="idm139781527996160"></a> for this purpose. To create a
     read-only image with compressed
     root file system for a removable USB medium the following configuration
     is required:
    </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type image="iso" file system="overlayfs" ramonly="true" .../&gt;
    ...
  &lt;/preferences
  ...
&lt;/image&gt;</pre></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.vmx"></a>Chapter 8. VMX Image / Virtual Disks</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.vmx.building">8.1. Building VMX Images</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.vmware-support">8.2. VMware support</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.lvm">8.3. LVM Support</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.bootpartition">8.4. Extra Boot Partition</a></span></dt></dl></div><a class="indexterm" name="idm139781527992688"></a><a class="indexterm" name="idm139781527991552"></a><a class="indexterm" name="idm139781527990416"></a><div class="abstract"><p class="title"><b>Abstract</b></p><p>
   A VMX image is a virtual disk image for use in full virtualization systems
   like Qemu or VMware. The image is a file containing the system (represented
   by the configured packages in <code class="filename">config.xml</code>) as well as
   partition data and boot loader information. VMX images have a fixed disk
   size and geometry that cannot be changed (see <a class="xref" href="#chap.oem" title="Chapter 12. OEM Image / Preload Systems">Chapter 12, <i>OEM Image / Preload Systems</i></a>
   for images with expandable disks).
  </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">VMX Image Description Templates</h3><p>
   KIWI comes with many image description templates. It is
   recommended to use them as a basis for your own image descriptions. To do
   so, copy the respective directory containing the image description of your
   choice to you working directory and adjust it according to your needs.
  </p><p>
   VMX image templates are shipped with the package
   <span class="package">kiwi-desc-vmxboot</span>. They are installed to
   <code class="filename">/usr/share/kiwi/image/vmxboot</code>.
  </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Just Enough Operating System (JeOS) Templates</h3><p>
   The package <span class="package">kiwi-templates</span> contains ready-to-use JeOS
   templates. They are installed to <code class="filename">/usr/share/kiwi/image/*-JeOS/</code><a class="indexterm" name="idm139781527982256"></a>. These
   templates can be used without any modification to build images containing
   a minimal operating system. The template directory is in KIWI's search
   path, therefore it is sufficient to only specify the name of the
   <code class="filename">*-JeOS</code> directory on the KIWI command line. Get a list
   of available templates with the following command:
  </p><pre class="screen">(cd /usr/share/kiwi/image/ &amp;&amp; ls -d1 *-JeOS)</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vmx.building"></a>8.1. Building VMX Images<span class="permalink"><a alt="Permalink" title="8.1. Building VMX Images" href="#sec.vmx.building">¶</a></span></h2></div></div></div><p>
   The following example shows how to build a Just enough Operating System
   (JeOS) based on SUSE Linux Enterprise 12:
  </p><pre class="screen">kiwi --build suse-SLE12-JeOS -d /tmp/myvm-result --type vmx</pre><p>
   The command creates a virtual disk in the <code class="filename">.raw</code><a class="indexterm" name="idm139781527976192"></a> format that can be directly booted with any
   virtualization system. The following example shows how to boot it with QEMU:
  </p><pre class="screen">qemu /tmp/myvm-result/LimeJeOS-SLE12.x86_64-1.13.1.raw -m 1024 </pre><p>
   KIWI always generates a file in the <code class="filename">.raw</code><a class="indexterm" name="idm139781527973216"></a> format. The <code class="filename">.raw</code><a class="indexterm" name="idm139781527971472"></a> file is a disk image with an
   equivalent to the structure of a physical hard disk. <code class="filename">.raw</code><a class="indexterm" name="idm139781527969632"></a> images are supported by any hypervisor,
   but are rather big in size (not compressed) and do not offer the best
   performance. 
  </p><p>
   Therefore each virtualization system supports its own proprietary format
   supporting compression and improved I/O performance. To build an image in a
   format other than <code class="filename">.raw</code><a class="indexterm" name="idm139781527967168"></a>, add the
   <code class="sgmltag-attribute">format</code><a class="indexterm" name="idm139781527965664"></a> attribute to the type
   definition in <code class="filename">config.xml</code>:
  </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type format="<em class="replaceable"><code>FORMAT</code></em>" .../&gt;
    ...
  &lt;/preferences
  ...
&lt;/image&gt;</pre><p>
   The following values can be set for <em class="replaceable"><code>FORMAT</code></em>:
  </p><div class="table"><a name="tab.vmx.supported-disk-formats"></a><p class="title"><b>Table 8.1. Supported Virtual Disk Formats</b><span class="permalink"><a alt="Permalink" title="Table 8.1. Supported Virtual Disk Formats" href="#tab.vmx.supported-disk-formats">¶</a></span></p><div class="table-contents"><a class="indexterm" name="idm139781527961296"></a><a class="indexterm" name="idm139781527960160"></a><table summary="Supported Virtual Disk Formats" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>vmdk</td><td>Disk format for VMware</td></tr><tr><td>vhd|vhd-fixed</td><td>Disk format for Microsoft HyperV</td></tr><tr><td>ovf|ova</td><td>Open Virtual Format requires VMware's ovftool</td></tr><tr><td>qcow2</td><td>QEMU virtual disk format</td></tr><tr><td>vdi</td><td>Disk format for VirtualBox</td></tr><tr><td>vagrant</td><td>Vagrant Box Format</td></tr><tr><td>gce</td><td>Google Cloud Format</td></tr></tbody></table></div></div><br class="table-break"></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vmx.vmware-support"></a>8.2. VMware support<span class="permalink"><a alt="Permalink" title="8.2. VMware support" href="#sec.vmx.vmware-support">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781527946672"></a><a class="indexterm" name="idm139781527945536"></a><p>
   A VMware image is accompanied by a guest configuration file. This file
   includes information about the hardware to be represented by the guest
   as well as specifications of resources such as memory.
  </p><p>
   It is possible to specify the VMware configuration settings in
   <code class="filename">config.xml</code>. Additionally, it is possible to also
   include selected packages in the created image that are specific to the VM
   image generation. This is done in the <span class="emphasis"><em>machine</em></span> section
   in the configuration file. The following example will create a VMware
   guest configuration with 512 MB of RAM and an IDE disk controller:
  </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type format="vmdk" ...&gt;
      &lt;machine memory="512"&gt;
        &lt;vmdisk controller="ide" id="0"/&gt;
      &lt;/machine&gt;
      ...
    &lt;/type&gt;
    ...
  &lt;/preferences
  ...
&lt;/image&gt;</pre><p>
   The guest configuration can be loaded via the VMware user interface and may
   be modified through the GUI. The configuration file has the extension
   <code class="filename">.vmx</code><a class="indexterm" name="idm139781527939904"></a> and the same basename as the
   image:
  </p><pre class="screen">/tmp/myvm-result/LimeJeOS-SLE12.x86_64-1.13.1.vmx</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vmx.lvm"></a>8.3. LVM Support<span class="permalink"><a alt="Permalink" title="8.3. LVM Support" href="#sec.vmx.lvm">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781527937264"></a><p>
  Support for LVM has been added for all image types which are disk-based.  In
  order to use LVM for the vmx type just add the <code class="option">--lvm</code> option
  as part of the KIWI create/build step. Alternatively add the attribute
  lvm="true" as part of the type section in your
  <code class="filename">config.xml</code> file.
 </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type lvm="true" .../&gt;
    ...
  &lt;/preferences
  ...
&lt;/image&gt;</pre><p>
   When using modern file systems like Btrfs or zfs, KIWI also supports using
   their native volume management system. For more information how to setup
   custom partitions/volumes, see <a class="xref" href="#chap.partitions" title="5.3. KIWI Custom Partitions">Section 5.3, “KIWI Custom Partitions”</a>.
 </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vmx.bootpartition"></a>8.4. Extra Boot Partition<span class="permalink"><a alt="Permalink" title="8.4. Extra Boot Partition" href="#sec.vmx.bootpartition">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781527931584"></a><p>
  Depending on the selected root file system and the capabilities of the boot
  loader, KIWI automatically decides whether to set up a separate boot
  partition. The format of a boot partition is set to ext2 by default.
 </p><p>
  To manually control the attributes <code class="sgmltag-attribute">bootpartition</code><a class="indexterm" name="idm139781527928944"></a> (can be set to <code class="sgmltag-attvalue">true</code> or <code class="sgmltag-attvalue">false</code>) and <code class="sgmltag-attribute">bootfilesystem</code><a class="indexterm" name="idm139781527926192"></a> (can be set to <code class="sgmltag-attvalue">ext2</code>, <code class="sgmltag-attvalue">ext3</code>,
  <code class="sgmltag-attvalue">ext4</code>, <code class="sgmltag-attvalue">fat32</code>, or <code class="sgmltag-attvalue">fat16</code>). A runtime check at build time will test
  whether the given configuration can be implemented. The following example
  will create an etx3-formatted boot partition:
 </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type bootpartition="true" bootfilesystem="ext3" .../&gt;
    ...
  &lt;/preferences
  ...
&lt;/image&gt;</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.docker"></a>Chapter 9. Docker images</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.docker.building">9.1. Building Docker Images</a></span></dt><dt><span class="sect1"><a href="#sec.docker.details">9.2. Image Configuration Details</a></span></dt></dl></div><a class="indexterm" name="idm139781527919472"></a><a class="indexterm" name="idm139781527918080"></a><div class="abstract"><p class="title"><b>Abstract</b></p><p>
   Docker is a shipping container system for code that can run virtually
   everywhere. It is an extension of LXC's capabilities. Since
   Docker is based on LXC, a Docker container does not include a separate
   operating system. It relies on the functionality provided by the underlying
   infrastructure. As such, it can package the application and all its
   dependencies in a virtual container which can be run on any Linux server.
  </p><p>
   Docker not only makes it possible to deploy portable containers across
   machines. It also includes versioning capabilities for tracking different
   versions of a container, it allows re-using containers as a base for other
   specialized components, and much more. Find more information about Docker
   on its home page at <a class="ulink" href="http://www.docker.io" target="_top">http://www.docker.io</a>.
  </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Just Enough Operating System (JeOS) Templates</h3><p>
   The package <span class="package">kiwi-templates</span> contains ready-to-use JeOS
   templates. They are installed to <code class="filename">/usr/share/kiwi/image/*-JeOS/</code><a class="indexterm" name="idm139781527910000"></a>. These
   templates can be used without any modification to build images containing
   a minimal operating system. The template directory is in KIWI's search
   path, therefore it is sufficient to only specify the name of the
   <code class="filename">*-JeOS</code> directory on the KIWI command line. Get a list
   of available templates with the following command:
  </p><pre class="screen">(cd /usr/share/kiwi/image/ &amp;&amp; ls -d1 *-JeOS)</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.docker.building"></a>9.1. Building Docker Images<span class="permalink"><a alt="Permalink" title="9.1. Building Docker Images" href="#sec.docker.building">¶</a></span></h2></div></div></div><p>
   The following example shows how to build a Just enough Operating System
   (JeOS) based on SUSE Linux Enterprise 12:
  </p><pre class="screen">kiwi --build suse-SLE12-JeOS --add-profile docker --type docker -d /tmp/my-container</pre><p>
   The image is packed into a TAR archive,
   <code class="filename">/tmp/my-container/LimeJeOS-SLE12-docker.x86_64-1.13.1.tar.xz</code>
   in this example. To use this image with Docker it must be imported via the
   <span class="command"><strong>docker</strong></span> command. The package <span class="package">docker</span>
   needs to be installed and the daemon <code class="systemitem">dockerd</code><a class="indexterm" name="idm139781527902112"></a> needs to run:
  </p><pre class="screen">cat /tmp/my-container/LimeJeOS-SLE12-docker.x86_64-1.13.1.tar.xz |\
docker import - sle12-jeos:new</pre><p>
   When imported, a container instance can be started as follows:
  </p><pre class="screen">docker run --privileged=true -t -i sle12-jeos:new /bin/bash</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Unpacking the TAR archive</h3><p>
    LXC images created by KIWI are packed into a TAR archive and need to be
    unpacked at the root level (<code class="filename">/</code><a class="indexterm" name="idm139781527897312"></a>) of the
    host system. <span class="emphasis"><em>Never do this with a Docker TAR archive</em></span>
    since it would overwrite data on the host system. Always use the
    <span class="command"><strong>docker</strong></span> command as described above to import the image.
   </p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.docker.details"></a>9.2. Image Configuration Details<span class="permalink"><a alt="Permalink" title="9.2. Image Configuration Details" href="#sec.docker.details">¶</a></span></h2></div></div></div><p>
   The configuration for a container does not need to contain a kernel
   package. The container represents the user space that runs on top of the
   kernel of the container host system. However, the container itself must
   include the Linux user space container tools. <em><span class="remark">
   2015-07-29 - fs: Is this a package? What needs to be done to include these
   tools?</span></em>
  </p><p>
   to configure the network for the container use the <code class="sgmltag-element">vmnic</code> in the
   <code class="filename">config.xml</code> file as shown below. The
   <code class="sgmltag-attribute">mode</code><a class="indexterm" name="idm139781527890528"></a> attribute configures the network
   mode, with <span class="emphasis"><em>veth</em></span> being the default.
   <em><span class="remark">
    2015-07-29 - fs: which other modes are valid?
   </span></em>

  </p><p>
   Although it is possible to configure multiple network interfaces in the
   <code class="filename">config.xml</code> file, only the first one is used in the
   container. Prerequisite for a working network in the container is a network
   bridge named <code class="systemitem">br0</code><a class="indexterm" name="idm139781527886512"></a> configured on
   the host system.  For complex network setups is necessary to edit the
   configuration file for the container.
   <em><span class="remark">
    2015-07-29 - fs: How? Unpack TAR archive, edit and tar again?
   </span></em>

  </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    &lt;type ...&gt;
      &lt;machine ...&gt;
        &lt;vmnic interface="0" mode="veth"/&gt;
        ...
      &lt;/machine&gt;
      ...
    &lt;/type&gt;
  &lt;/preferences&gt;
  ...
&lt;/image&gt;</pre><p>
   The generated configuration file restricts the device access of the
   container according to a generally accepted best practice security model.
   The device access permissions may be modified by editing the
   <code class="filename">config</code> file for the container.
  </p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.vagrant"></a>Chapter 10. Vagrant boxes</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.vagrant.building">10.1. Building Vagrant Boxes</a></span></dt></dl></div><a class="indexterm" name="idm139781527881328"></a><a class="indexterm" name="idm139781527880192"></a><a class="indexterm" name="idm139781527879056"></a><div class="abstract"><p class="title"><b>Abstract</b></p><p>
   <a class="ulink" href="http://vagrantup.com/" target="_top">Vagrant</a> is a nice framework to
   implement consistent processing/testing work environments based on
   Virtualization technologies. To run a system, Vagrant needs so-called
   <span class="quote">“<span class="quote">boxes</span>”</span>. A box is a TAR archive containing a virtual disk
   image and some metadata.
  </p><p>
   To build Vagrant boxes, you can use <a class="ulink" href="https://github.com/jedi4ever/veewee" target="_top">veewee</a> which builds boxes
   based on AutoYaST, or <a class="ulink" href="http://packer.io" target="_top">Packer</a>, which
   is provided by Vagrant itself.
  </p><p>
   Both tools are based on the official distribution media (DVDs). If such
   media does not exist (for example if the distribution is still under
   development or you want to use a collection of your own repositories), the
   KIWI way of building images might be helpful. In addition you can use the
   KIWI image description as source for the <a class="ulink" href="http://openbuildservice.org/" target="_top">Open Build Service</a> which then
   allows building and maintaining boxes in the Build Service as a plus.
  </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vagrant.building"></a>10.1. Building Vagrant Boxes<span class="permalink"><a alt="Permalink" title="10.1. Building Vagrant Boxes" href="#sec.vagrant.building">¶</a></span></h2></div></div></div><p>
   The following example shows how to build a Just enough Operating System
   (JeOS) based on SUSE Linux Enterprise 12:
  </p><pre class="screen">kiwi --build suse-SLE12-JeOS --add-profile vagrant --type vmx -d /tmp/my-box</pre><p>
   The build result is written to <code class="filename">/tmp/my-box</code>. The
   <code class="filename">.box</code><a class="indexterm" name="idm139781527868544"></a> and <code class="filename">.json</code><a class="indexterm" name="idm139781527866800"></a> files are needed to add and run the box
   in Vagrant. The <code class="filename">.box</code><a class="indexterm" name="idm139781527864976"></a> file is a TAR
   archive containing the virtual disk image for the selected virtualization
   provider.  In this example it is a qcow2 image to be used with libvirt and
   some metadata which mostly duplicates the information from the '.json' file
   to have it packaged in one place, too.
   <em><span class="remark">
    2015-07-29 - fs: not sure what the last part of the sentence is supposed
    to say... .
   </span></em>
  </p><p>
   The system installed on the virtual disk needs to fulfill some requirements
   which are documented at <a class="ulink" href="http://docs.vagrantup.com/v2/boxes/base.html" target="_top">http://docs.vagrantup.com/v2/boxes/base.html</a>. The KIWI template
   makes sure these requirements are met:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
     installation of mandatory packages: <span class="package">sudo</span>,
     <span class="package">openssh</span> and <span class="package">rsync</span>
    </p></li><li class="listitem"><p>
     users <code class="systemitem">root</code><a class="indexterm" name="idm139781527858288"></a> and <code class="systemitem">vagrant</code><a class="indexterm" name="idm139781527856544"></a> are both configured to use
     <code class="literal">vagrant</code> as password
    </p></li><li class="listitem"><p>
     integration of the Vagrant public SSH key from <a class="ulink" href="https://github.com/mitchellh/vagrant/tree/master/keys" target="_top">https://github.com/mitchellh/vagrant/tree/master/keys</a>
    </p></li><li class="listitem"><p>
     starting <code class="systemitem">sshd</code><a class="indexterm" name="idm139781527852144"></a> daemon at boot time
     with <code class="literal">UseDNS</code> set to <code class="literal">no</code>
    </p></li><li class="listitem"><p>
     sudo configured to allow passwordless root permissions for the
     <code class="systemitem">vagrant</code><a class="indexterm" name="idm139781527848288"></a> user
    </p></li></ul></div><p>
   Using the box requires a correct Vagrant installation on your machine. The
   <code class="systemitem">libvirtd</code><a class="indexterm" name="idm139781527845808"></a> daemon and the libvirt
   default network need to be running.
  </p><p>
   Adding the box to Vagrant can be done in two ways. Either by using the
   <code class="filename">.box</code><a class="indexterm" name="idm139781527843504"></a> file and providing a name at
   the command line:
  </p><pre class="screen">cd /tmp/my-box
vagrant box add my-box LimeJeOS-SLE12.x86_64-1.13.1.libvirt.box</pre><p>
   or by using the <code class="filename">.json</code><a class="indexterm" name="idm139781527840656"></a> file to
   provide metadata such as a version number (similar to the boxes downloaded
   from <a class="ulink" href="https://vagrantcloud.com/" target="_top">https://vagrantcloud.com/</a>):
  </p><pre class="screen">cd /tmp/my-box
vagrant box add LimeJeOS-SLE12.x86_64-1.13.1.libvirt.json</pre><p class="remark"><em><span class="remark">
 2015-07-29 - fs: Are the cd commands really needed? What about
vagrant box add /tmp/my-box/LimeJeOS-SLE12.x86_64-1.13.1.libvirt.json ?
</span></em></p><p>
   With either method, you can now boot the box and log in:
  </p><pre class="screen"><code class="prompt">root # </code>cd /tmp/my-box
<code class="prompt">root # </code>vagrant init my-box
<code class="prompt">root # </code>vagrant up --provider libvirt
<code class="prompt">root # </code>vagrant ssh
 This is the Lime-JeOS SLE12 Linux System...
 vagrant@linux:~&gt;</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Vagrant with Docker</h3><p>
    Building boxes for the libvirt, VMware or VirtualBox providers requires to
    build images with the disk format required by the provider. A Docker based
    box, however, has no such requirements. Therefore building a Docker based
    box for Vagrant in KIWI does not differ from building a regular Docker
    image as described in <a class="xref" href="#chap.docker" title="Chapter 9. Docker images">Chapter 9, <i>Docker images</i></a>.
   </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.pxe"></a>Chapter 11. PXE Image / Thin Clients</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.pxe.building">11.1. Building PXE Images</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.files">11.2. PXE Configuration Files</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.client-config-file">11.3. The PXE Client Configuration File Syntax</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.another-user">11.3.1. Use a Different Download Protocol</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.ram-only-image">11.3.2. RAM Only Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.union-image">11.3.3. Union Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.split-image">11.3.4. Split Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.remote-root">11.3.5. Mounting the Root File System from a Remote Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.groups">11.4. Hardware Grouping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.groups.def_file">11.4.1. The Group Definition File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.groups.group_file">11.4.2. The Group Configuration File</a></span></dt></dl></dd></dl></div><a class="indexterm" name="idm139781527830784"></a><a class="indexterm" name="idm139781527829648"></a><a class="indexterm" name="idm139781527828512"></a><a class="indexterm" name="idm139781527827760"></a><div class="abstract"><p class="title"><b>Abstract</b></p><p>
   PXE is a network boot protocol that is shipped with most BIOS
   implementations. The protocol sends a DHCP request to get an IP
   address. When an IP address is assigned, it uses the TFTP protocol to
   download a Kernel and boot instructions. Contrary to other images built
   with KIWI, a PXE image consists of separate boot and system images, since
   both images need to be made available in different locations on the network
   boot server.
  </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">PXE Image Description Templates</h3><p>
   KIWI comes with many image description templates. It is
   recommended to use them as a basis for your own image descriptions. To do
   so, copy the respective directory containing the image description of your
   choice to you working directory and adjust it according to your needs.
  </p><p>
   PXE image templates are shipped with the package
   <span class="package">kiwi-desc-netboot</span>. They are installed to
   <code class="filename">/usr/share/kiwi/image/netboot</code>.
  </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Just Enough Operating System (JeOS) Templates</h3><p>
   The package <span class="package">kiwi-templates</span> contains ready-to-use JeOS
   templates. They are installed to <code class="filename">/usr/share/kiwi/image/*-JeOS/</code><a class="indexterm" name="idm139781527820624"></a>. These
   templates can be used without any modification to build images containing
   a minimal operating system. The template directory is in KIWI's search
   path, therefore it is sufficient to only specify the name of the
   <code class="filename">*-JeOS</code> directory on the KIWI command line. Get a list
   of available templates with the following command:
  </p><pre class="screen">(cd /usr/share/kiwi/image/ &amp;&amp; ls -d1 *-JeOS)</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.building"></a>11.1. Building PXE Images<span class="permalink"><a alt="Permalink" title="11.1. Building PXE Images" href="#sec.pxe.building">¶</a></span></h2></div></div></div><p>
   The following example shows how to build a Just enough Operating
   System (JeOS) based on SUSE Linux Enterprise 12:
  </p><pre class="screen">kiwi --build suse-SLE12-community-JeOS --add-profile netboot --type pxe -d /tmp/mypxe-result</pre><p>
   This command generates a compressed root file system image which is deployed
   as an overlayfs-based union system. To use the image, all image parts need
   to be copied to a PXE boot server. If you have not set up such a server,
   refer to <a class="xref" href="#app.bootserver" title="Appendix B. Setting Up a Network Boot Server">Appendix B, <i>Setting Up a Network Boot Server</i></a> for instructions. The following
   example assumes you have created the PXE image on the boot server itself
   (if not, use <span class="command"><strong>scp</strong></span> to copy the files on the remote host).
  </p><div class="procedure"><a name="proc.pxe.using"></a><ol class="procedure" type="1"><li class="step"><p>
     Change into the build directory:
    </p><pre class="screen">cd /tmp/mypxe-result</pre></li><li class="step"><p>
     Copy the initrd and the kernel to
     <code class="filename">/srv/tftpboot/boot/initrd</code><a class="indexterm" name="idm139781527810000"></a>:
    </p><pre class="screen">cp initrd-netboot-suse-SLES12.x86_64-2.1.1.gz /srv/tftpboot/boot/initrd
cp initrd-netboot-suse-SLES12.x86_64-2.1.1.kernel /srv/tftpboot/boot/linux</pre></li><li class="step"><p>
     Copy the system image and its md5 sum to <code class="filename">/srv/tftpboot/image</code><a class="indexterm" name="idm139781527806464"></a>:
    </p><pre class="screen">cp LimeJeOS-SLE12-Community.x86_64-1.13.1 /srv/tftpboot/image
cp LimeJeOS-SLE12-Community.x86_64-1.13.1.md5 /srv/tftpboot/image</pre></li><li class="step"><p>
     Copy the image boot configuration to <code class="filename">/srv/tftpboot/KIWI/config.default</code><a class="indexterm" name="idm139781527802944"></a>. See
     <a class="xref" href="#sec.pxe.files" title="11.2. PXE Configuration Files">Section 11.2, “PXE Configuration Files”</a> for details.
    </p><pre class="screen">cp LimeJeOS-SLE12-Community.x86_64-1.13.1.config \
 /srv/tftpboot/KIWI/config.default</pre></li><li class="step"><p>
     Adjust the PXE configuration file. it controls which kernel and initrd is
     loaded and which kernel parameters are set. A template has been installed
     at <code class="filename">/srv/tftpboot/pxelinux.cfg/default</code> with the
     <span class="package">kiwi-pxeboot</span> package. The minimal configuration
     required to boot the SLE 12 JeOS looks like to following:
    </p><pre class="screen">DEFAULT KIWI-Boot

LABEL KIWI-Boot
    kernel boot/linux
    append initrd=boot/initrd
    IPAPPEND 1

LABEL Local-Boot
    localboot 0</pre><em><span class="remark">
     2015-07-31 - fs: The content above differs from what is installed with
     kiwi-pxeboot.
    </span></em></li><li class="step"><p>
     Connect the client to the network and boot it.
    </p></li></ol></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.files"></a>11.2. PXE Configuration Files<span class="permalink"><a alt="Permalink" title="11.2. PXE Configuration Files" href="#sec.pxe.files">¶</a></span></h2></div></div></div><p>
   <em><span class="remark">
    2015-12-02 - fs: Removed everything concerning hwtype.MAC, since it did
    not seem relevant
   </span></em>
   All PXE boot based deployment methods are controlled by configuration files
   located in <code class="filename">/srv/tftpboot/KIWI</code><a class="indexterm" name="idm139781527792592"></a> on the
   PXE server. Such a configuration file can either be client-specific
   (<code class="filename">config.<em class="replaceable"><code>MAC_ADDRESS</code></em></code>, for
   example <code class="filename">config.00.AB.F3.11.73.C8</code>),
   group-specific
   (<code class="filename">config.<em class="replaceable"><code>GROUP</code></em></code>, see <a class="xref" href="#sec.pxe.groups" title="11.4. Hardware Grouping">Section 11.4, “Hardware Grouping”</a> for details) or generic
   (<code class="filename">config.default</code>).  In an environment with
   heterogeneous clients, this allows to have a default configuration suitable
   for the majority of clients, to have configurations suitable for a group of
   clients (for example machines with similar or identical hardware) and
   individual configurations for selected machines.
  </p><p>
   Configuration files are assigned to a client in the following order, the
   first matching file is used:
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
     <code class="filename">config.<em class="replaceable"><code>MAC_ADDRESS</code></em></code>
    </p></li><li class="listitem"><p>
     <code class="filename">config.<em class="replaceable"><code>GROUP</code></em></code>
    </p></li><li class="listitem"><p>
     <code class="filename">config.default</code>
    </p></li></ol></div><p>
   When building the OEM image a template configuration file named
   <code class="filename"><em class="replaceable"><code>IMAGE_NAME.config</code></em></code> (for
   example <code class="filename">LimeJeOS-SLE12.x86_64-1.13.1.config</code>) is
   generated. Copy this file to
   <code class="filename">/srv/tftpboot/KIWI/config.default</code> on the PXE
   server and adjust it according to your needs. If you need client- or
   group-specific configuration files, use the final version of
   <code class="filename">config.default</code> as a template.
  </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.client-config-file"></a>11.3. The PXE Client Configuration File Syntax<span class="permalink"><a alt="Permalink" title="11.3. The PXE Client Configuration File Syntax" href="#sec.pxe.client-config-file">¶</a></span></h2></div></div></div><p>
    The configuration file contains data about the image and about
    configuration, synchronization, and partition parameters.
    The configuration file has got the following general format:
   </p><pre class="screen">AOEROOT=device
COMBINED_IMAGE=1
CONF="src;dest;srvip;bsize;[hash],...,src;dest;srvip;bsize;[hash]"
DISK="device"
FORCE_KEXEC=1
IMAGE="device;name;version;srvip;bsize;compressed,...,"
KIWI_BOOT_TIMEOUT="seconds"
KIWI_INITRD="path-to-initrd"
KIWI_KERNEL="path-to-kernel"
KIWI_KERNEL_OPTIONS="opt1 opt2 ..."
NBDROOTNBDROOT="ip-address;export-name;device;swap-export-name;swap-device;write-export-name;write-device"
NFSROOT="ip-address;path"
PART="size;id;Mount,...,size;id;Mount"
RAID="raid-level;device1;device2;..."
REBOOT_IMAGE=1
RELOAD_CONFIG=1
RELOAD_IMAGE=1
UNIONFS_CONFIGURATION="rw-partition,compressed-partition,container-fs"</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Quoting the Values</h3><p>
     <code class="filename">config.<em class="replaceable"><code>MAC_ADDRESS</code></em></code>
     is sourced by the Bash, so the same quoting rules as for the Bash apply.
    </p></div><p>
    Not all configuration options need to be specified. The following
    configuration is an example for an image based on a read-write file system
    stored on a local disk:
   </p><pre class="screen">DISK="/dev/sda"
PART="5;S;x,x;L;/"
IMAGE="/dev/sda2;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096"</pre><p>
    Refer to the following list for details on each configuration option:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">AOEROOT</code></span></dt><dd><p>
       Mount the system image root file system remotely via AoE (ATA over
       Ethernet). This requires a server exporting a block device
       representing the root directory of the system image via the AoE
       subsystem. The block device could be a partition of a real or a
       virtual disk. To use the AoE subsystem it is recommended to
       install the <span class="package">aoetools</span> and <span class="package">vblade</span>
       packages from <a class="ulink" href="http://download.opensuse.org/repositories/server:/ltsp" target="_top">http://download.opensuse.org/repositories/server:/ltsp</a>.
      </p><p>
       When these packages are installed, partitions can be exported with the
       <span class="command"><strong>vbladed</strong></span> command. The following example shows how to
       export <code class="filename">/dev/sdb1</code><a class="indexterm" name="idm139781527765424"></a> via AoE with a
       major value of 0 and minor of 1 on the eth0 interface.:
      </p><pre class="screen"><span class="command"><strong>vbladed</strong></span> 0 1 eth0 /dev/sdb1</pre><p>
       To be able to use the device KIWI needs the information which AoE
       device contains the root file system. In this example this is the device
       <code class="filename">/dev/etherd/e0.1</code><a class="indexterm" name="idm139781527761904"></a>:
      </p><pre class="screen">AOEROOT=/dev/etherd/e0.1</pre><p>
       In case of a compressed read-only image with <code class="systemitem">overlayfs</code><a class="indexterm" name="idm139781527759152"></a>, the
       <code class="varname">AOEROOT</code> variable can also contain a second device
       for the write actions:
      </p><pre class="screen">AOEROOT=/dev/etherd/e0.1,/dev/ram1</pre><p>
       Writing to RAM as in the example above, is the default. You also can
       specify another AoE location or a local device for writing the data.
      </p></dd><dt><span class="term"><code class="varname">COMBINED_IMAGE</code></span></dt><dd><p>
       If set to a non-empty string, indicates that the boot and the system
       image need to be combined into a single bootable image. The first image
       defines the read-write part and the second image defines the read-only
       part.
      </p></dd><dt><span class="term"><code class="varname">CONF</code>, <code class="varname">VENDOR_CONF</code></span></dt><dd><p>
       Specifies a comma-separated list of source:target configuration file
       names. The <code class="literal">source</code> corresponds to the path on the
       TFTP server. It is downloaded to <code class="literal">target</code> on the
       client. The download is only done when the file is missing on the
       client or has a different md5-sum (in case the md5sum hash is supplied
       with <code class="literal">hash</code>).
      </p><p>
       To achieve this, a list of <code class="varname">CONF</code> files (and
       <code class="varname">VENDOR_CONF</code>) files that generated by KIWI and stored
       on the client (<code class="filename">/etc/KIWI/InstalledConfigFiles</code>) is
       compared to the <code class="varname">CONF</code> data gathered from the
       configuration file (for example <code class="filename">config.default</code>),
       if supplied.
      </p><p>
       Configuration files selected for comparison are those with same
       destination path (dest). If the destination path is same for more than
       one configuration file, only the last one is used (and
       <code class="varname">VENDOR_CONF</code> always take s precedence over
       <code class="varname">CONF</code>). By comparing configuration file lists present
       in the current <code class="varname">CONF</code> and
       <code class="varname">VENDOR_CONF</code> variables and with the local list, the
       following actions can result:
      </p><div class="table"><a name="tab.configuration.files.synchronization"></a><p class="title"><b>Table 11.1. Configuration Files Synchronization Possibilities</b><span class="permalink"><a alt="Permalink" title="Table 11.1. Configuration Files Synchronization Possibilities" href="#tab.configuration.files.synchronization">¶</a></span></p><div class="table-contents"><table summary="Configuration Files Synchronization Possibilities" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>
            File from <code class="varname">CONF</code>, <code class="varname">VENDOR_CONF</code>
           </th><th>
            <code class="filename">InstalledConfigFiles</code>
           </th><th>Action</th></tr></thead><tbody><tr><td>hash_a</td><td>hash_a</td><td>nothing, keep</td></tr><tr><td>hash_a</td><td>hash_b</td><td>download from server</td></tr><tr><td>none</td><td>hash</td><td>download from server</td></tr><tr><td>hash</td><td>none</td><td>download from server</td></tr><tr><td>none</td><td>none</td><td>nothing, keep</td></tr><tr><td>present</td><td>not present</td><td>download from server (regardless of hash)</td></tr><tr><td>not present</td><td>present</td><td>delete on client (regardless hash)</td></tr></tbody></table></div></div><br class="table-break"><p>
       Note that actual configuration files (or their md5sum hashes) on the
       client machine are not tested—only data from the list file
       <code class="filename">/etc/KIWI/InstalledConfigFiles</code> is used to
       determine which files need to be synchronized. This means that actual
       configuration files can be altered or even be deleted without
       triggering any action. On the other hand, if the list file is changed
       or deleted, an action could be triggered although the actual
       configuration files have not changed.
     </p></dd><dt><span class="term"><code class="varname">DISK</code></span></dt><dd><p>
       Specifies the storage device. Only to be used together with
       <code class="varname">PART</code>, for example:
      </p><pre class="screen">DISK=/dev/hda</pre></dd><dt><span class="term"><code class="varname">FORCE_KEXEC</code>
     </span></dt><dd><p>
       During the initial deployment process KIWI checks if the running Kernel
       is the same as the Kernel installed via the system image. If there is a
       mismatch, KIWI activates the installed kernel by calling
       <span class="command"><strong>kexec</strong></span>. Kexec is a tool to boot to another kernel
       from the currently running one. The system boots faster, because the
       hardware initialization phase and the boot loader are skipped..
      </p><p>
       If <code class="varname">FORCE_KEXEC</code> is set to a non-empty string kiwi
       will also perform kexec if the Kernel versions matches.
      </p></dd><dt><span class="term"><code class="varname">IMAGE</code>
     </span></dt><dd><p>
       Specifies the image to be downloaded and the device for the root file
       system.
      </p><pre class="screen">IMAGE='<em class="replaceable"><code>device</code></em>;<em class="replaceable"><code>name</code></em>;<em class="replaceable"><code>version</code></em>;<em class="replaceable"><code>srvip</code></em>;<em class="replaceable"><code>bsize</code></em>;compressed'</pre><p>
       The following parameters are supported:
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">device</code></span></dt><dd><p class="remark"><em><span class="remark">
          2015-11-24 - fs: Please check whether the following is correct
         </span></em></p><p>
          The device the root file system should be installed on. Can either
          be a RAM disk (for example <code class="filename">/dev/ram1</code><a class="indexterm" name="idm139781527709984"></a> or a block device (for
          example <code class="filename">/dev/hda2</code><a class="indexterm" name="idm139781527708240"></a>).
         </p><p>
          When using a RAM disk, note that you cannot use <code class="filename">/dev/ram0</code><a class="indexterm" name="idm139781527706032"></a>, since it is already
          reserved for the initial RAM disk set up by the installation
          system. Use <code class="filename">/dev/ram1</code><a class="indexterm" name="idm139781527704160"></a>
          instead.
         </p><p>
          When using a block device, always make sure to also create a
          corresponding <code class="envar">PART</code><a class="indexterm" name="idm139781527702400"></a> entry defining the
          partitioning. Note that a partitioning scheme defined with
          <code class="envar">PART</code><a class="indexterm" name="idm139781527701024"></a> always defines the first partition as swap and
          the second partition as the root file system. Therefore
          <code class="literal">device</code> needs to point to the second partition
          (for example <code class="filename">/dev/hda2</code><a class="indexterm" name="idm139781527698432"></a>).
         </p></dd><dt><span class="term"><code class="literal">name</code></span></dt><dd><p class="remark"><em><span class="remark">
          2015-11-24 - fs: Is "##.#" used as a wild card for the version string?
         </span></em></p><p>
          File name of the image. Use the character <span class="quote">“<span class="quote">#</span>”</span> as a wild
          card for the version number, for example
          <code class="literal">LimeJeOS-SLE12-Community.x86_64-#.##.#</code>.
         </p></dd><dt><span class="term"><code class="literal">version</code></span></dt><dd><p>
          Version string, for example <code class="literal">1.13.1</code>.
         </p></dd><dt><span class="term"><code class="literal">srvip</code></span></dt><dd><p>
          Specifies the server IP address for the TFTP download. Must always
          be indicated, except in <code class="varname">PART</code>.
         </p></dd><dt><span class="term"><code class="literal">bsize</code></span></dt><dd><p>
          Specifies the block size for the TFTP download. Must always be
          indicated, except in <code class="varname">PART</code>. If the block size is
          too small according to the maximum number of data packages (32768),
          linuxrc will automatically calculate a new block size for the
          download.
         </p></dd><dt><span class="term"><code class="literal">compressed</code></span></dt><dd><p>
          Specifies if the image file on the TFTP server is compressed and
          handles it accordingly. To specify a compressed image download only
          the keyword <code class="literal">compressed</code> needs to be added. If
          compressed is not specified the standard download workflow is used.
         </p><p>
          The name of the compressed image needs to contain the suffix <code class="filename">.gz</code><a class="indexterm" name="idm139781527682032"></a> and the image needs to be
          compressed with the <span class="command"><strong>gzip</strong></span> tool.  Using a
          compressed image will automatically <span class="emphasis"><em>deactivate</em></span>
          the multicast download option of atftp.
         </p><pre class="screen">IMAGE='/dev/sda2;suse.i686.gz;1.2.8;192.168.100.2;4096;compressed'</pre><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"></h3><p>
           The download will fail if you specify <code class="literal">compressed</code>
           and the image is not compressed. It will also fail if you don’t
           specify <code class="literal">compressed</code> but the image is compressed.
          </p></div></dd></dl></div></dd><dt><span class="term"><code class="varname">KIWI_BOOT_TIMEOUT</code>
     </span></dt><dd><p>
       Specifies the number of seconds to wait at the boot loader screen when
       doing a local boot before booting the default boot entry. The default
       is 10.
      </p></dd><dt><span class="term"><code class="varname">KIWI_INITRD</code>
     </span></dt><dd><p>
       Specifies the KIWI initrd to be used for a local boot of the system.
       The value must be set to the name of the initrd file which is used via
       PXE network boot. If the standard TFTP setup suggested with the
       kiwi-pxeboot package is used all initrd files reside in <code class="filename">/var/lib/tftpboot/boot/</code><a class="indexterm" name="idm139781527671392"></a>. However, because
       the TFTP server does a change root (<span class="command"><strong>chroot
       /var/lib/tftpboot</strong></span>) you need to specify the initrd file as in
       the following example:
      </p><pre class="screen">KIWI_INITRD=/boot/<em class="replaceable"><code>name-of-initrd-file</code></em></pre></dd><dt><span class="term"><code class="varname">KIWI_KERNEL</code>
     </span></dt><dd><p>
       Specifies the Kernel to be used for a local boot of the system The
       same path rules as described for <code class="varname">KIWI_INITRD</code>
       apply for the kernel setup:
      </p><pre class="screen">KIWI_KERNEL=/boot/<em class="replaceable"><code>name-of-kernel-file</code></em></pre></dd><dt><span class="term"><code class="varname">KIWI_KERNEL_OPTIONS</code>
     </span></dt><dd><p>
       Specifies additional command line options to be passed to the Kernel
       when booting from disk. For instance, to enable a splash screen, you
       might use
      </p><pre class="screen">KIWI_KERNEL_OPTIONS="vga=0x317 splash=silent"</pre></dd><dt><span class="term"><code class="varname">NBDROOT</code>
     </span></dt><dd><p>
       Mount the system image root file system remotely via NBD (Network Block
       Device). This requires a server which exports the root directory
       of the system image via a specified export name. The Kernel provides
       the block layer, together with a remote port that uses the nbd-server
       program. For more information on how to set up the server, see
       <span class="command"><strong>man 1 nbd-server</strong></span>. The Kernel on the remote client
       can set up a special network block device named <code class="filename">/dev/nb0</code><a class="indexterm" name="idm139781527659248"></a> using the nbd-client
       command. After this device exists, the mount program is used to mount
       the root file system. To allow the KIWI boot image to use that, the
       following information must be provided:
      </p><pre class="screen">NBDROOT=<em class="replaceable"><code>NBD.Server.IP.address;</code></em>\
<em class="replaceable"><code>NBD-Export-Name</code></em>;/dev/<em class="replaceable"><code>NBD-Device</code></em>;\
<em class="replaceable"><code>NBD-Swap-Export-Name</code></em>;/dev/<em class="replaceable"><code>NBD-Swap-Device</code></em>;\
<em class="replaceable"><code>NBD-Write-Export-Name</code></em>;/dev/<em class="replaceable"><code>NBD-Write-Device</code></em></pre><p>
       The server IP and the export name are mandatory parameters, all other
       parameters are optional. The default device names are:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
         NBD-Device: <code class="filename">/dev/nbd0</code><a class="indexterm" name="idm139781527652640"></a>,
        </p></li><li class="listitem"><p>
         NBD-Swap-Device: <code class="filename">/dev/nbd1</code><a class="indexterm" name="idm139781527650128"></a>
        </p></li><li class="listitem"><p>
         NBD-Write-Device: <code class="filename">/dev/ram1</code><a class="indexterm" name="idm139781527647616"></a>
        </p></li></ul></div><p>
       Defining a swap device is optional. It is only set up if the client
       has less than 48 MB of RAM. The optional NBD-Write-Export-Name and
       NBD-Write-Device define a write copy-on-write (COW) location for the
       root file system. A separate write device is only used together with a
       union setup based on, for example, overlayfs.
      </p></dd><dt><span class="term"><code class="varname">NFSROOT</code>
     </span></dt><dd><p>
       Mount the system image root file system remotely via NFS (Network File
       System). This requires a server which exports the root file system of
       the network client in such a way that the client can mount it
       read/write. To do that, the boot image must know the server IP
       address and the path name where the root directory exists on this
       server. The information must be provided like follows:
      </p><pre class="screen">NFSROOT=<em class="replaceable"><code>NFS.Server.IP.address</code></em>;<em class="replaceable"><code>/path/to/root/tree</code></em></pre></dd><dt><span class="term"><code class="varname">PART</code>
     </span></dt><dd><p>
       Specifies the partitioning data. Comma-separated blocks contain size,
       partition type and mount point:
      </p><pre class="screen">PART='<em class="replaceable"><code>size</code></em>;<em class="replaceable"><code>type</code></em>;<em class="replaceable"><code>mountpoint</code></em>,...,<em class="replaceable"><code>size</code></em>;<em class="replaceable"><code>type</code></em>;<em class="replaceable"><code>mountpoint</code></em>'</pre><p>
       In addition, the following rules apply:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
         <em class="replaceable"><code>size</code></em> is measured in megabytes (MB).
        </p></li><li class="listitem"><p>
         <em class="replaceable"><code>type</code></em> can be one of the following values:
        </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
          <code class="literal">S</code> or <code class="literal">82</code>: swap partition
         </td></tr><tr><td>
          <code class="literal">L</code> or <code class="literal">83</code>: linux partition
         </td></tr><tr><td>
          <code class="literal">V</code> or <code class="literal">8e</code>: LVM partition
         </td></tr><tr><td><code class="literal">fd</code>: RAID partition</td></tr><tr><td><code class="literal">41</code>: prep-partition for IBM POWER</td></tr></table></li><li class="listitem"><p>
         The first element of the list must define the swap partition.
        </p><p>
         The swap partition must not contain a mount point. A lowercase
         letter <code class="literal">x</code> needs to be set instead.
        </p></li><li class="listitem"><p>
         The second element of the list must define the root partition.
        </p></li><li class="listitem"><p>
         If a partition should take all the space left on a disk one can set
         a lower <code class="literal">x</code> letter as size specification.
        </p></li></ul></div><p>
       The following example defines a 2 GB swap partition
       (<code class="literal">2000;S;x</code>) and a root partition occupying the
       remaining space on the disk (<code class="literal">x;L;/</code>):
      </p><pre class="screen">PART='2000;S;x,x;L;/'</pre></dd><dt><span class="term"><code class="varname">RAID</code>
     </span></dt><dd><p>
       In addition to the <code class="varname">PART</code> line it is also allowed to
       add a raid array setup. The first parameter of the
       <code class="varname">RAID</code> line is the raid level. So far only raid1
       (mirroring) is supported. The second and third parameter specifies the
       raid disk devices which make up the array. If a RAID line is present
       all partitions in PART will be created as raid partitions. The first
       raid is named md0 the second one md1 and so on.  It is required to
       specify the correct raid partition in the IMAGE line according to the
       PART setup. A typical raid image setup could look like this:
      </p><pre class="screen">DISK=/dev/sda
RAID='1;/dev/sda;/dev/sdb'
IMAGE='/dev/md1;LimeJeOS-openSUSE-##.#.i686;1.11.3;192.168.100.2;4096'
PART='5;S;x,2000;L;/'</pre></dd><dt><span class="term"><code class="varname">REBOOT_IMAGE</code></span></dt><dd><p>
       If set to a non-empty string, this will reboot the system after the
       initial deployment process is done. This means the system is rebooted
       before the system init process is activated. If the machine's default
       boot setup is to boot via PXE it will again boot from the network.
      </p></dd><dt><span class="term"><code class="varname">RELOAD_CONFIG</code>
     </span></dt><dd><p>
       If set to a non-empty string, this forces all configuration files to be
       loaded from the server. The primary purpose of this setting is to aid
       debugging. The option only applies to disk-based systems.
      </p></dd><dt><span class="term"><code class="varname">RELOAD_IMAGE</code>
     </span></dt><dd><p>
       If set to a non-empty string, this forces the image to be loaded from
       the server even if the image on the disk is up-to-date.  The primary
       purpose of this setting is to aid debugging. The option only applies
       to disk-based systems.
      </p></dd><dt><a name="var.pxe.client-config-file.unionfs"></a><span class="term"><code class="varname">UNIONFS_CONFIG</code>
     </span></dt><dd><p>
       Netboot images may use overlayfs as a
       container file system in combination with a compressed system image.
       The recommended compressed file system type for the system image is
       <span class="bold"><strong>overlayfs</strong></span>.
      </p><pre class="screen">UNIONFS_CONFIG=/dev/sda2,/dev/sda3,overlayfs</pre><p>
       In this example the first device <code class="filename">/dev/sda2</code><a class="indexterm" name="idm139781527605408"></a> represents the read/write
       file system and the second device <code class="filename">/dev/sda3</code><a class="indexterm" name="idm139781527603584"></a> represents the compressed
       system image file system.
      </p><p>
       The union file system overlayfs is then used to cover the read/write
       layer with the read-only device to one read/write file system. If a
       file on the read-only device is going to be written, the changed inodes
       are part of the read/write file system. Note the device specifications
       in <code class="varname">UNIONFS_CONFIG</code> must correspond to the
       <code class="varname">IMAGE</code> and <code class="varname">PART</code> information. The
       following example should explain the interconnections:
      </p><pre class="screen">DISK=/dev/sda
IMAGE='/dev/sda3;image/myImage;1.1.1;192.168.1.1;4096'
PART='200;S;x,300;L;/,x;L;x'
UNIONFS_CONFIG=/dev/sda2,/dev/sda3,overlayfs</pre><p>
       As the second element of the PART list must define the root partition
       it is absolutely important that the first device in
       <code class="varname">UNIONFS_CONFIG</code> matches this device as read/write
       device. The second device of <code class="varname">UNIONFS_CONFIG</code> needs to
       match the given IMAGE device name.
      </p></dd></dl></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.another-user"></a>11.3.1. Use a Different Download Protocol<span class="permalink"><a alt="Permalink" title="11.3.1. Use a Different Download Protocol" href="#sec.pxe.another-user">¶</a></span></h3></div></div></div><p>
     By default all downloads controlled by the KIWI linuxrc code are
     performed by an atftp call using the TFTP protocol. With PXE the download
     protocol is fixed and thus you cannott change the way how the kernel and
     the boot image (initrd) is downloaded. As soon as Linux takes over, the
     download protocols HTTP, HTTPS and FTP are supported too. KIWI uses of
     the <span class="command"><strong>curl</strong></span> program to support the additional protocols.
    </p><p>
     To select one of the additional download protocols the following
     kernel parameters need to be specified ion
     <code class="filename">/srv/tftpboot/pxelinux.cfg/default</code>:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">kiwiserver</code></span></dt><dd><p>
        Name or IP address of the server who implements the protocol
       </p></dd><dt><span class="term"><code class="literal">kiwiservertype</code></span></dt><dd><p>
        Name of the download protocol which could be one of
        <code class="literal">http</code>, <code class="literal">https</code> or
        <code class="literal">ftp</code>
       </p></dd></dl></div><p>
     To set up this parameters edit the file
     <code class="filename">/srv/tftpboot/pxelinux.cfg/default</code> on your PXE boot
     server and change the append line accordingly. Note that all downloads
     except for kernel and initrd are now controlled by the given server and
     protocol. You need to make sure that this server provides the same
     directory and file structure as initially provided by the
     <span class="package">kiwi-pxeboot</span> package.
    </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.ram-only-image"></a>11.3.2. RAM Only Image<span class="permalink"><a alt="Permalink" title="11.3.2. RAM Only Image" href="#sec.pxe.ram-only-image">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781527585488"></a><p>
     If there is no local or remote storage for mounting the root file system,
     the image can be stored into the main memory of the client. The machine
     needs to be equipped with sufficient memory to host the RAM disk and
     provide enough additional memory for system operation. Set up the machine
     similar to the following example:
    </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
       Use a read-write file system in <code class="filename">config.xml</code>, for
       example <code class="literal">filesystem="ext3"</code>
      </p></li><li class="step"><p>
       Create <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>
      </p><pre class="screen">IMAGE='/dev/ram1;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096'</pre></li></ol></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.union-image"></a>11.3.3. Union Image<span class="permalink"><a alt="Permalink" title="11.3.3. Union Image" href="#sec.pxe.union-image">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781527577360"></a><p>
     As shown in <a class="xref" href="#var.pxe.client-config-file.unionfs"><code class="varname">UNIONFS_CONFIG</code>
     </a> it is
     possible to use the union file system with overlayfs, to combine
     two file systems into one. In case of thin clients there is often the
     need for a compressed file system because of space limitations. However,
     all supported compressed file systems only allow read-only
     access. Combining a read-only file system with a read-write file system
     is a solution for this problem.  KIWI uses squashfs compressing file
     systems. To create an image with a compressed root file system, make sure
     the file system attribute in <code class="filename">config.xml</code> contains
     <code class="systemitem">squashfs</code><a class="indexterm" name="idm139781527573408"></a>.
     <em><span class="remark">
      2015-11-25 - fs: where should this attribute be set? A link to an
      example or an example right here is needed.
     </span></em>
    </p><p>
     When an image contains a compressed root file system, it can either be
     downloaded to the local machine or be mounted remotely. The following
     setups can be configured:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
       
       <a class="xref" href="#ex.pxe.union.local.local" title="Example 11.1.  Download Compressed Image to Local Storage, Write to Local Storage">Example 11.1, “
      Download Compressed Image to Local Storage, Write to Local Storage
     ”</a>
      </p></li><li class="listitem"><p>
       
       <a class="xref" href="#ex.pxe.union.local.ram" title="Example 11.2.  Download Compressed Image to Local Storage, Write to RAM">Example 11.2, “
      Download Compressed Image to Local Storage, Write to RAM
     ”</a>
      </p></li><li class="listitem"><p>
       
       <a class="xref" href="#ex.pxe.union.remote.local" title="Example 11.3.  Mount Compressed Image from Remote, Write to Local Storage">Example 11.3, “
      Mount Compressed Image from Remote, Write to Local Storage
     ”</a>
      </p></li><li class="listitem"><p>
       
       <a class="xref" href="#ex.pxe.union.remote.ram" title="Example 11.4.  Mount Compressed Image from Remote, Write to RAM">Example 11.4, “
      Mount Compressed Image from Remote, Write to RAM
     ”</a>
      </p></li><li class="listitem"><p>
       
       <a class="xref" href="#ex.pxe.union.remote.remote" title="Example 11.5.  Mount Compressed Image from Remote, Write to Remote">Example 11.5, “
      Mount Compressed Image from Remote, Write to Remote
     ”</a>
      </p></li></ul></div><div class="example"><a name="ex.pxe.union.local.local"></a><p class="title"><b>Example 11.1. 
      Download Compressed Image to Local Storage, Write to Local Storage
     </b><span class="permalink"><a alt="Permalink" title="Example 11.1. 
      Download Compressed Image to Local Storage, Write to Local Storage
     " href="#ex.pxe.union.local.local">¶</a></span></p><div class="example-contents"><a class="indexterm" name="idm139781527561632"></a><pre class="screen">DISK=/dev/sda
PART='5;S;x,400;L;/,x;L;x'
IMAGE='/dev/sda2;suse-##.#-pxe-client.i386;1.2.8;192.168.100.2;4096'
UNIONFS_CONFIG=/dev/sda3,/dev/sda2,overlayfs
KIWI_INITRD=/boot/initrd</pre></div></div><br class="example-break"><div class="example"><a name="ex.pxe.union.local.ram"></a><p class="title"><b>Example 11.2. 
      Download Compressed Image to Local Storage, Write to RAM
     </b><span class="permalink"><a alt="Permalink" title="Example 11.2. 
      Download Compressed Image to Local Storage, Write to RAM
     " href="#ex.pxe.union.local.ram">¶</a></span></p><div class="example-contents"><a class="indexterm" name="idm139781527558416"></a><pre class="screen">DISK=/dev/sda
PART='5;S;x,400;L;/'
IMAGE='/dev/sda2;suse-##.#-pxe-client.i386;1.2.8;192.168.100.2;4096'
UNIONFS_CONFIG=tmpfs,/dev/sda2,overlayfs</pre></div></div><br class="example-break"><div class="example"><a name="ex.pxe.union.remote.local"></a><p class="title"><b>Example 11.3. 
      Mount Compressed Image from Remote, Write to Local Storage
     </b><span class="permalink"><a alt="Permalink" title="Example 11.3. 
      Mount Compressed Image from Remote, Write to Local Storage
     " href="#ex.pxe.union.remote.local">¶</a></span></p><div class="example-contents"><a class="indexterm" name="idm139781527555280"></a><p>
      Depending on whether the remote image is served via AoE, NBD, or NFS, the
      configuration differs:
     </p><p>
      <span class="bold"><strong>AoE</strong></span>
     </p><pre class="screen">PART='5;S;x,x;L;x'
AOEROOT=/dev/etherd/e0.1,/dev/sda2
UNIONFS_CONFIG=/dev/sda2,aoe,overlayfs</pre><p>
      <span class="bold"><strong>NBD</strong></span>
     </p><pre class="screen">PART='5;S;x,x;L;x'
NBDROOT=192.168.100.7;root1;/dev/nbd0;;;;/dev/sda2
UNIONFS_CONFIG=/dev/sda2,nbd,overlayfs</pre><p>
      <span class="bold"><strong>NFS</strong></span>
     </p><pre class="screen">PART='5;S;x,x;L;x'
NFSROOT="192.168.100.2;/srv/kiwi-read-only-path"
UNIONFS_CONFIG=/dev/sda2,nfs,overlayfs</pre></div></div><br class="example-break"><div class="example"><a name="ex.pxe.union.remote.ram"></a><p class="title"><b>Example 11.4. 
      Mount Compressed Image from Remote, Write to RAM
     </b><span class="permalink"><a alt="Permalink" title="Example 11.4. 
      Mount Compressed Image from Remote, Write to RAM
     " href="#ex.pxe.union.remote.ram">¶</a></span></p><div class="example-contents"><a class="indexterm" name="idm139781527547024"></a><p>
      Depending on whether the remote image is served via AoE, NBD, or NFS, the
      configuration differs:
     </p><p>
      <span class="bold"><strong>AoE</strong></span>
     </p><pre class="screen">AOEROOT=/dev/etherd/e0.1
UNIONFS_CONFIG=tmpfs,aoe,overlayfs</pre><p>
      <span class="bold"><strong>NBD</strong></span>
     </p><pre class="screen">NBDROOT=192.168.100.7;root1;/dev/nbd0
UNIONFS_CONFIG=tmpfs,nbd,overlayfs</pre><p>
      <span class="bold"><strong>NFS</strong></span>
     </p><pre class="screen">NFSROOT="192.168.100.2;/srv/kiwi-read-only-path"
UNIONFS_CONFIG=tmpfs,nfs,overlayfs</pre></div></div><br class="example-break"><div class="example"><a name="ex.pxe.union.remote.remote"></a><p class="title"><b>Example 11.5. 
      Mount Compressed Image from Remote, Write to Remote
     </b><span class="permalink"><a alt="Permalink" title="Example 11.5. 
      Mount Compressed Image from Remote, Write to Remote
     " href="#ex.pxe.union.remote.remote">¶</a></span></p><div class="example-contents"><a class="indexterm" name="idm139781527538864"></a><p>
      <span class="bold"><strong>AoE</strong></span>
     </p><pre class="screen">AOEROOT=/dev/etherd/e0.1,/dev/etherd/e1.1
UNIONFS_CONFIG=aoe,aoe,overlayfs</pre><p>
      <span class="bold"><strong>NBD</strong></span>
     </p><pre class="screen">NBDROOT=192.168.100.7;root1;/dev/nbd0;swap1;/dev/nbd1;write1;/dev/nbd2
UNIONFS_CONFIG=nbd,nbd,overlayfs</pre><p>
      <span class="bold"><strong>NFS</strong></span>
     </p><pre class="screen">NFSROOT="192.168.100.2;/srv/kiwi-read-only-path"
UNIONFS_CONFIG=/srv/kiwi-read-write-path,nfs,overlayfs</pre></div></div><br class="example-break"><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Check Remote Access</h3><p>
      It is recommended to check the accessibility of the read and, if
      applicable, the read-write devices from a client machine in the same
      network. If data can be read from and, if applicable, written to these
      devices, the image should also be able to access these devices when
      booting. If the PXE boot fails, device accessibility problems can be
      ruled out upfront.
     </p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.split-image"></a>11.3.4. Split Image<span class="permalink"><a alt="Permalink" title="11.3.4. Split Image" href="#sec.pxe.split-image">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781527529680"></a><p>
     An alternative to a Union Image (see <a class="xref" href="#sec.pxe.union-image" title="11.3.3. Union Image">Section 11.3.3, “Union Image”</a>)is a split image that combines the read
     and read-write partitions with
     the <code class="varname">COMBINED_IMAGE</code> method. This allows to use
     different file systems without the need for an overlay file system.
    </p><p>
     Edit <code class="filename">config.xml</code> and add a split type plus a split
     section describing the <code class="sgmltag-element">temporary</code> and
    <code class="sgmltag-element">persistent</code> parts:
    </p><pre class="screen">&lt;type fsreadonly="squashfs"
   image="split" fsreadwrite="ext3" boot="netboot/suse-..."/&gt;
  &lt;split&gt;
    &lt;temporary&gt;
      <code class="sgmltag-sgmlcomment">&lt;!-- allow RAM read/write access to: --&gt;</code>
      &lt;file name="/mnt"/&gt;
      &lt;file name="/mnt/*"/&gt;
    &lt;/temporary&gt;
    &lt;persistent&gt;
      <code class="sgmltag-sgmlcomment">&lt;!-- allow DISK read/write access to: --&gt;</code>
      &lt;file name="/var"/&gt;
      &lt;file name="/var/*"/&gt;
      &lt;file name="/boot"/&gt;
      &lt;file name="/boot/*"/&gt;
      &lt;file name="/etc"/&gt;
      &lt;file name="/etc/*"/&gt;
      &lt;file name="/home"/&gt;
      &lt;file name="/home/*"/&gt;
    &lt;/persistent&gt;
  &lt;/split&gt;
  ...
&lt;/type&gt;</pre><p>
     Create a <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code> file
     similar to the following::
    </p><pre class="screen">IMAGE='/dev/sda2;suse-##.#-pxe-client.i686;1.2.8;192.168.100.2;4096,\
      /dev/sda3;suse-##.#-pxe-client-read-write.i686;1.2.8;192.168.100.2;4096'
PART='200;S;x,500;L;/,x;L'
DISK=/dev/sda
COMBINED_IMAGE=yes
KIWI_INITRD=/boot/initrd</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.remote-root"></a>11.3.5. Mounting the Root File System from a Remote Server<span class="permalink"><a alt="Permalink" title="11.3.5. Mounting the Root File System from a Remote Server" href="#sec.pxe.remote-root">¶</a></span></h3></div></div></div><p>
     Instead of installing the image on a local storage device, it is also
     possible to mount the root file system remotely via AoE, NBD, and NFS.
    </p><div class="example"><a name="ex.pxe.remote-root.aoe"></a><p class="title"><b>Example 11.6. Root Tree Over AoE</b><span class="permalink"><a alt="Permalink" title="Example 11.6. Root Tree Over AoE" href="#ex.pxe.remote-root.aoe">¶</a></span></p><div class="example-contents"><p>
      Use the <span class="command"><strong>vbladed</strong></span> command on the remote server to bind
      a block device to an Ethernet interface. The block device can be a disk
      partition or a loop device (losetup) but not a directory. For example:
     </p><pre class="screen">vbladed 0 1 eth0 <em class="replaceable"><code>blockdevice</code></em></pre><p>
      Create a <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>
      pointing to the exported AoE device. For the example above, this would
      be:
     </p><pre class="screen">AOEROOT=/dev/etherd/e0.1</pre></div></div><br class="example-break"><div class="example"><a name="ex.pxe.root-tree-over-nbd"></a><p class="title"><b>Example 11.7. Root Tree Over NBD</b><span class="permalink"><a alt="Permalink" title="Example 11.7. Root Tree Over NBD" href="#ex.pxe.root-tree-over-nbd">¶</a></span></p><div class="example-contents"><p>
      Export the KIWI prepared tree on the NBD server and use a
      <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code> file similar
      to the following example:
     </p><pre class="screen">NBDROOT=192.168.100.7;root1;/dev/nbd0</pre></div></div><br class="example-break"><div class="example"><a name="ex.pxe.root-tree-over-nfs"></a><p class="title"><b>Example 11.8. Root Tree Over NFS</b><span class="permalink"><a alt="Permalink" title="Example 11.8. Root Tree Over NFS" href="#ex.pxe.root-tree-over-nfs">¶</a></span></p><div class="example-contents"><p>
      Export the KIWI prepared tree via NFS and use a
      <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code> file similar
      to the following example:
     </p><pre class="screen">NFSROOT=192.168.100.7;/tmp/kiwi.nfsroot</pre></div></div><br class="example-break"></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.groups"></a>11.4. Hardware Grouping<span class="permalink"><a alt="Permalink" title="11.4. Hardware Grouping" href="#sec.pxe.groups">¶</a></span></h2></div></div></div><p>
    As explained in the section <a class="xref" href="#sec.pxe.files" title="11.2. PXE Configuration Files">Section 11.2, “PXE Configuration Files”</a>, three
    different types of configuration files containing image and deployment
    information exist: generic, client-specific and group-specific. This
    section explains how to set up groups and group-specific configuration
    files.
   </p><p>
    Creating groups is useful if you have a subgroup of identical or similar
    clients that will use the same configuration file in an otherwise
    heterogeneous group of clients. Instead of creating and maintaining
    multiple
    <code class="filename">config.<em class="replaceable"><code>MAC_ADDRESS</code></em></code> with
    identical content, you create a single
    <code class="filename">config.<em class="replaceable"><code>GROUP</code></em></code> file.
   </p><p>
    To add one or more groups requires to create a group definition file
    (<code class="filename">config.group</code> defining the groups and the clients
    belonging to each group, and a configuration file
    <code class="filename">config.<em class="replaceable"><code>GROUP</code></em></code> for each
    group containing image and deployment information.
   </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.groups.def_file"></a>11.4.1. The Group Definition File<span class="permalink"><a alt="Permalink" title="11.4.1. The Group Definition File" href="#sec.pxe.groups.def_file">¶</a></span></h3></div></div></div><p>
     The group definition file defines one or more groups and assigns client
     machines by MAC address to these groups. The file is name
     <code class="filename">config.group</code> and needs to be placed in <code class="filename">/srv/tftpboot/KIWI/</code><a class="indexterm" name="idm139781527498160"></a> on the PXE boot server.
    </p><p>
     The following example <code class="filename">config.group</code> defines three
     groups <em class="replaceable"><code>group1</code></em>,
     <em class="replaceable"><code>group2</code></em>, and <em class="replaceable"><code>group3</code></em>
     and assigns two client machines to each group:
    </p><pre class="screen">KIWI_GROUP="<em class="replaceable"><code>group1</code></em>, <em class="replaceable"><code>group2</code></em>, <em class="replaceable"><code>group3</code></em>"

<em class="replaceable"><code>group1</code></em>_KIWI_MAC_LIST="11:11:11:11:11:11, 00:11:00:11:22:CA"
"<em class="replaceable"><code>group2</code></em>_KIWI_MAC_LIST="00:22:00:44:00:4D, 99:3F:21:A2:F4:32"
"<em class="replaceable"><code>group3</code></em>_KIWI_MAC_LIST="00:54:33:FA:44:33, 84:3D:45:2F:5F:33"</pre><p>
     The following parameters can be set in <code class="filename">config.group</code>:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">KIWI_GROUP</code></span></dt><dd><p>
        Contains a list of groups that should be defined. At least one group
        name needs to be specified. The names are separated by a comma and a
        space. Although there is no limit for the number of groups, it should
        be kept to a minimum for reasonable manageability.
       </p><p>
        Valid group names are made up of uppercase and lowercase letters, and
        may use numeric, and underscore characters. The same rules used to
        define Bash or sh variable names apply. The following example contains
        valid names:
       </p><pre class="screen">KIWI_GROUP="group1, group2, group3"</pre></dd><dt><span class="term">
       <code class="literal"><em class="replaceable"><code>GROUP_NAME</code></em>_KIWI_MAC_LIST</code>
      </span></dt><dd><p>
        This parameter is used to assign MAC addresses to the groups defined
        with <code class="envar">KIWI_GROUP</code><a class="indexterm" name="idm139781527484688"></a>. The name of this parameter depends on
        the group it represents. In our example the groups <code class="literal">group1,
        group2, group3</code> are defined, so the corresponding parameters
        are:
       </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="literal">group1_KIWI_MAC_LIST</code></td></tr><tr><td><code class="literal">group2_KIWI_MAC_LIST</code></td></tr><tr><td><code class="literal">group3_KIWI_MAC_LIST</code></td></tr></table><p>
        These parameters contain a comma-separated list of MAC addresses that
        should be assigned to the specified group. MAC addresses always need to
        be specified with uppercase letters, otherwise they will not match.
        If the list of addresses is very long (several thousand entries), the
        client's boot process my be slowed down.
       </p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.groups.group_file"></a>11.4.2. The Group Configuration File<span class="permalink"><a alt="Permalink" title="11.4.2. The Group Configuration File" href="#sec.pxe.groups.group_file">¶</a></span></h3></div></div></div><p>
     In addition to the group definition file
     <code class="filename">config.group</code>, each defined group requires a
     <code class="filename">config.<em class="replaceable"><code>GROUP_NAME</code></em></code> file
     containing the image and deployment information. Content-wise this file
     is identical to the <code class="filename">config.default</code> or
     <code class="filename">config.<em class="replaceable"><code>MAC_ADDRESS</code></em></code>. See
     <a class="xref" href="#sec.pxe.client-config-file" title="11.3. The PXE Client Configuration File Syntax">Section 11.3, “The PXE Client Configuration File Syntax”</a> for details. These files
     need to be placed in <code class="filename">/srv/tftpboot/KIWI/</code><a class="indexterm" name="idm139781527473072"></a> on the PXE server. For
     our example, the following files would be needed:
    </p><pre class="screen">/srv/tftpboot/KIWI/config.group1
/srv/tftpboot/KIWI/config.group2
/srv/tftpboot/KIWI/config.group3</pre><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.pxe.groups.group_file.overrides"></a>11.4.2.1. Hardware-Specific Configuration Files<span class="permalink"><a alt="Permalink" title="11.4.2.1. Hardware-Specific Configuration Files" href="#sec.pxe.groups.group_file.overrides">¶</a></span></h4></div></div></div><p>
      Some scenarios may require to provide different system configuration
      files to clients belonging to the same hardware group: If grouping
      clients with similar hardware, but for example different graphic cards,
      it may be necessary to provide graphic card specific configuration
      files. If setting up a PXE server supporting different locations within
      your organization, you may want to deliver country specific
      configurations for the system language and the keyboard layout.
     </p><p>
      The concept is similar to the one used with the group definition a
      configuration files. A list of MAC addresses that will receive
      individual configuration files is specified with two hardware mapping
      element in the group configuration file. A list of system configuration
      files for each hardware mapping element is specified in a hardware
      mapping configuration file.
     </p><p>
      Using hardware specific configuration files within a group is
      optional. It allows to use a single group configuration file, but to
      provide additional configuration files that will override the defaults
      provided by the <code class="literal">CONF</code> parameter. The same
      functionality could theoretically also be achieved by specifying
      different groups using different CONF parameters, but that would be less
      flexible and produce an unnecessary maintenance overhead.
     </p><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a name="sec.pxe.groups.group_file.overrides.hw_element"></a>11.4.2.1.1. The Hardware Mapping Elements<span class="permalink"><a alt="Permalink" title="11.4.2.1.1. The Hardware Mapping Elements" href="#sec.pxe.groups.group_file.overrides.hw_element">¶</a></span></h5></div></div></div><p>
       To use the hardware linking mechanism, two additional elements
       needs to be added to the group details file
       (<code class="filename">config.<em class="replaceable"><code>GROUP_NAME</code></em></code>. These
       two elements link hardware specific configurations to the appropriate
       systems by MAC address. A general example would look like this:
     </p><pre class="screen">HARDWARE_MAP="<em class="replaceable"><code>VENDORNAME_MODEL</code></em>"
<em class="replaceable"><code>VENDORNAME_MODEL</code></em>_HARDWARE_MAP="<em class="replaceable"><code>MAC1</code></em><em class="replaceable"><code>MAC2</code></em>"</pre><p>
      The following parameters can be set in <code class="filename">config.group</code>:
     </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">HARDWARE_MAP</code></span></dt><dd><p>
         This element follows the same rules as defined by the KIWI_GROUP
         element. However, this variable will create sub-groups used to ensure
         multiple types of hardware vendors can be used within the same group.
         The name of the group(s) should be clearly defined, and a good
         convention to follow would be to use a combination of the vendor name
         with the model number or type. This would allow for cases where the
         same vendor is used, but differences between alternative models
         requires different maps to be used.
        </p><pre class="screen">HARDWARE_MAP="myvendor_foo1000 myvendor_foo2000"</pre></dd><dt><span class="term">
       <code class="literal"><em class="replaceable"><code>HARDWARE_MAP_NAME</code></em>_HARDWARE_MAP</code></span></dt><dd><p>
         This element behaves identical to the
         <em class="replaceable"><code>GROUP_NAME</code></em>_KIWI_MAC_LIST element. It lists
         all MAC addresses that need to be linked to a hardware map. Any host
         defined within the list will receive configuration files that have
         been specifically defined in a
         hardware_config.<em class="replaceable"><code>HARDWARE_MAP</code></em> file (in
         addition to any files defined within a CONF element).
        </p><pre class="screen">myvendor_foo1000_HARDWARE_MAP="11:11:11:11:11:11"
myvendor_foo2000_HARDWARE_MAP="00:11:00:11:22:CA"</pre></dd></dl></div></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a name="sec.pxe.groups.group_file.overrides.hw_config"></a>11.4.2.1.2. The Hardware Mapping Configuration File<span class="permalink"><a alt="Permalink" title="11.4.2.1.2. The Hardware Mapping Configuration File" href="#sec.pxe.groups.group_file.overrides.hw_config">¶</a></span></h5></div></div></div><p>
      When the hardware map has been defined, the last step is to ensure
      configuration specific elements are linked to the host(s) in question.
      This is done by creating a new
      hardware_config.<em class="replaceable"><code>hardware_map</code></em> file.  The
      content of the file only contains one element
      <code class="literal">VENDOR_CONF</code>:
     </p><pre class="screen">VENDOR_CONF='CONFIGURATIONS/xorg.conf.<em class="replaceable"><code>hardware_name_model</code></em>;/etc/X11/xorg.conf;192.168.100.2;4096'</pre><p>
      The format of the VENDOR_CONF values is identical to the CONF
      variable used in the standard host and group configurations (see <a class="xref" href="#sec.pxe.client-config-file" title="11.3. The PXE Client Configuration File Syntax">Section 11.3, “The PXE Client Configuration File Syntax”</a>). In addition, files defined
      within this list will over-write any files defined in the group
      configuration, if and only if, the following requirements are met:
     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        The host is assigned to the current hardware map
       </p></li><li class="listitem"><p>
        The file is defined within the CONF <span class="emphasis"><em>and</em></span>
        VENDOR_CONF elements
       </p></li></ul></div><p>
      NOTE: If a file is not defined in the CONF element, but is defined in
      the VENDOR_CONF element, it is simply downloaded to the host as if it
      was a CONF file. In this case, no overwriting will take place as it is
      considered a new file.
     </p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="sec.pxe.groups.group_file.overrides.example"></a>11.4.2.2. A Complete Example<span class="permalink"><a alt="Permalink" title="11.4.2.2. A Complete Example" href="#sec.pxe.groups.group_file.overrides.example">¶</a></span></h4></div></div></div><p>
     The following is an example of a group that is using hardware from
     multiple vendors. For this example, lets assume the group will have 10
     defined hosts, seven are <em class="replaceable"><code>myvendor_foo1000</code></em> thin
     client, while the remaining three are
     <em class="replaceable"><code>myvendor_foo2000</code></em> thin clients. We will also
     assume that the differences between the two hardware models are specific
     to the video card and therefore require different X drivers.
    </p><p>
     The following configuration files in <code class="filename">/srv/tftpboot/KIWI</code>are required:
    </p><pre class="screen">config.group<a name="hw_conf.group"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
config.myvendor<a name="hw_conf.group_config"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
hardware_config.myvendor_foo2000<a name="hw_conf.hw_details"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span>
    </pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#hw_conf.group"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left"><p>
       <a class="xref" href="#ex.pxe.groups.group_file.overrides.example.group" title="Example 11.9. The Group Definition File config.group">Example 11.9, “The Group Definition File <code class="filename">config.group</code>”</a>
      </p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#hw_conf.group_config"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>
       <a class="xref" href="#ex.pxe.groups.group_file.overrides.example.group_config" title="Example 11.10.  The Group Configuration File config.myvendor">Example 11.10, “
      The Group Configuration File <code class="filename">config.myvendor</code>
     ”</a>
      </p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#hw_conf.hw_details"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left"><p>
       <a class="xref" href="#ex.pxe.groups.group_file.overrides.example.hw_config" title="Example 11.11.  The Hardware Mapping Details File hardware_config.myvendor_foo2000">Example 11.11, “
      The Hardware Mapping Details File
      <code class="filename">hardware_config.myvendor_foo2000</code>
     ”</a>
      </p></td></tr></table></div><div class="example"><a name="ex.pxe.groups.group_file.overrides.example.group"></a><p class="title"><b>Example 11.9. The Group Definition File <code class="filename">config.group</code></b><span class="permalink"><a alt="Permalink" title="Example 11.9. The Group Definition File config.group" href="#ex.pxe.groups.group_file.overrides.example.group">¶</a></span></p><div class="example-contents"><pre class="screen">KIWI_GROUP="myvendor"
myvendor_KIWI_MAC_LIST=
  "00:00:00:00:00:01 00:00:00:00:00:02 \
   00:00:00:00:00:03 00:00:00:00:00:04 \
   00:00:00:00:00:05 00:00:00:00:00:06 \
   00:00:00:00:00:07 00:00:00:00:00:08
   00:00:00:00:00:09 00:00:00:00:00:0A"</pre><p>
      The example group definition file contains a single group
      (<code class="literal">myvendor</code>) containing the ten thin clients.
     </p></div></div><br class="example-break"><div class="example"><a name="ex.pxe.groups.group_file.overrides.example.group_config"></a><p class="title"><b>Example 11.10. 
      The Group Configuration File <code class="filename">config.myvendor</code>
     </b><span class="permalink"><a alt="Permalink" title="Example 11.10. 
      The Group Configuration File config.myvendor
     " href="#ex.pxe.groups.group_file.overrides.example.group_config">¶</a></span></p><div class="example-contents"><pre class="screen">KIWI_INITRD=/boot/initrd
KIWI_KERNEL=/boot/linux
DISK=/dev/sda
PART='5;S;x,769;L;/,x;L;x'
IMAGE='/dev/sda2;exmaple-kiosk-opensuse-##.#-pxe-client.i686;0.0.1;192.168.1.2;4096'
UNIONFS_CONFIG=/dev/sda3,/dev/sda2,overlayfs
RELOAD_IMAGE=yes
RELOAD_CONFIG=yes
CONF='prefs.js;/home/kioskuser/.mozilla/firefox/07xvl1ty.default/prefs.js;192.168.1.2;4096,\
xorg.conf;/etc/X11/xorg.conf;192.168.1.2;4096'<a name="hw_conf.group_config.conf"></a><span><img src="images/callouts/1.png" alt="1" border="0"></span>
HARDWARE_MAP='myvendor_foo2000'<a name="hw_conf.group_config.hw_map"></a><span><img src="images/callouts/2.png" alt="2" border="0"></span>
myvendor_foo2000_HARDWARE_MAP='00:00:00:00:00:02 00:00:00:00:00:03 00:00:00:00:00:04'<a name="hw_conf.group_config.hw_clients"></a><span><img src="images/callouts/3.png" alt="3" border="0"></span></pre><p>
     The first seven lines define a standard KIWI configuration, while the
     last three lines set up a hardware-specific configuration.
    </p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#hw_conf.group_config.conf"><span><img src="images/callouts/1.png" alt="1" border="0"></span></a> </p></td><td valign="top" align="left"><p>
       Specifies two default configuration files that will be copied to all
       clients defined in this group: <code class="filename">prefs.js</code> (for
       Mozilla Firefox), and <code class="filename">xorg.conf</code> (for X Window).
      </p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#hw_conf.group_config.hw_map"><span><img src="images/callouts/2.png" alt="2" border="0"></span></a> </p></td><td valign="top" align="left"><p>
       Defines the hardware map(s) (<code class="literal">myvendor_foo2000</code> in
       this case) that are to be used to provide overrides for the
       configuration files defined in the previous lines.
      </p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#hw_conf.group_config.hw_clients"><span><img src="images/callouts/3.png" alt="3" border="0"></span></a> </p></td><td valign="top" align="left"><p>
       Defines the list of hosts (by MAC address) that will receive the
       configuration file overrides (the three myvendor_foo2000 clients).
      </p></td></tr></table></div></div></div><br class="example-break"><div class="example"><a name="ex.pxe.groups.group_file.overrides.example.hw_config"></a><p class="title"><b>Example 11.11. 
      The Hardware Mapping Details File
      <code class="filename">hardware_config.myvendor_foo2000</code>
     </b><span class="permalink"><a alt="Permalink" title="Example 11.11. 
      The Hardware Mapping Details File
      hardware_config.myvendor_foo2000
     " href="#ex.pxe.groups.group_file.overrides.example.hw_config">¶</a></span></p><div class="example-contents"><pre class="screen">VENDOR_CONF='xorg.conf.myvendor_foo2000;/etc/X11/xorg.conf;192.168.1.2;4096,\
someconfig.cfg;/etc/sysconfig/someconfig.cfg;192.168.1.2;4096'</pre><p>
     When the VENDOR_CONF definition is used, we are telling KIWI that all
     files defined within this element, are specific to the hardware map they
     are linked to. As a result, all files listed here will be transferred to
     a host if, and only if, the host has been linked to the hardware map via
     the myvendor_foo2000_HARDWARE_MAP element. In our example the only
     systems that will receive the xorg.conf.myvendor_foo2000 file will be the
     three myvendor_foo2000 thin clients listed in the hardware map itself.
    </p><p>
     In this VENDOR_CONF element, two files are defined. An override
     <code class="filename">xorg.conf</code> file and an additional file called
     <code class="filename">someconfig.cfg</code>.
     <code class="filename">xorg.conf.myvendor_foo2000</code> will overwrite the
     <code class="filename">xorg.conf</code> file that was previously transferred via
     the CONF element. In addition to that, <code class="filename">someconfig.cfg</code>
     will be copied to the three myvendor_foo2000 thin clients.
    </p></div></div><br class="example-break"><p>
     As a result of this example, all ten thin clients will receive the
     <code class="filename">prefs.js</code> file defined in
     <code class="literal">CONF</code>. The seven myvendor_foo1000 clients will receive the
     <code class="filename">xorg.conf</code> defined in <code class="literal">CONF</code>, while
     the three myvendor_foo2000 clients will receive the specific
     <code class="filename">xorg.conf</code> defined in
     <code class="literal">VENDOR_CONF</code>. The myvendor_foo2000 clients will also
     get the file <code class="filename">someconfig.cfg</code>.
    </p></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.oem"></a>Chapter 12. OEM Image / Preload Systems</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.oem.building">12.1. Building an OEM System and an Installation Image</a></span></dt><dt><span class="sect1"><a href="#sec.oem.testing">12.2. Testing the Images</a></span></dt><dt><span class="sect1"><a href="#sec.oem.flavours">12.3. Installation Image Flavors</a></span></dt><dt><span class="sect1"><a href="#sec.oem.customize">12.4. Customizing the OEM Images</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.oem.customize.installation">12.4.1. Customizing the OEM Install Process</a></span></dt><dt><span class="sect2"><a href="#sec.oem.customize.parameters">12.4.2. OEM Customizing Parameters</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partition-based-installation">12.4.3. Partition Based Installation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.oem.pxe-based-installation">12.5. Network Based Installation</a></span></dt></dl></div><a class="indexterm" name="idm139781527407632"></a><a class="indexterm" name="idm139781527406496"></a><a class="indexterm" name="idm139781527405360"></a><p>
  An OEM image is a virtual disk image representing all partitions and
  boot loader information the same way as on a physical disk. All flavors
  discussed previously in <a class="xref" href="#chap.vmx" title="Chapter 8. VMX Image / Virtual Disks">Chapter 8, <i>VMX Image / Virtual Disks</i></a> also apply to the OEM
  image type. Compared to the VMX image type, an OEM image comes with
  additional features. It can expand itself to a custom disk geometry
  and KIWI can create installation images which embeds the OEM image for
  deployment from CD/DVD/Stick and over the network via PXE.
 </p><a class="indexterm" name="idm139781527403088"></a><a class="indexterm" name="idm139781527402336"></a><a class="indexterm" name="idm139781527401584"></a><p>
  The basic idea behind an OEM image is to provide the virtual disk data for
  OEM vendors to support easy deployment of the system to physical storage
  media.
 </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">OEM Image Description Templates</h3><p>
   KIWI comes with many image description templates. It is
   recommended to use them as a basis for your own image descriptions. To do
   so, copy the respective directory containing the image description of your
   choice to you working directory and adjust it according to your needs.
  </p><p>
   OEM image templates are shipped with the package
   <span class="package">kiwi-desc-oemboot</span>. They are installed to
   <code class="filename">/usr/share/kiwi/image/oemboot</code>.
  </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.building"></a>12.1. Building an OEM System and an Installation Image<span class="permalink"><a alt="Permalink" title="12.1. Building an OEM System and an Installation Image" href="#sec.oem.building">¶</a></span></h2></div></div></div><p>
   The image creation process creates two images: An OEM disk image and an
   Installation ISO image containing the OEM disk image. The disk image can be
   dumped on a physical disk on the target system (using for example
   <span class="command"><strong>dd</strong></span>). The installation image can be dumped or burned
   to a bootable installation medium (for example a flash disk or a DVD).
   When a machine is booted from such a medium, an image deployment process
   (which can optionally be configured to run without user interaction) is
   started. The following example shows how to build a Just enough Operating
   System (JeOS) based on SUSE Linux Enterprise 12:
  </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myoem-result --type oem</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.testing"></a>12.2. Testing the Images<span class="permalink"><a alt="Permalink" title="12.2. Testing the Images" href="#sec.oem.testing">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781527392592"></a><a class="indexterm" name="idm139781527391456"></a><p>
   The images can be tested using virtualization software such as QEMU,
   VMware, or VirtualBox. The OEM disk image file can b identified by the
   extension <code class="filename">.raw</code><a class="indexterm" name="idm139781527389024"></a>, the installation
   image either has the <code class="filename">.iso</code><a class="indexterm" name="idm139781527387280"></a> or the
   <code class="filename">.raw.install</code><a class="indexterm" name="idm139781527385536"></a> extension (also see
   <a class="xref" href="#sec.oem.flavours" title="12.3. Installation Image Flavors">Section 12.3, “Installation Image Flavors”</a>).
  </p><p>
   To test the OEM disk image using <span class="command"><strong>qemu</strong></span>, run the
   following commands:
  </p><pre class="screen">cd /tmp/myoem-result
qemu LimeJeOS-SLE12.x86_64-1.13.1.raw</pre><p>
   Alternatively, use the <span class="command"><strong>dd</strong></span> command to dump the image onto
   a spare hard disk or a flash disk (this will wipe all existing data on the
   target device). To boot the image, select the appropriate device
   for booting device in the BIOS/EFI.
  </p><pre class="screen">cd /tmp/myoem-result
dd if=LimeJeOS-SLE12.x86_64-1.13.1.raw of=/dev/<em class="replaceable"><code>device</code></em></pre><p>
   Note, when testing an OEM image using the virtual disk image, for example
   the <code class="filename">.raw</code><a class="indexterm" name="idm139781527378224"></a> file, the geometry of the
   disk image is not changed and therefore retains the disk geometry of the
   host system. This implies that the re-partitioning performed for a physical
   disk install during the OEM boot workflow will be skipped.

   <em><span class="remark">
    2015-11-30 - fs: Does this mean you are asked whether you want to perform
    the repartitioning or not during the initial boot process?
   </span></em>
  </p><p>
   The installation image can also be tested using virtualization
   software. Note that the hard disk will be re-partitioned in this case. The
   following example uses <span class="command"><strong>qemu</strong></span> for testing. A virtual hard
   disk is created with <span class="command"><strong>qemu-img</strong></span> prior to starting the
   image.
  </p><pre class="screen">cd /tmp/myoem-result
qemu-img create /tmp/mydisk 20G
qemu -hda /tmp/mydisk -cdrom LimeJeOS-SLE12.x86_64-1.13.1.iso -boot d</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.flavours"></a>12.3. Installation Image Flavors<span class="permalink"><a alt="Permalink" title="12.3. Installation Image Flavors" href="#sec.oem.flavours">¶</a></span></h2></div></div></div><p>
   <a class="indexterm" name="idm139781527372176"></a> <a class="indexterm" name="idm139781527371168"></a>
   The installation image is a bootable, self-installing image that deploys
   the OEM image onto the selected storage device. The installation process is
   a simple image dump using the <span class="command"><strong>dd</strong></span> command. During this
   process the target system remains in terminal mode.
  </p><p>
   The installation image can be created in two formats: a hybrid image
   suitable for CD/DVD media and flash disks and a second one suitable for a
   flash disks only. The latter format can be used if the BIOS/EFI does not
   support booting from hybrid images.  The following
   configuration snippets show the use of the <code class="sgmltag-attribute">installiso</code><a class="indexterm" name="idm139781527368016"></a> to create a CD/DVD iso image and
   <code class="sgmltag-attribute">installstick</code><a class="indexterm" name="idm139781527366512"></a> attributes in
   <code class="filename">configuration.xml</code> to create a USB installation image
   format.
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
     <code class="literal">installiso</code>
    </span></dt><dd><p>
      Creates an <code class="filename">.iso</code><a class="indexterm" name="idm139781527361984"></a> file which can be
      burned onto a CD or a DVD or dumped on a flash disk. The attribute
      <code class="sgmltag-attribute">hybrid="true"</code><a class="indexterm" name="idm139781527360368"></a> makes sure a hybrid
      iso image is created that is suitable for both purposes. A
      hybrid image is the recommended format for an installation image. If the
      target hardware is not able to boot from such an image, try the <code class="sgmltag-attribute">installstick</code><a class="indexterm" name="idm139781527358608"></a> variant described below.
     </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    ...
    &lt;type image="name" installiso="true" hybrid="true" ....&gt;
      ...
    &lt;/type&gt;
  &lt;/preferences&gt;
  ...
&lt;/image ...&gt;</pre></dd><dt><span class="term">
     <code class="literal">installstick</code>
    </span></dt><dd><p>
      Creates a <code class="filename">.raw.install</code><a class="indexterm" name="idm139781527353824"></a> file
      which can be dumped (<span class="command"><strong>dd</strong></span>) onto a flash disk. Use this
      format if your machine cannot boot from a hybrid image.
     </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    ...
    &lt;type image="name" installstick="true" ....&gt;
      ...
    &lt;/type&gt;
  &lt;/preferences&gt;
  ...
&lt;/image ...&gt;</pre></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.customize"></a>12.4. Customizing the OEM Images<span class="permalink"><a alt="Permalink" title="12.4. Customizing the OEM Images" href="#sec.oem.customize">¶</a></span></h2></div></div></div><p>
   KIWI not only allows to customize the boot process of an OEM image by
   adding scripts to the image but also provides many configuration options
   that let you customize the boot loader, partitioning and other aspects of
   the image.
  </p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.customize.installation"></a>12.4.1. Customizing the OEM Install Process<span class="permalink"><a alt="Permalink" title="12.4.1. Customizing the OEM Install Process" href="#sec.oem.customize.installation">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781527348320"></a><a class="indexterm" name="idm139781527347568"></a><a class="indexterm" name="idm139781527346816"></a><a class="indexterm" name="idm139781527346064"></a><p>
    It is possible to customize the OEM install process by providing shell
    scripts with the following names. For more information on how to include
    the scripts into the boot image and make them work in the boot code, see
    the chapter <a class="xref" href="#sec.hooks" title="3.2.1. Boot Image Hook-Scripts">Section 3.2.1, “Boot Image Hook-Scripts”</a>.
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="filename">preHWdetect.sh</code></span></dt><dd><p>
       This script is executed prior to the hardware scan on the target
       machine.
      </p></dd><dt><span class="term"><code class="filename">postHWdetect.sh</code></span></dt><dd><p>
       This script is executed after the hardware scan on the target machine.
      </p></dd><dt><span class="term"><code class="filename">preImageDump.sh</code></span></dt><dd><p>
       This script is executed immediately prior to the OEM image dump onto
       the target storage device.
      </p></dd><dt><span class="term"><code class="filename">postImageDump.sh</code></span></dt><dd><p>
       This script is executed directly after the OEM image dump onto the
       target storage device when the image checksum has been successfully
       verified.
      </p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.customize.parameters"></a>12.4.2. OEM Customizing Parameters<span class="permalink"><a alt="Permalink" title="12.4.2. OEM Customizing Parameters" href="#sec.oem.customize.parameters">¶</a></span></h3></div></div></div><p>
    <em><span class="remark">
     2015-12-01 - fs: oem-home* is/are? missing. Any others?
    </span></em>
    All OEM customizing parameters reside in the <code class="sgmltag-element">oemconfig</code> tag in
    <code class="filename">configuration.xml</code>:
   </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    ...
    &lt;type image="oem" ....&gt;
      &lt;oemconfig&gt;
        &lt;oem-.../&gt;
      &lt;/oemconfig&gt;
      ...
    &lt;/type&gt;
  &lt;/preferences&gt;
  ...
&lt;/image ...&gt;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-boot-title&gt;</code>text<code class="sgmltag-endtag">&lt;/oem-boot-title&gt;</code>
     </span></dt><dd><p>
       By default, the string <code class="literal">OEM</code>&gt; will be used
       as the boot manager menu entry when KIWI creates the GRUB configuration
       during deployment. The <code class="sgmltag-element">oem-boot-title</code> element allows
       you to set a custom name for the GRUB menu entry. This value can also
       be set at the boot prompt by the parameter
       <code class="literal">kiwi_oemtitle="<em class="replaceable"><code>TITLE</code></em>"</code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-bootwait&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-bootwait&gt;</code>
     </span></dt><dd><p>
       Specify if the system should wait for user interaction prior to
       continuing the initial boot process after (default value is
       <code class="literal">false</code>). This value can also be set at the boot
       prompt by the parameter
       <code class="literal">kiwi_oembootwait=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-inplace-recovery&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-inplace-recovery&gt;</code>
     </span></dt><dd><p>
       Specify if the recovery archive is stored as part of the image or if
       the archive is to be created at the time the image is deployed to the
       target storage device. This value can also be set at the boot prompt
       by the parameter
       <code class="literal">kiwi_oemrecoveryInPlace=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-kiwi-initrd&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-kiwi-initrd&gt;</code>
     </span></dt><dd><p>
       If this element is set to <code class="literal">true</code> (default value is
       <code class="literal">false</code>) the oemboot boot image (initrd) will
       <span class="emphasis"><em>not</em></span> be replaced by the initrd created by the
       system. This option is useful when the system is installed on a flash
       disk. When booting from such a drive it is usually necessary to
       detect the storage location on each boot. This detection process is
       part of the oemboot boot image. This value can also be set at the boot
       prompt by the parameter
       <code class="literal">kiwi_oemkboot=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-partition-install&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-partition-install&gt;</code>
     </span></dt><dd><p>
       By default (<code class="literal">false</code>), an OEM image is installed on the
       specified disk on the target system. During this process the disk is
       being overwritten and the original data is lost. Setting this parameter
       to <code class="literal">true</code>, installs the image into an empty partition
       (that is a partition without a file system). If the device already
       contains a swap partition, it will be used, otherwise a swap file will
       be created. The empty partition needs to exist prior to booting the
       KIWI image, otherwise the installation will fail. Setting this
       parameter to <code class="literal">true</code> also makes KIWI ignore any other
       partitioning-related setting (for example <code class="sgmltag-element">oem-swap</code>). See <a class="xref" href="#sec.oem.partition-based-installation" title="12.4.3. Partition Based Installation">Section 12.4.3, “Partition Based Installation”</a> for more details. This
       value can also be set at the boot prompt by the parameter
       <code class="literal">kiwi_oempartition_install=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-reboot&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-reboot&gt;</code>
     </span></dt><dd><p>
       If set to <code class="literal">true</code>, the system reboots after the OEM
       image has been deployed. By default this parameter is set to
       <code class="literal">false</code>. This value can also be set at the boot prompt
       by the parameter
       <code class="literal">kiwi_oemreboot=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-reboot-interactive&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-reboot-interactive&gt;</code>
     </span></dt><dd><p>
       If set to <code class="literal">true</code>, the system reboots after the OEM
       image has been deployed. A message, which the user needs to confirm to
       start the reboot is displayed. By default this parameter is set to
       <code class="literal">false</code>. This value can also be set at the boot prompt
       by the parameter
       <code class="literal">kiwi_oemrebootinteractive=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-recovery&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-recovery&gt;</code>
     </span></dt><dd><p>
       If this element is set to <code class="literal">true</code> (default value is
       <code class="literal">false</code>), KIWI will create a recovery archive from the
       prepared root tree. The archive will appear as
       <code class="filename">/recovery.tar.bz2</code> in the image file. During the
       first boot of the image a single recovery partition will be created and
       the recovery archive will be moved to that partition. A boot menu entry
       for recovery, that will restores the original root tree on the system,
       is created. User data stored in <code class="filename">/home</code><a class="indexterm" name="idm139781527288352"></a> will not be affected by the recovery
       process. This value can also be set at the boot prompt by the parameter
       <code class="literal">kiwi_oemrecovery=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-recoveryID&gt;</code>partition-id<code class="sgmltag-endtag">&lt;/oem-recoveryID&gt;</code>
     </span></dt><dd><p>
       Specify the partition type for the recovery partition. The default is
       to create a Linux partition (id = 83). This value can also be set at
       the boot prompt by the parameter
       <code class="literal">kiwi_oemrecoveryID=<em class="replaceable"><code>ID</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-silent-boot&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-silent-boot&gt;</code>
     </span></dt><dd><p>
       Specify if the system should show boot messages
       (<code class="literal">false</code>) on the very first boot after having deployed
       the OEM image, or whether all boot messages should be suppressed
       (<code class="literal">true</code>). This value can also be set at the boot
       prompt by the parameter
       <code class="literal">kiwi_oemsilentboot=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-shutdown&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-shutdown&gt;</code>
     </span></dt><dd><p>
       Specify if the system is to be powered down after the OEM image has
       been deployed (the default value is <code class="literal">false</code>). This
       value can also be set at the boot prompt by the parameter
       <code class="literal">kiwi_oemshutdown=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-shutdown-interactive&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-shutdown-interactive&gt;</code>
     </span></dt><dd><p>
       Specify if the system is to be powered down after the OEM image has
       been deployed. A message, which the user needs to confirm to start the
       shutdown process, is displayed. This value can also be set at the boot
       prompt by the parameter
       <code class="literal">kiwi_oemshutdowninteractive=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-swap&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-swap&gt;</code>
     </span></dt><dd><p>
       Specify if a swap partition should be created (the default is
       <code class="literal">true</code>). This value can also be set at the boot prompt
       by the parameter
       <code class="literal">kiwi_oemswap=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd><dt><span class="term">
      <code class="sgmltag-starttag">&lt;oem-swapsize&gt;</code>size in MB<code class="sgmltag-endtag">&lt;/oem-swapsize&gt;</code>
     </span></dt><dd><p>
       Set the size of the swap partition in megabytes. If a swap partition is
       to be created and the size of the swap partition is not specified with
       this optional element, KIWI will create a swap partition of a size
       equal to two times of the RAM size at initial boot time. This value can
       also be set at the boot prompt by the parameter
       <code class="literal">kiwi_oemswapMB=<em class="replaceable"><code>SIZE_IN_MB</code></em></code>.
      </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-systemsize&gt;</code>size in MB<code class="sgmltag-endtag">&lt;/oem-systemsize&gt;</code>
     </span></dt><dd><p>
       Set the size the operating system is allowed to consume on the target
       disk. The size limit does not include any consideration for swap space
       or a recovery partition. In a setup <span class="emphasis"><em>without</em></span> a
       <code class="sgmltag-element">systemdisk</code> element this value
       specifies the size of the root partition. In a setup
       <span class="emphasis"><em>including</em></span> a <code class="sgmltag-element">systemdisk</code> element this value specifies the
       size of the LVM partition which contains all specified volumes. Thus,
       the sum of all specified volume sizes plus the sum of the specified
       free space for each volume must be smaller or equal than the size
       specified with the <code class="sgmltag-element">oem-systemsize</code>. This value can also be set at
       the boot prompt by the parameter
       <code class="literal">kiwi_oemrootMB=<em class="replaceable"><code>SIZE_IN_MB</code></em></code>.
      </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-unattended&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-unattended&gt;</code>
     </span></dt><dd><p>
       If set to <code class="literal">true</code>, the image deployment is done without
       requiring user interaction. If the target system contains multiple
       disks, the first device (/dev/sda, for example) is automatically
       selected. This value can also be set at the boot prompt by the
       parameter
       <code class="literal">kiwi_oemunattended=<em class="replaceable"><code>TRUE_OR_FALSE</code></em></code>.
      </p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.partition-based-installation"></a>12.4.3. Partition Based Installation<span class="permalink"><a alt="Permalink" title="12.4.3. Partition Based Installation" href="#sec.oem.partition-based-installation">¶</a></span></h3></div></div></div><a class="indexterm" name="idm139781527247280"></a><p>
    The default installation method of an OEM image is to dump the entire
    virtual disk onto the target disk and to re-partition the disk to match
    the real geometry. All data that was previously stored on the disk will be
    erased.
   </p><p>
    Alternatively KIWI supports the installation into already existing
    partitions. This requires to set up <span class="emphasis"><em>empty</em></span> (no file
    system) partitions prior to deploying the image. This way already existing
    data will not be touched. To activate the partition based install mode the
    following option needs to be set in <code class="filename">config.xml</code>:
   </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    ...
    &lt;type image="oem" ....&gt;
      &lt;oemconfig&gt;
        &lt;oem-partition-install&gt;true&lt;/oem-partition-install&gt;
      &lt;/oemconfig&gt;
      ...
    &lt;/type&gt;
  &lt;/preferences&gt;
  ...
&lt;/image ...&gt;</pre><p>
    With a partition-based installation, the setup differs from the default,
    disk-based installation in the following ways:
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      The boot loader will be set up to boot the installed system only. If a
      multi-boot setup is required, it needs to be manually configured by the
      user after the initial boot.
     </p></li><li class="listitem"><p>
      The parameter <code class="sgmltag-element">oem-home*</code>, <code class="sgmltag-element">oem-swap*</code>, and <code class="sgmltag-element">oem-systemsize</code> for system, swap and home are
      ignored. In this mode KIWI will not create additional partitions. If a
      swap partition exists, it will automatically be used, if not, a
      swap-file will be created.
     </p></li><li class="listitem"><p>
      There is no support for a remote (PXE) OEM installation, because KIWI
      needss to loop-mount the disk image and need to address specific regions
      inside of the image. Such operations are not implemented for remote
      access
     </p></li></ul></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.pxe-based-installation"></a>12.5. Network Based Installation<span class="permalink"><a alt="Permalink" title="12.5. Network Based Installation" href="#sec.oem.pxe-based-installation">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781527236256"></a><a class="indexterm" name="idm139781527235504"></a><p>
   Instead of manually dumping the OEM image on the target device or creating
   a KIWI installation CD or flash disk, the image can alternatively be
   downloaded from a PXE boot server over the network. This requires a PXE
   network boot server to be setup as explained in <a class="xref" href="#chap.pxe" title="Chapter 11. PXE Image / Thin Clients">Chapter 11, <i>PXE Image / Thin Clients</i></a>. If your PXE server is running the following steps are
   required to set up the installation process over the network:
  </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
     Make sure to create an installation PXE TAR archive along with your OEM
     image by setting the following option in
     <code class="filename">configuration.xml</code>:
    </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences&gt;
    ...
    &lt;type image="oem" installpxe="true"....&gt;
      ...
    &lt;/type&gt;
  &lt;/preferences&gt;
  ...
&lt;/image ...&gt;</pre></li><li class="step"><p>
     Create the image, unpack the resulting
     <code class="filename"><em class="replaceable"><code>IMAGE_NAME</code></em>.tgz</code> file to a
     temporary directory and copy the <code class="filename">initrd</code> and
     kernel images to the PXE server:
    </p><pre class="screen">
      mkdir /tmp/pxe &amp;&amp; cd /tmp/pxe
      <span class="command"><strong>tar</strong></span> -xf <em class="replaceable"><code>PATH_TO</code></em>/<em class="replaceable"><code>IMAGE_NAME</code></em>.tgz
<span class="command"><strong>scp</strong></span> initrd-oemboot-*.install.* <em class="replaceable"><code>PXE_SERVER_IP</code></em>:/srv/tftpboot/boot/initrd
<span class="command"><strong>scp</strong></span> initrd-oemboot-*.kernel.*  <em class="replaceable"><code>PXE_SERVER_IP</code></em>:/srv/tftpboot/boot/linux</pre></li><li class="step"><p>
     Also copy the system image and the md5 sum to the PXE boot server:
    </p><pre class="screen"><span class="command"><strong>scp</strong></span> <em class="replaceable"><code>IMAGE_FILE</code></em>.xz  <em class="replaceable"><code>PXE_SERVER_IP</code></em>:/srv/tftpboot/image/
<span class="command"><strong>scp</strong></span> <em class="replaceable"><code>IMAGE_FILE</code></em>.md5 <em class="replaceable"><code>PXE_SERVER_IP</code></em>:/srv/tftpboot/image/</pre></li><li class="step"><p>
     Copy the kernel command line parameters from
     <code class="filename"><em class="replaceable"><code>IMAGE_FILE</code></em>.append</code>. Edit
     your PXE configuration (for example
     <code class="filename">pxelinux.cfg/default</code>) on the PXE server and add
     these parameters to the append line.
    </p><p>
     Optionally the image and its md5sum can be stored on an FTP or HTTP
     server specified via the parameters
     <span class="command"><strong>kiwiserver=<em class="replaceable"><code>IP_ADRESS</code></em></strong></span> and
     <span class="command"><strong>kiwiservertype=<em class="replaceable"><code>HTTP_HTTPS_OR_FTP</code></em></strong></span>. In
     this case make sure to copy the system image and md5 file to the correct
     location on the server. KIWI searches the image at
     <em class="replaceable"><code>SERVER_ROOT</code></em>/image (for example
     http://www.example.com/image/<em class="replaceable"><code>IMAGE_FILE</code></em>.xz). Note
     that initrd and Linux Kernel are always loaded via PXE.
    </p></li></ol></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.xen"></a>Chapter 13. Xen Para- and Full virtual Images</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.xen.dom0.building">13.1. Building a Dom0 Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.dom0.using">13.2. Testing the Dom0 Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.pv.building">13.3. Building a Paravirtualized Xen Guest Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.domU.hvm.building">13.4. Building a Fully Virtualized Xen Guest</a></span></dt><dt><span class="sect1"><a href="#sec.xen.using">13.5. Using the Guest Images</a></span></dt></dl></div><a class="indexterm" name="idm139781527211984"></a><a class="indexterm" name="idm139781527210848"></a><a class="indexterm" name="idm139781527209712"></a><p>
  A Xen image is a virtual disk like a vmx but with the Xen kernel installed
  for dom0 or para virtual guest images. For fully virtualized guest images
  any Kernel, for example <code class="systemitem">kernel-default</code><a class="indexterm" name="idm139781527206480"></a>, my be used together with the
  Xen kernel modules.
 </p><p>
  A Xen image can only be booted on a Xen dom0 server. A Xen guest is booted
  via a boot infrastructure. For paravirtual images <code class="literal">pyGrub</code>
  or <code class="literal">pvGrub</code> can be used, while for HVM (fully virtualized)
  a special hvmloader is used. Xen extracts boot information from the given
  image and boots the guest. Depending on the guest type, also the boot loader
  configuration needs to be read. This puts some constraints on the
  configuration which are addressed by KIWI.
 </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Xen Image Description Templates</h3><p>
   KIWI comes with many image description templates. It is
   recommended to use them as a basis for your own image descriptions. To do
   so, copy the respective directory containing the image description of your
   choice to you working directory and adjust it according to your needs.
  </p><p>
   There are no special templates for Xen images. You may either use OEM or
   VMX image templates. OEM image templates are shipped with the package
   <span class="package">kiwi-desc-oemboot</span>. They are installed to
   <code class="filename">/usr/share/kiwi/image/oemboot</code>. VMX image templates are
   shipped with the package <span class="package">kiwi-desc-vmxboot</span>. They are
   installed to <code class="filename">/usr/share/kiwi/image/vmxboot</code>.
  </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.dom0.building"></a>13.1. Building a Dom0 Image<span class="permalink"><a alt="Permalink" title="13.1. Building a Dom0 Image" href="#sec.xen.dom0.building">¶</a></span></h2></div></div></div><p>
   The following example shows how to build a Just enough Operating System
   (JeOS) based on SUSE Linux Enterprise 12. The example adds a
   <code class="literal">xenFlavour</code> profile which builds a dom0 image for the OEM
   image type.
  </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myoem-result --type oem \
     --add-profile xenFlavour</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.dom0.using"></a>13.2. Testing the Dom0 Image<span class="permalink"><a alt="Permalink" title="13.2. Testing the Dom0 Image" href="#sec.xen.dom0.using">¶</a></span></h2></div></div></div><p>
   The dom0 represents the most privileged layer with access to the
   hardware. Running such an image in a fully virtualized system like Qemu, as
   shown below, is only suitable for testing purposes. For production system
   this is not supported and suffers from a major performance penalty. To test
   the image with <span class="command"><strong>qemu</strong></span>, run the following commands:
  </p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/myoem-result
<span class="command"><strong>qemu-img</strong></span> create mydom0 10g
<span class="command"><strong>qemu</strong></span> -cdrom LimeJeOS-SLE12.x86_64-1.13.1.install.iso -hda mydom0 -boot d</pre><p>
   When booted <span class="emphasis"><em>mydom0</em></span> is a Xen dom0 from which other
   Xen guests can be started.
  </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.domU.pv.building"></a>13.3. Building a Paravirtualized Xen Guest Image<span class="permalink"><a alt="Permalink" title="13.3. Building a Paravirtualized Xen Guest Image" href="#sec.xen.domU.pv.building">¶</a></span></h2></div></div></div><p>
   The following example shows how to build a Just enough Operating System
   (JeOS) based on SUSE Linux Enterprise 12. The example again uses
   the <code class="literal">xenFlavour</code> profile but builds a simple vmx
   image. The result is a disk image with kernel-xen prepared for paravirtual
   boot via GRUB2. To boot such a guest a <code class="literal">pvGrub</code>
   or <code class="literal">pyGrub</code> machine configuration supporting GRUB2 must be
   provided.
  </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myvmx-result --type vmx \
     --add-profile xenFlavour</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.domU.hvm.building"></a>13.4. Building a Fully Virtualized Xen Guest<span class="permalink"><a alt="Permalink" title="13.4. Building a Fully Virtualized Xen Guest" href="#sec.xen.domU.hvm.building">¶</a></span></h2></div></div></div><p>
   The following example shows how to build a Just enough Operating System
   (JeOS) based on SUSE Linux Enterprise 12. Contrary to the paravirtual
   guest image this example builds a simple vmx image including the standard
   kernel plus some kernel modules required by Xen. To boot such a
   guest, a hvmloader machine configuration must be provided.
  </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build suse-SLE12-JeOS -d /tmp/myvmx-result --type vmx \
     --add-profile xenFlavourHVM</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.using"></a>13.5. Using the Guest Images<span class="permalink"><a alt="Permalink" title="13.5. Using the Guest Images" href="#sec.xen.using">¶</a></span></h2></div></div></div><p>
   To run a domain U the Xen tool <span class="command"><strong>xl</strong></span> needs to be
   called in with a domain U configuration file:
  </p><pre class="screen"><span class="command"><strong>xl</strong></span> create -f <em class="replaceable"><code>CONFIG-FILE</code></em></pre><p>
   For paravirtual guest images KIWI supports the creation of the
   configuration file according to information provided with the <code class="sgmltag-element">machine</code> element of the KIWI
   configuration file <code class="filename">config.xml</code>:
  </p><pre class="screen">&lt;image ...&gt;
  &lt;preferences ...&lt;
    &lt;machine memory="512" domain="domU"&gt;
      &lt;vmdisk id="0" device="/dev/xvda" controller="ide"/&gt;
      &lt;vmnic interface=""/&gt;
    &lt;/machine&gt;
    ...
  &lt;/preferences&gt;
  ...
&lt;/image&gt;</pre><p>
   If this information exists, KIWI creates a file with the extension
   <code class="filename">.xenconfig</code>. Note that not all possible configuration
   options are supported by the KIWI Xen configuration file creator. For fully
   virtualized images there is currently no support to create the
   configuration from KIWI. However tools like <span class="command"><strong>virt-manager</strong></span>
   support you setting up the machine configuration. Refer to the <a class="ulink" href="https://www.suse.com/documentation/sles-12/book_virt/data/book_virt.html" target="_top">SUSE
   Linux Enterprise Virtualization Guide</a> or the <a class="ulink" href="http://www.xenproject.org/help/documentation.html" target="_top">Xen
   Documentation</a> for more information.
  </p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.appliance"></a>Chapter 14. Creating Appliances</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#sec.appliance.kiwi-model">14.1. The KIWI Model</a></span></dt></dl></div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
   With the traditional model of application delivery, applications such as a
   word processor or an e-mail program are installed by a user or an
   administrator on individual machines. When deploying the application on
   multiple machines, this often requires to start the application
   installation on each machine. Furthermore, in case of machines
   solely dedicated to a single application or a defined set of applications,
   it is good practice, to adjust the operating system to optimize resource
   management and maximize security and performance. When multiple machines
   are affected, the steps for adjusting the operating system need to be
   performed on each machine, too.
  </p><p>
   An alternative to the traditional model of application delivery is to
   provide a so-called <span class="quote">“<span class="quote">appliance</span>”</span>. An appliance is the
   combination of the parts of a general purpose OS needed by a given
   application and the application itself, bundled and delivered as one
   unit. This unit may be delivered in a variety of formats, for example a
   ready to run virtual machine or a self-installing system on an optical
   media or a flash disk.
  </p><p>
   The appliance model has a many advantages. Operating system and
   application installation are no longer separate steps. The application is
   installed together with the operating system and the installation does not
   require manual intervention. The appliance provider can preconfigure the
   application to be ready-to-run directly after installation. Furthermore,
   the appliance provider can customize the operating system in terms of
   performance, resources and security, so it best fits the given
   appliance.
  </p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.appliance.kiwi-model"></a>14.1. The KIWI Model<span class="permalink"><a alt="Permalink" title="14.1. The KIWI Model" href="#sec.appliance.kiwi-model">¶</a></span></h2></div></div></div><a class="indexterm" name="idm139781527167120"></a><p>
   KIWI supports building appliances. When building appliances with KIWI the
   following procedure has proven to work reliably. Nevertheless it is a
   recommendation only and can be adapted to special needs and environments.
  </p><div class="procedure"><a name="proc.appliance.general-building"></a><ol class="procedure" type="1"><li class="step"><p>
     Choose an appropriate image description from the KIWI example templates.
     They are provided by the packages <span class="package">kiwi-templates</span>,
     <span class="package">kiwi-desc-vmxboot</span>,
     <span class="package">kiwi-desc-netboot</span>, and
     <span class="package">kiwi-desc-oemboot</span>. The templates are installed to
     <code class="filename">/usr/share/kiwi/images</code><a class="indexterm" name="idm139781527161584"></a>.  Add or
     adapt repositories and/or package names, according to the distribution
     you want to build an image for.
    </p></li><li class="step"><p>
     Allow the image to create an in-place git repository to allow tracking
     non-binary changes. This is done by adding the following line into the
     <span class="command"><strong>config.sh</strong></span> script:
    </p><pre class="screen">baseSetupPlainTextGITRepository</pre></li><li class="step"><p>
     Set up a testing environment. A physical machine supporting to boot
     from a flash disk is recommended. All image templates provided by KIWI
     contain a hybrid iso type setup which is suitable for such a machine.
    </p></li><li class="step"><p>
     Build the live stick appliance by running
    </p><pre class="screen">kiwi --build template-name</pre></li><li class="step"><p>
     Transfer the image generated in the previous step to the flash disk. Note
     that all data on the disk will be erased!
    </p><pre class="screen">dd if=<em class="replaceable"><code>PATH_TO_ISO_IMAGE</code></em>
    of=<em class="replaceable"><code>FLASH_DISK_DEVICE</code></em> bs=4M</pre></li><li class="step"><p>
     Plug the flash disk into your test machine and boot it from the disk
     containing the appliance.
    </p></li><li class="step"><p>
     After your test system has successfully booted the image, log in to your
     appliance and start to tweak the system according to your needs.  This
     includes all actions required to configure the appliance as
     needed. Before you start take care for the following:
    </p><ol type="a" class="substeps"><li class="step"><p>
       Create an initial package list. This can be done by calling:
      </p><pre class="screen">rpm -qa | sort &gt; /tmp/deployPackages</pre></li><li class="step"><p>
       Check the output of the command <span class="command"><strong>git</strong></span>
       <code class="option">status</code> and add all files matching the following
       criteria to <code class="filename">/.gitignore</code>:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
         the file is not yet part of the repository
        </p></li><li class="listitem"><p>
         you do not plan to change the file
        </p></li><li class="listitem"><p>
         the file will not be included by one of the image description overlay
         files
        </p></li></ul></div></li></ol><p>
     When the initial package list exist and the git repository is set up,
     you can start to configure the system.
    </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Installing Additional Software</h3><p>
      Do not add additional software by installing a package being part of
      a repository not listed in <code class="filename">configuration.xml</code> or by
      compiling it from the sources. It is very hard to find out what binary
      files have been installed that way and it is also not architecture-safe.
     </p><p>
      If there is really no other way for the software to become part of the
      image, you should address this issue directly in your image description
      and the <span class="command"><strong>config.sh</strong></span> script, but not after the initial
      deployment has happened.
     </p></div></li><li class="step"><p>
     As soon as the appliance on your test system works as expected it is
     ready to enter the final stage. At this point you have done several
     changes to the system which are tracked by the git repository and the
     package list. To include them into your image description, use the
     following process:
    </p><ol type="a" class="substeps"><li class="step"><p>
       Check the differences between the currently installed packages and
       the initial deployment list. This can be done by running:
      </p><pre class="screen">rpm -qa | sort &gt; /tmp/appliancePackages
diff -u /tmp/deployPackages /tmp/appliancePackages</pre><p>
       Add all packages labeled with <code class="literal">(+)</code> to the
       <code class="sgmltag-starttag">&lt;packages type="image"&gt;</code> section of
       your config.xml file and remove packages labeled with
       <code class="literal">(−)</code>.
      </p><p>
       In case you want to keep packages that have been automatically removed
       by the package manager, make sure you address these packages in the
       <code class="filename">config.sh</code> script. If you have installed packages
       from repositories which are not yet configured in
       <code class="filename">config.xml</code>, add them to allow KIWI to
       install the packages.
      </p></li><li class="step"><p>
       Check the differences made in the configuration files by running:
      </p><pre class="screen">git diff &gt;/tmp/appliancePatch</pre><p>
       The patch created with this command
       (<code class="filename">/tmp/appliancePatch</code>) should become part of your
       image description. To make sure it is applied when preparing the image,
       add the following line to <span class="command"><strong>config.sh</strong></span>:
      </p><pre class="screen"><span class="command"><strong>patch</strong></span> -p0 &lt; appliancePatch</pre></li><li class="step"><p>
       Check for new non binary files that have been added. This can be done
       by calling:
      </p><pre class="screen"><span class="command"><strong>git</strong></span> status</pre><p>
       All files not yet tracked, will be listed under <code class="literal">Untracked
       files</code>. Make sure to add all files from this list
       <span class="emphasis"><em>which are not created automatically</em></span> to your image
       description. To do this, clone (copy) these files with regards to the
       file system structure as overlay files in your image description
       <code class="filename">root/</code><a class="indexterm" name="idm139781527120592"></a> directory.
      </p></li></ol></li><li class="step"><p>
     All customization work you did within your appliance is now stored in the
     image description. The image description you created can be re-used
     for all image types supported by KIWI.
    </p></li></ol></div><p>
   To make sure the appliance works as expected prepare a new image tree and
   create an image from the new tree. You may optionally disable the creation
   of the git repository within this new image tree to save disk space. If
   this appliance is a server, you should keep it, because it allows you to
   keep track of changes during the live time of this appliance.
  </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Cross Platform Appliance Building</h3><a class="indexterm" name="idm139781527116432"></a><p>
    Building appliances for a specific processor architecture on a different
    processor architecture is in generally <span class="emphasis"><em>not</em></span> possible
    with KIWI. This limitation is based on the requirement that KIWI needs to
    be able to execute installed software inside the unpacked image tree. If
    the software installed inside the unpacked image tree does not run on the
    architecture of the build platform then KIWI cannot build the
    appliance. The only exception is building 32-bit x86 appliances on a
    64-bit x86-64 architecture.
   </p><p>
    KIWI's option <code class="option">--target-arch</code> is not intended to support
    cross-platform appliance builds. It rather tells the package manager to
    install packages for the specified architecture.
   </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chap.migration"></a>Chapter 15. System Analysis/Migration</h2></div></div></div><a class="indexterm" name="idm139781527111744"></a><p>
  KIWI provides a module which allows you to analyze the running system for
  creating a report and an image description representing the current state of
  the machine. Among others, this allows you to clone your currently running
  system into an image. The process has the following limitations at the
  moment:
 </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
    Works for SUSE systems only (with zypper on board)
   </p></li><li class="listitem"><p>
    The process works semi-automatically—depending on the
    complexity of the system, some manual postprocessing might be necessary
   </p></li></ul></div><p>
  When calling KIWI's analysis module it tries to find the base version of
  your operating system by using the active repositories specified in the
  zypper database to identify the software packages currently installed. The
  result is a list of packages and patterns representing your system. Files
  not belonging to any packages, such as user data or configuration files, are
  provided as custom data by KIWI. In addition, KIWI offers different data
  visualization e.g unmanaged binary data. Along with the software analysis,
  KIWI also checks for enabled systemd services, augeas configuration
  inventory and more. The process will not go beyond the scope of local
  file systems.
 </p><p>
  To create an image of your running system, proceed as follows:
 </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
    Create a report listing all packages and repositories currently installed
    by running
   </p><pre class="screen">sudo kiwi --describe workstation</pre><p>
    The result will be written to /var/cache/kiwi/describe/workstation
   </p></li><li class="step"><p>
    Check the result of the previous step for packages that cannot be assigned
    to a repository. If you do not need these packages within your image,
    proceed with the next step. If you want them to be in the image, either
    add the repositories containing these packages to your system (for
    example with <span class="command"><strong>zypper addrepo</strong></span>) and run the previous
    command again. Alternatively, tell KIWI which additional repos to check,
    by using the previous command together with the
    <code class="option">--add-repo</code> and <code class="option">--add-repotype</code> options
    (refer to <span class="command"><strong>man 1 kiwi</strong></span> for more information).
   </p></li><li class="step"><p>
    Rerun the report generating command. List all packages that are not part
    of a repository or should not be included with the <code class="option">--skip</code>
    parameter. In case you have previously used the
    <code class="option">--add-repo</code> and <code class="option">--add-repotype</code> options,
    use them again with this command:

    <em><span class="remark">
     2015-12-22 - fs: --skip and --nofiles are not mentioned in "man 1 kiwi"
    </span></em>

   </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --describe workstation --nofiles \
--skip "<em class="replaceable"><code>LIST_OF_PAKAGES</code></em>" \
--add-repo <em class="replaceable"><code>REPO</code></em> --add-repotype <em class="replaceable"><code>TYPE</code></em></pre></li><li class="step"><p>
    Next check the list of files not belonging to any packages in
    <code class="filename">/var/cache/kiwi/describe/workstation/custom.files</code>. Among
    others, this list contains user data, configuration files, and database
    files. Make sure to only add files to the image that are really needed. In
    case you want to publish the image, double check the list for password
    files, configuration files containing plain text passwords, user data,
    databases and other sensitive data. All files that should become part of
    the image description need to be moved from <code class="filename">/var/cache/kiwi/describe/worksation/custom</code><a class="indexterm" name="idm139781527092000"></a> to
    <code class="filename">/var/cache/kiwi/describe/worksation/root</code>. For
    additional information also check <code class="filename">/var/cache/kiwi/describe/workstation/custom.files.readme</code>.
   </p></li><li class="step"><p>
    Adjust the image description according to your needs by checking the
    following items:
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      Change author and contact in <code class="filename">config.xml</code>.
     </p></li><li class="listitem"><p>
      Set appropriate name for your image in <code class="filename">config.xml</code>.
     </p></li><li class="listitem"><p>
      Add or modify the image type (<code class="literal">oem</code> by default) set in
      <code class="filename">config.xml</code> if needed.
     </p></li><li class="listitem"><p>
      If you want to access any remote file system its a good idea to let
      AutoYaST add them on first boot of the system.
     </p></li><li class="listitem"><p>
      Check the network setup in
      <code class="filename">/etc/sysconfig/network</code>. Is this setup still
      possible in the cloned environment? Make sure you check for the MAC
      address of the card first.
     </p></li></ul></div></li><li class="step"><p>
    Check the size of the image description. It's good practice to keep the
    image as small as possible. The size of a migrated image description
    mainly depends on how many overlay files exists in the <code class="filename">root/</code><a class="indexterm" name="idm139781527078944"></a> directory. You should make sure to
    maintain only required overlay files.
   </p></li><li class="step"><p>
    Create an image from the description. By default an OEM image, containing
    a virtual disk that can also be deployed to a physical machine, is
    created. In addition to that, an ISO image containing an installable
    version of the image, is also generated. Refer to <a class="xref" href="#chap.oem" title="Chapter 12. OEM Image / Preload Systems">Chapter 12, <i>OEM Image / Preload Systems</i></a> for details.
   </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --build /var/cache/kiwi/describe/workstation -d /tmp/myResult</pre></li><li class="step"><p>
    Test the image as described in <a class="xref" href="#sec.oem.testing" title="12.2. Testing the Images">Section 12.2, “Testing the Images”</a>.
   </p></li></ol></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="appendix"></a>Appendix A. KIWI Man Pages</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwi">kiwi</a></span><span class="refpurpose"> — Creating Operating System Images</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.config.sh">kiwi::config.sh</a></span><span class="refpurpose"> — Customization File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.images.sh">kiwi::images.sh</a></span><span class="refpurpose"> — Customization File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwirc">kiwi::kiwirc</a></span><span class="refpurpose"> — Resource file for the Kiwi imaging system</span></dt></dl></div><p>
  The following pages will show you the man page of KIWI and the functions
  which can be used within <span class="command"><strong>config.sh</strong></span> and
  <span class="command"><strong>index.sh</strong></span>
 </p><div class="refentry"><a name="ref.kiwi.kiwi"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi</span></h2><p>kiwi — Creating Operating System Images</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -l  |   --list }</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -o  |   --clone }  <em class="replaceable"><code>image-path</code></em>
     { -d }  <em class="replaceable"><code>destination</code></em>
    </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -b  |   --build }  <em class="replaceable"><code>image-path</code></em>
     { -d }  <em class="replaceable"><code>destination</code></em>
    </p></div></div><div class="refsect1"><a name="kiwi.image.basics"></a><h2>Basics</h2><p>
   KIWI is a complete imaging solution that is based on an image
   description. Such a description is represented by a directory which
   includes at least one <code class="filename">config.xml</code> file and may as
   well include other files like scripts or configuration data. The
   <code class="systemitem">kiwi-templates</code> package provides example
   descriptions based on a JeOS system. JeOS means <span class="emphasis"><em>Just enough
   Operating System</em></span>. KIWI provides image templates based on that
   axiom which means a JeOS is a small, text only based image including a
   predefined remote source setup to allow installation of missing software
   components at a later point in time.
  </p><p>
   Detailed description of the kiwi image system exists in the system design
   document in
   <a class="ulink" href="file:///usr/share/doc/packages/kiwi/kiwi.pdf" target="_top">file:///usr/share/doc/packages/kiwi/kiwi.pdf</a>. KIWI
   always operates in two steps. The KIWI <code class="option">--build</code> option
   just combines both steps into one to make it easier to start with KIWI.
   The first step is the preparation step and if that step was successful, a
   creation step follows which can create different image output
   types. If you have started with an example and want to add you own
   changes it might be a good idea to clone of from this example. This can
   be done by simply copying the entire image description or you can let
   KIWI do that for you by using the <span class="command"><strong>kiwi</strong></span>
   <code class="option">--clone</code> command.
  </p><p>
   In the preparation step, you prepare a directory including the contents
   of your new file system based on one or more software package source(s)
   The creation step is based on the result of the preparation step and uses
   the contents of the new image root tree to create the output image. If
   the image type ISO was requested, the output image would be a file with
   the suffix <code class="filename">.iso</code><a class="indexterm" name="idm139781527035216"></a>
   representing a live system on CD or DVD. Other than that KIWI can
   create images for virtual and para-virtual (Xen) environments as well as
   for USB stick, PXE network clients and OEM customized Linux systems.
  </p></div><div class="refsect1"><a name="kiwi.general"></a><h2>General Options</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">-h</code> | <code class="option">--help</code></span>]
    </span></dt><dd><p>
      Display help.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--version</code></span>]
    </span></dt><dd><p>
      Display the KIWI version.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--check-config <em class="replaceable"><code>path-to-the-configuration-file</code></em></code></span>]
    </span></dt><dd><p>
      Checks the XML configuration file.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--nocolor</code></span>]
    </span></dt><dd><p>
      Do not use colored output.
     </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.image.prepcreate"></a><h2>Image Preparation and Creation</h2><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -p  |   --prepare }  <em class="replaceable"><code>image-path</code></em>
    <br> { -r  |   --root }  <em class="replaceable"><code>image-root</code></em>
     [--cache <em class="replaceable"><code>directory</code></em>
   ]</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -c  |   --create }  <em class="replaceable"><code>image-root</code></em>
    <br> { -d  |   --destdir }  <em class="replaceable"><code>destination</code></em>
     [--type <em class="replaceable"><code>image-type</code></em>
   ]</p></div></div><div class="refsect1"><a name="kiwi.image.upgrade"></a><h2>Image Upgrade</h2><p>
   If the image root tree is stored and not removed, it can be used for
   upgrading the image according to the changes made in the repositories
   used for this image. If a distributor provides an update channel for
   package updates and an image <code class="filename">config.xml</code> includes
   this update channel as repository, it is useful to store the image root
   tree and upgrade the tree according to changes on the update channel.
   Given that the root tree exists it's also possible to add or remove
   software and recreate the image of the desired type.
  </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -u  |   --upgrade }  <em class="replaceable"><code>image-root</code></em>
     [--add-package <em class="replaceable"><code>name</code></em>
   ] [--add-pattern <em class="replaceable"><code>name</code></em>
   ]</p></div></div><div class="refsect1"><a name="kiwi.image.system2image"></a><h2>System Analysis</h2><p>
   KIWI provides a module which allows you to analyze the running system and
   create a report and an image description representing the current state
   of the machine. Among others this allows you to clone your currently
   running system into an image. The system requires the zypper back-end in
   order to work properly.
  </p><p>
   The process will always place it's result into the
   <code class="filename">/tmp/$OptionValueOf--describe</code> directory. The reason
   for this is because <code class="filename">/tmp</code><a class="indexterm" name="idm139781526990944"></a> is always
   excluded from the analysis and therefore we can safely place new files
   there without influencing the process itself. You should have at least
   100 MB free space for the cache file and the image description all
   the rest are just hard links.
  </p><p>
   As one result a HTML based report file is created which contains
   important information about the system. You are free to ignore that
   information but with the risk that the image from that description does
   not represent the same system which is running at the moment. The less
   issues left in the report the better is the result. In most cases a
   manual fine tuning is required. This includes the repository selection
   and the unmanaged files along with the configuration details of your
   currently running operating system. You should understand the module as a
   helper to analyze running linux systems.
  </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { --describe }  <em class="replaceable"><code>name</code></em>
    </p></div></div><div class="refsect1"><a name="kiwi.image.postproc"></a><h2>Image Postprocessing Modes</h2><p>
   The KIWI post-processing modes are used for special image deployment
   tasks, like installing the image on a USB stick. So to say they are the
   third step after preparation and creation. KIWI calls the postprocessing
   modules automatically according to the specified output image type and
   attributes but it's also possible to call them manually.
  </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --bootvm <em class="replaceable"><code>initrd</code></em>
      --bootvm-system <em class="replaceable"><code>systemImage</code></em>
     [--bootvm-disksize <em class="replaceable"><code>size</code></em>
   ]</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --bootcd <em class="replaceable"><code>initrd</code></em>
    </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --bootusb <em class="replaceable"><code>initrd</code></em>
    </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --installcd <em class="replaceable"><code>initrd</code></em>
      --installcd-system <em class="replaceable"><code>raw-system-image</code></em>
    </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --installstick <em class="replaceable"><code>initrd</code></em>
      --installstick-system <em class="replaceable"><code>raw-system-image</code></em>
    </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --installpxe <em class="replaceable"><code>initrd</code></em>
      --installpxe-system <em class="replaceable"><code>raw-system-image</code></em>
    </p></div></div><div class="refsect1"><a name="idm139781526961536"></a><h2>Image Format Conversion</h2><p>
   The KIWI format conversion is useful to perform the creation of another
   image output format like vmdk for VMware or ovf the open virtual machine
   format. Along with the conversion KIWI also creates the virtual machine
   configuration according to the format if there is a machine section
   specified in the XML description
  </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --convert <em class="replaceable"><code>systemImage</code></em>
     [--format <em class="replaceable"><code>vmdk|ovf|qcow2|vhd</code></em>
   ]</p></div></div><div class="refsect1"><a name="idm139781526956416"></a><h2>Helper Tools</h2><p>
   The helper tools provide optional functions like creating an encrypted
   password string for the users section of the
   <code class="filename">config.xml</code> file as well as signing the image
   description with an md5sum hash and adding splash data to the boot image
   used by the boot loader.
  </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --createpassword </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --createhash
      <em class="replaceable"><code>image-path</code></em>
    </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -i  |   --info }  <em class="replaceable"><code>ImagePath</code></em>
     {--select
      <em class="replaceable"><code>
    repo-patterns|patterns|types|sources|size|profiles|packages|version
    </code></em>
   }</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --setup-splash <em class="replaceable"><code>initrd</code></em>
    </p></div><p>
   The following list describes the helper tools more detailed
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">--createpassword</code></span>]
    </span></dt><dd><p>
      Create a crypted password hash and prints it on the console. The user
      can use the string as value for the pwd attribute in the XML users
      section
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--createhash <em class="replaceable"><code>image-path</code></em></code></span>]
    </span></dt><dd><p>
      Sign your image description with a md5sum. The result is written to a
      file named <code class="filename">.checksum.md</code> and is checked if KIWI
      creates an image from this description.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">-i</code> | <code class="option">--info <em class="replaceable"><code>image-path</code></em></code><code class="option">--select <em class="replaceable"><code>selection</code></em></code></span>]
    </span></dt><dd><p>
      List general information about the image description. So far you can
      get information about the available patterns in the configured
      repositories with <em class="replaceable"><code>repo-patterns</code></em>, a list of
      used patterns for this image with <em class="replaceable"><code>patterns</code></em>,
      a list of supported image types with <em class="replaceable"><code>types</code></em>,
      a list of source URLs with <em class="replaceable"><code>sources</code></em>, an
      estimation about the install size and the size of the packages marked
      as to be deleted with <em class="replaceable"><code>size</code></em>, a list of
      profiles with <em class="replaceable"><code>profiles</code></em>, a list of solved
      packages to become installed with <em class="replaceable"><code>packages</code></em>,
      and the information about the appliance name and version with
      <em class="replaceable"><code>version</code></em>
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--setup-splash <em class="replaceable"><code>initrd</code></em></code></span>]
    </span></dt><dd><p>
      Create splash screen from the data inside the initrd and re-create the
      initrd with the splash screen attached to the initrd cpio archive.
      This enables the kernel to load the splash screen at boot time. If
      splashy is used only a link to the original initrd will be created
     </p></dd></dl></div></div><div class="refsect1"><a name="kiwi..global.options"></a><h2>Global Options</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">--add-profile</code><em class="replaceable"><code>profile-name</code></em></span>]
    </span></dt><dd><p>
      Use the specified profile. A profile is a part of the XML image
      description and therefore can enhance each section with additional
      information. For example adding packages.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repo</code><em class="replaceable"><code>URL</code></em></span>]
    </span></dt><dd><p>
      Set/Overwrite the repo URL for the first repo listed in the
      configuration file that does not have a "fixed" status. The change is
      temporary and will not be written to the XML file.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repotype</code><em class="replaceable"><code>type</code></em></span>]
    </span></dt><dd><p>
      Set/Overwrite repo type for the first listed repo. The supported repo
      types depends on the package manager. Commonly supported are rpm-md,
      rpm-dir and yast2. The change is temporary and will not be written to
      the XML file.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repoalias</code><em class="replaceable"><code>name</code></em></span>]
    </span></dt><dd><p>
      Set/Overwrite alias name for the first listed repo. Alias names are
      optional free form text. If not set the source attribute value is used
      and builds the alias name by replacing each <span class="quote">“<span class="quote">/</span>”</span> with a
      <span class="quote">“<span class="quote">_</span>”</span>. An alias name should be set if the source argument
      doesn't really explain what this repository contains. The change is
      temporary and will not be written to the XML file.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repoprio</code><em class="replaceable"><code>number</code></em></span>]
    </span></dt><dd><p>
      Set/Overwrite priority for the first listed repo. Works with the smart
      package manager only. The Channel priority assigned to all packages
      available in this channel (0 if not set). If the exact same package is
      available in more than one channel, the highest priority is used.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--add-repo
      <em class="replaceable"><code>URL</code></em></code>,
      <code class="option">--add-repotype <em class="replaceable"><code>type</code></em></code><code class="option">--add-repoalias <em class="replaceable"><code>name</code></em></code><code class="option">--add-repoprio <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      Add the given repository and type for this run of an image prepare or
      upgrade process. Multiple
      <code class="option">--add-repo</code>/<code class="option">--add-repotype</code> options
      are possible. The change will not be written to the
      <code class="filename">config.xml</code> file
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--ignore-repos</code></span>]
    </span></dt><dd><p>
      Ignore all repositories specified so far, in XML or elsewhere. This
      option should be used in conjunction with subsequent calls to
      <code class="option">--add-repo</code> to specify repositories at the command line
      that override previous specifications.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--logfile <em class="replaceable"><code>Filename</code></em></code>
      | <code class="option">terminal</code></span>]
    </span></dt><dd><p>
      Write to the log file <em class="replaceable"><code>Filename</code></em> instead of
      the terminal.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--gzip-cmd <em class="replaceable"><code>cmd</code></em></code></span>]
    </span></dt><dd><p>
      Specify an alternate command to run when compressing boot and system
      images. Command must accept <span class="command"><strong>gzip</strong></span> options.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--package-manager <em class="replaceable"><code>smart|zypper</code></em></code></span>]
    </span></dt><dd><p>
      Set the package manager to use for this image. If set it will
      temporarily overwrite the value set in the xml description.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">-A</code> | <code class="option">--target-arch <em class="replaceable"><code>i586|x86_64|armv5tel|ppc</code></em></code></span>]
    </span></dt><dd><p>
      Set a special target-architecture. This overrides the used
      architecture for the image-packages in <code class="filename">zypp.conf</code>.
      When used with smart this option doesn't have any effect.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--disk-start-sector <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      The start sector value for virtual disk based images. The default is
      2048. For newer disks including SSD this is a reasonable default. In
      order to use the old style disk layout the value can be set to 32.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--disk-sector-size <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      Overwrite the default 512 byte sector size value. This will influence
      the partition alignment.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--disk-alignment <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      Align the start of each partition to the specified value. By default
      4096 bytes are used.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--debug</code></span>]
    </span></dt><dd><p>
      Prints a stack trace in case of internal errors
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--verbose <em class="replaceable"><code>1|2|3</code></em></code></span>]
    </span></dt><dd><p>
      Controls the verbosity level for the instsource module
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">-y</code> | <code class="option">--yes</code></span>]
    </span></dt><dd><p>
      Answer any interactive questions with yes
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--create-instsource <em class="replaceable"><code>path-to-config.xml</code></em></code></span>]
    </span></dt><dd><p>
      Using this option, it is possible to create a valid installation
      repository from blank RPM file trees. The created tree can be used
      directly for the image creation process afterwards.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--bundle-build</code></span>]
    </span></dt><dd><p>
      This option bundles the build results to be suitable for publishing it
      in the Build Service. It allows adding a build-number in combination
      with the <code class="option">--bundle-id</code> option as well as a SHA key to
      the results. It also removes intermediate build results not relevant
      for users if they don't want to rebuild the image.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--bundle-id <em class="replaceable"><code>build-number</code></em></code></span>]
    </span></dt><dd><p>
      The build-number/string in combination with
      <code class="option">--bundle-build</code>
     </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.prepare.options"></a><h2>Image Preparation Options</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">-r</code> | <code class="option">--root
      <em class="replaceable"><code>RootPath</code></em></code></span>]
    </span></dt><dd><p>
      Set up the physical extend, chroot system below the given root-path
      path. If no <code class="option">--root</code> option is given, KIWI will search
      for the attribute defaultroot in <code class="filename">config.xml</code>. If
      no root directory is known, a <span class="command"><strong>mktemp</strong></span> directory will
      be created and used as root directory.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--force-new-root</code></span>]
    </span></dt><dd><p>
      Force creation of new root directory. If the directory already exists,
      it is deleted.
     </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.prepare.upgrade.options"></a><h2>Image Upgrade/Preparation Options</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">--cache</code><em class="replaceable"><code>directory</code></em></span>]
    </span></dt><dd><p>
      When specifying a cache directory, KIWI will create a cache each for
      patterns and packages and re-use them, if possible, for subsequent
      root tree preparations of this and/or other images
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--init-cache</code><em class="replaceable"><code>image description</code></em></span>]
    </span></dt><dd><p>
      Creates a cache from a KIWI image description.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--recycle-root</code></span>]
    </span></dt><dd><p>
      Uses an existing root tree and base the kiwi prepare step on top of
      it. This is used to speed things up.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--force-bootstrap</code></span>]
    </span></dt><dd><p>
      In combination with recycle-root this option forces to call the
      bootstrap phase of kiwi, which is not considered necessary under
      normal circumstances.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--add-package</code><em class="replaceable"><code>package</code></em></span>]
    </span></dt><dd><p>
      Add the given package name to the list of image packages multiple
      <code class="option">--add-package</code> options are possible. The change will
      not be written to the XML description.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--add-pattern</code><em class="replaceable"><code>name</code></em></span>]
    </span></dt><dd><p>
      Add the given pattern name to the list of image packages multiple
      <code class="option">--add-pattern</code> options are possible. The change will
      not be written to the xml description. Patterns can be handled by SUSE
      based repositories only.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--del-package</code><em class="replaceable"><code>package</code></em></span>]
    </span></dt><dd><p>
      Removes the given package by adding it the list of packages to become
      removed. The change will not be written to the xml description.
     </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.create.options"></a><h2>Image Creation Options</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional"><code class="option">-d</code> | <code class="option">--destdir
      <em class="replaceable"><code>DestinationPath</code></em></code></span>]
    </span></dt><dd><p>
      Specify destination directory to store the image file(s) If not
      specified, KIWI will try to find the attribute
      <em class="replaceable"><code>defaultdestination</code></em> which can be specified
      in the <em class="replaceable"><code>preferences</code></em> section of the
      <code class="filename">config.xml</code> file. If it exists its value is used
      as destination directory. If no destination information can be found,
      an error occurs.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">-t</code> | <code class="option">--type
      <em class="replaceable"><code>Imagetype</code></em></code></span>]
    </span></dt><dd><p>
      Specify the output image type to use for this image. Each type is
      described in a <em class="replaceable"><code>type</code></em> section of the
      preferences section. At least one type needs to be specified in the
      <code class="filename">config.xml</code> description. By default, the types
      specifying the <span class="emphasis"><em>primary</em></span> attribute will be used. If
      there is no primary attribute set, the first type section of the
      preferences section is the primary type. The types are only evaluated
      when KIWI runs the <code class="option">--create</code> step. With the option
      <code class="option">--type</code> one can distinguish between the types stored
      in <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">-s</code> | <code class="option">--strip</code></span>]
    </span></dt><dd><p>
      Strip shared objects and executables - only makes sense in combination
      with <code class="option">--create</code>
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--prebuiltbootimage
      <em class="replaceable"><code>Directory</code></em></code></span>]
    </span></dt><dd><p>
      Search in <em class="replaceable"><code>Directory</code></em> for pre-built boot
      images.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--isocheck</code></span>]
    </span></dt><dd><p>
      in case of an iso image the checkmedia program generates a md5sum into
      the ISO header. If the <code class="option">--isocheck</code> option is specified
      a new boot menu entry will be generated which allows to check this
      media
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--lvm</code></span>]
    </span></dt><dd><p>
      Use the logical volume manager to control the disk. The partition
      table will include one lvm partition and one standard ext2 boot
      partition. Use of this option makes sense for the create step only and
      also only for the image types: vmx, oem, and usb
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-blocksize <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      When calling KIWI in creation mode this option will set the block size
      in bytes. For ISO images with the old style ramdisk setup a block size
      of 4096 bytes is required
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-journalsize <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      When calling KIWI in creation mode this option will set the journal
      size in mega bytes for ext[23] based file systems and in blocks if the
      Reiser file system is used
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-inodesize <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      When calling KIWI in creation mode this option will set the inode size
      in bytes. This option has no effect if the Reiser file system is used
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-inoderatio <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      Set the bytes/inode ratio. This option has no effect if the Reiser
      file system is used
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-max-mount-count <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      When calling kiwi in creation mode this option will set the number of
      mounts after which the file system will be checked. Set to 0 to disable
      checks. This option applies only to ext[234] file systems.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-check-interval <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      When calling kiwi in creation mode this option will set the maximal
      time between two file system checks. Set to 0 to disable time-dependent
      checks. This option applies only to ext[234] file systems.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fat-storage <em class="replaceable"><code>size in MB</code></em></code></span>]
    </span></dt><dd><p>
      if the syslinux boatload is used this option allows to specify the
      size of the fat partition. This is useful if the fat space is not only
      used for booting the system but also for custom data. Therefore this
      option makes sense when building a USB stick image (image type: usb or
      oem)
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--partitioner <em class="replaceable"><code>parted|fdasd</code></em></code></span>]
    </span></dt><dd><p>
      Select the tool to create partition tables. Supported are parted and
      fdasd (s390). By default parted is used
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--check-kernel</code></span>]
    </span></dt><dd><p>
      Activates check for matching kernels between boot and system image.
      The kernel check also tries to fix the boot image if no matching
      kernel was found.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--mbrid <em class="replaceable"><code>number</code></em></code></span>]
    </span></dt><dd><p>
      Specifies a custom mbrid. The number value is treated as decimal
      number which is internally translated into a 4byte hex value. The
      allowed range therefore is from 0x0 to max 0xffffffff. By default kiwi
      creates a random value
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--edit-bootconfig <em class="replaceable"><code>script</code></em></code></span>]
    </span></dt><dd><p>
      Specifies the location of a custom script which is called right before
      the boot loader is installed. This allows to modify the boot loader
      configuration file written by kiwi. The scripts working directory is
      the one which represents the image structure including the boot loader
      configuration files. Please have in mind that according to the image
      type, architecture and boot loader type the files/directory structure
      and also the name of the boot loader configuration files might be
      different.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--edit-bootinstall <em class="replaceable"><code>script</code></em></code></span>]
    </span></dt><dd><p>
      Specifies the location of a custom script which is called right after
      the boot loader is installed.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--archive-image</code></span>]
    </span></dt><dd><p>
      When calling kiwi <code class="option">--create</code> this option allows to pack
      the build result(s) into a tar archive.
     </p></dd><dt><span class="term">[<span class="optional"><code class="option">--targetdevice</code><em class="replaceable"><code>device</code></em></span>]
    </span></dt><dd><p>
      Use an alternative block device instead of the loop device.
      The given location must be a block device node, not a symlink or
      other linux device node type.
     </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.moreinfo"></a><h2>For More Information</h2><p>
   More information about KIWI, its files can be found at:
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a class="ulink" href="https://opensuse.github.io/kiwi/" target="_top">https://opensuse.github.io/kiwi/</a>
    </span></dt><dd><p>
      KIWI wiki
     </p></dd><dt><span class="term"><code class="filename">config.xml</code>
    </span></dt><dd><p>
      The configuration XML file that contains every aspect for the image
      creation.
     </p></dd><dt><span class="term"><a class="ulink" href="file:///usr/share/doc/packages/kiwi/kiwi.pdf" target="_top">file:///usr/share/doc/packages/kiwi/kiwi.pdf</a>
    </span></dt><dd><p>
      The system documentation which describes the supported image types in
      detail.
     </p></dd><dt><span class="term"><a class="ulink" href="file:///usr/share/doc/packages/kiwi/schema/kiwi.xsd.html" target="_top">file:///usr/share/doc/packages/kiwi/schema/kiwi.xsd.html</a>
    </span></dt><dd><p>
      The KIWI RELAX NG XML Schema documentation.
     </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="ref.kiwi.config.sh"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi::config.sh</span></h2><p>KIWI::config.sh — Customization File for KIWI image description</p></div><div class="refsect1"><a name="kiwi.config.description"></a><h2>Description</h2><p>
   The KIWI image description allows to have an optional
   <code class="filename">config.sh</code> bash script in place. It can be used for
   changes appropriate for all images to be created from a given unpacked
   image (since config.sh runs prior to create step) Basically the script
   should be designed to take over control of adding the image operating
   system configuration. Configuration in that sense means all tasks which
   runs once in an os installation process like activating services,
   creating configuration files, prepare an environment for a firstboot
   workflow, etc. The <code class="filename">config.sh</code> script is called
   <span class="emphasis"><em>after</em></span> the following kiwi built in configuration
   tasks: User/Groups, copy of overlay root tree and setup of AutoYaST If
   <code class="filename">config.sh</code> exits with an exit code != 0 the kiwi
   process will exit with an error too.
  </p><div class="example"><a name="idm139781526761824"></a><p class="title"><b>Example A.1. Template for config.sh</b></p><div class="example-contents"><pre class="programlisting">
#======================================
# Functions...
#--------------------------------------
test -f /.kconfig &amp;&amp; . /.kconfig
test -f /.profile &amp;&amp; . /.profile

#======================================
# Greeting...
#--------------------------------------
echo "Configure image: [$kiwi_iname]..."

#======================================
# Mount system filesystems
#--------------------------------------
baseMount

#======================================
# Call configuration code/functions
#--------------------------------------
...

#======================================
# Umount kernel filesystems
#--------------------------------------
baseCleanMount

#======================================
# Exit safely
#--------------------------------------
exit 0</pre></div></div><br class="example-break"></div><div class="refsect1"><a name="kiwi.config.functions"></a><h2>Common functions</h2><p>
   The <code class="filename">.kconfig</code> file allows to make use of a common set
   of functions. Functions specific to SUSE Linux specific begin with the
   name <span class="emphasis"><em>suse</em></span>. Functions applicable to all linux systems
   starts with the name <span class="emphasis"><em>base</em></span>. The following list
   describes the functions available inside the
   <code class="filename">config.sh</code> script.
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional">baseCleanMount</span>]
    </span></dt><dd><p>
      Umount the system filesystems <code class="filename">/proc</code>,
      <code class="filename">/dev/pts</code>, and <code class="filename">/sys</code>.
     </p></dd><dt><span class="term">[<span class="optional">baseDisableCtrlAltDel</span>]
    </span></dt><dd><p>
      Disable the <span class="keycap"><strong>Ctrl</strong></span>-<span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>Del</strong></span> key sequence
      setting in <code class="filename">/etc/inittab</code>
     </p></dd><dt><span class="term">[<span class="optional">baseGetPackagesForDeletion</span>]
    </span></dt><dd><p>
      Return the name(s) of packages which will be deleted
     </p></dd><dt><span class="term">[<span class="optional">baseGetProfilesUsed</span>]
    </span></dt><dd><p>
      Return the name(s) of profiles used to build this image
     </p></dd><dt><span class="term">[<span class="optional">baseSetRunlevel {value}</span>]
    </span></dt><dd><p>
      Set the default run level
     </p></dd><dt><span class="term">[<span class="optional">baseSetupBoot</span>]
    </span></dt><dd><p>
      Set up the linuxrc as init
     </p></dd><dt><span class="term">[<span class="optional">baseSetupBusyBox {-f}</span>]
    </span></dt><dd><p>
      activates busybox if installed for all links from the
      <code class="filename">busybox/busybox.links</code> file—you can choose
      custom apps to be forced into busybox with the <code class="option">-f</code>
      option as first parameter, for example:
     </p><pre class="screen">baseSetupBusyBox -f /bin/zcat /bin/vi</pre></dd><dt><span class="term">[<span class="optional">baseSetupInPlaceGITRepository</span>]
    </span></dt><dd><p>
      Create an in place git repository of the root directory. This process
      may take some time and you may expect problems with binary data
      handling
     </p></dd><dt><span class="term">[<span class="optional">baseSetupInPlaceSVNRepository {path_list}</span>]
    </span></dt><dd><p>
      Create an in place subversion repository for the specified
      directories. A standard call could look like this
      baseSetupInPlaceSVNRepository <code class="filename">/etc</code>,
      <code class="filename">/srv</code>, and <code class="filename">/var/log</code>
     </p></dd><dt><span class="term">[<span class="optional">baseSetupPlainTextGITRepository</span>]
    </span></dt><dd><p>
      Create an in place git repository of the root directory containing all
      plain/text files.
     </p></dd><dt><span class="term">[<span class="optional">baseSetupUserPermissions</span>]
    </span></dt><dd><p>
      Search all home directories of all users listed in
      <code class="filename">/etc/passwd</code> and change the ownership of all files
      to belong to the correct user and group.
     </p></dd><dt><span class="term">[<span class="optional">baseStripAndKeep {list of info-files to keep}</span>]
    </span></dt><dd><p>
      helper function for strip* functions read stdin lines of files to
      check for removing params: files which should be keep
     </p></dd><dt><span class="term">[<span class="optional">baseStripDocs {list of docu names to keep}</span>]
    </span></dt><dd><p>
      remove all documentation, except one given as parameter
     </p></dd><dt><span class="term">[<span class="optional">baseStripInfos {list of info-files to keep}</span>]
    </span></dt><dd><p>
      remove all info files, except one given as parameter
     </p></dd><dt><span class="term">[<span class="optional">baseStripLocales {list of locales}</span>]
    </span></dt><dd><p>
      remove all locales, except one given as parameter
     </p></dd><dt><span class="term">[<span class="optional">baseStripMans {list of manpages to keep}</span>]
    </span></dt><dd><p>
      remove all manual pages, except one given as parameter example:
      baseStripMans more less
     </p></dd><dt><span class="term">[<span class="optional">baseStripRPM</span>]
    </span></dt><dd><p>
      remove rpms defined in <code class="filename">config.xml</code> in the image
      type=delete section
     </p></dd><dt><span class="term">[<span class="optional">suseRemovePackagesMarkedForDeletion</span>]
    </span></dt><dd><p>
      remove rpms defined in <code class="filename">config.xml</code> in the image
      type=delete section. The difference compared to baseStripRPM is that
      the suse variant checks if the package is really installed prior to
      passing it to rpm to uninstall it. The suse rpm exits with an error
      exit code while there are other rpm version which just ignore if an
      uninstall request was set on a package which is not installed
     </p></dd><dt><span class="term">[<span class="optional">baseStripTools {list of toolpath} {list of tools}</span>]
    </span></dt><dd><p>
      helper function for suseStripInitrd function params: toolpath, tools
     </p></dd><dt><span class="term">[<span class="optional">baseStripUnusedLibs</span>]
    </span></dt><dd><p>
      remove libraries which are not directly linked against applications in
      the bin directories
     </p></dd><dt><span class="term">[<span class="optional">baseUpdateSysConfig {filename} {variable} {value}</span>]
    </span></dt><dd><p>
      update sysconfig variable contents
     </p></dd><dt><span class="term">[<span class="optional">Debug {message}</span>]
    </span></dt><dd><p>
      Helper function to print a message if the variable
      <code class="varname">DEBUG</code> is set to 1
     </p></dd><dt><span class="term">[<span class="optional">Echo {echo commandline}</span>]
    </span></dt><dd><p>
      Helper function to print a message to the controlling terminal
     </p></dd><dt><span class="term">[<span class="optional">Rm {list of files}</span>]
    </span></dt><dd><p>
      Helper function to delete files and announce it to log
     </p></dd><dt><span class="term">[<span class="optional">Rpm {rpm commandline}</span>]
    </span></dt><dd><p>
      Helper function to the RPM function and announce it to log
     </p></dd><dt><span class="term">[<span class="optional">suseConfig</span>]
    </span></dt><dd><p>
      Setup keytable language, timezone and hwclock if specified in
      <code class="filename">config.xml</code> and call SuSEconfig afterwards
      SuSEconfig is only called on systems which still support it
     </p></dd><dt><span class="term">[<span class="optional">suseInsertService {servicename}</span>]
    </span></dt><dd><p>
      This function calls baseInsertService and exists only for
      compatibility reasons
     </p></dd><dt><span class="term">[<span class="optional">suseRemoveService {servicename}</span>]
    </span></dt><dd><p>
      This function calls baseRemoveService and exists only for
      compatibility reasons
     </p></dd><dt><span class="term">[<span class="optional">baseInsertService {servicename}</span>]
    </span></dt><dd><p>
      Activate the given service by using the chkconfig or systemctl
      program. Which init system is in use is auto detected
     </p></dd><dt><span class="term">[<span class="optional">baseRemoveService {servicename}</span>]
    </span></dt><dd><p>
      Deactivate the given service by using the chkconfig or systemctl
      program. Which init system is in use is auto detected
     </p></dd><dt><span class="term">[<span class="optional">baseService {servicename} {on|off}</span>]
    </span></dt><dd><p>
      Activate/Deactivate a service by using the chkconfig or systemctl
      program. The function requires the service name and the value on or
      off as parameters. Which init system is in use is auto detected
     </p></dd><dt><span class="term">[<span class="optional">suseActivateDefaultServices</span>]
    </span></dt><dd><p>
      Activates the following sysVInit services to be on by default using
      the chkconfig program: boot.rootfsck, boot.cleanup, boot.localfs,
      boot.localnet, boot.clock, policykitd, dbus, consolekit, haldaemon,
      network, atd, syslog, cron, kbd. And the following for systemd
      systems: network, cron
     </p></dd><dt><span class="term">[<span class="optional">suseSetupProduct</span>]
    </span></dt><dd><p>
      This function creates the baseproduct link in /etc/products.d pointing
      to the installed product
     </p></dd><dt><span class="term">[<span class="optional">suseSetupProductInformation</span>]
    </span></dt><dd><p>
      This function will use zypper to search for the installed product and
      install all product specific packages. This function only makes sense
      if zypper is used as package manager
     </p></dd><dt><span class="term">[<span class="optional">suseStripPackager {-a}</span>]
    </span></dt><dd><p>
      Remove smart or zypper packages and db files Also remove rpm package
      and db if <code class="option">-a</code> given
     </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.config.environment"></a><h2>Profile environment variables</h2><p>
   The .profile environment file contains a specific set of variables which
   are listed below. Some of the functions above use the variables.
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional">$kiwi_compressed</span>]
    </span></dt><dd><p>
      The value of the compressed attribute set in the type element in
      <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_delete</span>]
    </span></dt><dd><p>
      A list of all packages which are part of the packages section with
      <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781526663984"></a>="<code class="sgmltag-attvalue">delete</code>"
      in <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_drivers</span>]
    </span></dt><dd><p>
      A comma separated list of the driver entries as listed in the drivers
      section of the <code class="filename">config.xml</code>.
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_iname</span>]
    </span></dt><dd><p>
      The name of the image as listed in <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_iversion</span>]
    </span></dt><dd><p>
      The image version string major.minor.release
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_keytable</span>]
    </span></dt><dd><p>
      The contents of the keytable setup as done in
      <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_language</span>]
    </span></dt><dd><p>
      The contents of the locale setup as done in
      <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_profiles</span>]
    </span></dt><dd><p>
      A list of profiles used to build this image
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_size</span>]
    </span></dt><dd><p>
      The predefined size value for this image. This is not the computed
      size but only the optional size value of the preferences section in
      <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_timezone</span>]
    </span></dt><dd><p>
      The contents of the timezone setup as done in
      <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_type</span>]
    </span></dt><dd><p>
      The basic image type. Can be a simply file system image type of ext2,
      ext3, reiserfs, squashfs, cpio, or one of the following complex image
      types: iso, split, usb, vmx, oem, xen, or pxe.
     </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="ref.kiwi.images.sh"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi::images.sh</span></h2><p>KIWI::images.sh — Customization File for KIWI image description</p></div><div class="refsect1"><a name="kiwi.images.description"></a><h2>Description</h2><p>
   The KIWI image description allows to have an optional
   <code class="filename">images.sh</code> bash script in place. It can be used for
   changes appropriate for certain images/image types on case-by-case basis
   (since it runs at beginning of create step) Basically the script should
   be designed to take over control of handling image type specific tasks.
   For example if building the oem type requires some additional package or
   config it can be handled in images.sh. Please keep in mind there is only
   one unpacked root tree the script operates in. This means all changes are
   permanent and will not be automatically restored. It is also the script
   authors tasks to check if changes done before do not interfere in a
   negative way if another image type is created from the same unpacked
   image root tree If <code class="filename">images.sh</code> exits with an exit code
   != 0 the kiwi process will exit with an error too.
  </p><div class="example"><a name="idm139781526625296"></a><p class="title"><b>Example A.2. Template for images.sh</b></p><div class="example-contents"><pre class="programlisting">#======================================
# Functions...
#--------------------------------------
test -f /.kconfig &amp;&amp; . /.kconfig
test -f /.profile &amp;&amp; . /.profile

#======================================
# Greeting...
#--------------------------------------
echo "Configure image: [$kiwi_iname]..."

#======================================
# Call configuration code/functions
#--------------------------------------
...

#======================================
# Exit safely
#--------------------------------------
exit</pre></div></div><br class="example-break"></div><div class="refsect1"><a name="kiwi.image.functions"></a><h2>Common functions</h2><p>
   The <code class="filename">.kconfig</code> file allows to make use of a common set
   of functions. Functions specific to SUSE Linux specific begin with the
   name <span class="emphasis"><em>suse</em></span>. Functions applicable to all linux systems
   starts with the name <span class="emphasis"><em>base</em></span>. The following list
   describes the functions available inside the
   <code class="filename">images.sh</code> script.
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional">baseCleanMount</span>]
    </span></dt><dd><p>
      Umount the system file systems <code class="filename">/proc</code>,
      <code class="filename">/dev/pts</code>, and <code class="filename">/sys</code>.
     </p></dd><dt><span class="term">[<span class="optional">baseGetProfilesUsed</span>]
    </span></dt><dd><p>
      Return the name(s) of profiles used to build this image.
     </p></dd><dt><span class="term">[<span class="optional">baseGetPackagesForDeletion</span>]
    </span></dt><dd><p>
      Return the list of packages setup in the packages
      <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781526610176"></a>="<code class="sgmltag-attvalue">delete</code>"
      section of the <code class="filename">config.xml</code> used to build this
      image.
     </p></dd><dt><span class="term">[<span class="optional">suseGFXBoot {theme} {loadertype}</span>]
    </span></dt><dd><p>
      This function requires the gfxboot and at least one bootsplash-theme-*
      package to be installed to work correctly. The function
      creates from this package data a graphics boot screen for the isolinux
      and grub boot loaders. Additionally it creates the bootsplash files
      for the resolutions 800x600, 1024x768, and 1280x1024
     </p></dd><dt><span class="term">[<span class="optional">suseStripKernel</span>]
    </span></dt><dd><p>
      This function removes all kernel drivers which are not listed in the
      *drivers sections of the <code class="filename">config.xml</code> file.
     </p></dd><dt><span class="term">[<span class="optional">suseStripInitrd</span>]
    </span></dt><dd><p>
      This function removes a whole bunch of tools binaries and libraries
      which are not required to boot a suse system with KIWI.
     </p></dd><dt><span class="term">[<span class="optional">Rm {list of files}</span>]
    </span></dt><dd><p>
      Helper function to delete files and announce it to log.
     </p></dd><dt><span class="term">[<span class="optional">Rpm {rpm commandline}</span>]
    </span></dt><dd><p>
      Helper function to the rpm function and announce it to log.
     </p></dd><dt><span class="term">[<span class="optional">Echo {echo commandline}</span>]
    </span></dt><dd><p>
      Helper function to print a message to the controlling terminal.
     </p></dd><dt><span class="term">[<span class="optional">Debug {message}</span>]
    </span></dt><dd><p>
      Helper function to print a message if the variable
      <code class="varname">DEBUG</code> is set to 1.
     </p></dd></dl></div></div><div class="refsect1"><a name="kiwi.images.environment"></a><h2>Profile environment variables</h2><p>
   The .profile environment file contains a specific set of variables which
   are listed below. Some of the functions above use the variables.
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional">$kiwi_iname</span>]
    </span></dt><dd><p>
      The name of the image as listed in config.xml
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_iversion</span>]
    </span></dt><dd><p>
      The image version string major.minor.release
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_keytable</span>]
    </span></dt><dd><p>
      The contents of the keytable setup as done in
      <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_language</span>]
    </span></dt><dd><p>
      The contents of the locale setup as done in
      <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_timezone</span>]
    </span></dt><dd><p>
      The contents of the timezone setup as done in
      <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_delete</span>]
    </span></dt><dd><p>
      A list of all packages which are part of the packages section with
      <code class="sgmltag-attribute">type</code><a class="indexterm" name="idm139781526576432"></a>="<code class="sgmltag-attvalue">delete</code>"
      in <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_profiles</span>]
    </span></dt><dd><p>
      A list of profiles used to build this image
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_drivers</span>]
    </span></dt><dd><p>
      A comma separated list of the driver entries as listed in the drivers
      section of the <code class="filename">config.xml</code>.
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_size</span>]
    </span></dt><dd><p>
      The predefined size value for this image. This is not the computed
      size but only the optional size value of the preferences section in
      <code class="filename">config.xml</code>
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_compressed</span>]
    </span></dt><dd><p>
      The value of the compressed attribute set in the type element in
      config.xml
     </p></dd><dt><span class="term">[<span class="optional">$kiwi_type</span>]
    </span></dt><dd><p>
      The basic image type. Can be a simply file system image type of ext2,
      ext3, reiserfs, squashfs, and cpio or one of the following complex
      image types: iso split usb vmx oem xen pxe
     </p></dd></dl></div></div></div><div class="refentry"><div class="refentry.separator"><hr></div><a name="ref.kiwi.kiwirc"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi::kiwirc</span></h2><p>KIWI::kiwirc — Resource file for the Kiwi imaging system</p></div><div class="refsect1"><a name="kiwi.kiwirc.description"></a><h2>Description</h2><p>
   The KIWI imaging tool chain supports the use of an optional resource file
   named <code class="filename">.kiwirc</code> located in the users home directory.
  </p><p>
   The file is sourced by a Perl process and thus Perl compatible syntax for
   the supported variable settings is required.
  </p><div class="example"><a name="idm139781526549600"></a><p class="title"><b>Example A.3. Template for .kiwi.rc</b></p><div class="example-contents"><pre class="screen">$BasePath='/usr/share/kiwi';
$Gzip='bzip2';
$LogServerPort='4455';
$System='/usr/share/kiwi/image';</pre></div></div><br class="example-break"></div><div class="refsect1"><a name="kiwi.kiwirc.settings"></a><h2>Supported Resource Settings</h2><p>
   KIWI recognizes the BasePath, Gzip, LogServerPort, LuksCipher, and System
   settings in the <code class="filename">.kiwirc</code> file.
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">[<span class="optional">BasePath</span>]
    </span></dt><dd><p>
      Path to the location of the KIWI image system components, such as
      modules, tests, image descriptions etc.
     </p><p>
      The default value is <code class="filename">/usr/share/kiwi</code>
     </p></dd><dt><span class="term">[<span class="optional">Gzip</span>]
    </span></dt><dd><p>
      Specify the compression utility to be used for various compression
      tasks during image generation.
     </p><p>
      The default value is <span class="command"><strong>gzip</strong></span> <code class="option">-9</code>
     </p></dd><dt><span class="term">[<span class="optional">LogServerPort</span>]
    </span></dt><dd><p>
      Specify a port number for log message queuing.
     </p><p>
      The default value is off
     </p></dd><dt><span class="term">[<span class="optional">LuksCipher</span>]
    </span></dt><dd><p>
      Specify the cipher for the encrypted Luks file system.
     </p></dd><dt><span class="term">[<span class="optional">System</span>]
    </span></dt><dd><p>
      Specify the location of the KIWI system image description.
     </p><p>
      The default value is the value of BasePath concatenated with /image.
     </p></dd></dl></div></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="app.bootserver"></a>Appendix B. Setting Up a Network Boot Server</h1></div></div></div><p>
  To be able to deploy PXE bot images created with KIWI, you need to
  set up a network boot server providing the services DHCP and atftp.
 </p><div class="procedure"><a name="proc.pxe.atftp-server-setup"></a><p class="title"><b>Procedure B.1. Installing and Configuring atftp</b><span class="permalink"><a alt="Permalink" title="Procedure B.1. Installing and Configuring atftp" href="#proc.pxe.atftp-server-setup">¶</a></span></p><ol class="procedure" type="1"><li class="step"><p>
    Install the packages <span class="package">atftp</span> and
    <span class="package">kiwi-pxeboot</span>.
   </p></li><li class="step"><p>
    Edit the file <code class="filename">/etc/sysconfig/atftpd</code>. Set or modify
    the following variables:
   </p><pre class="screen">ATFTPD_OPTIONS="--daemon --no-multicast"
ATFTPD_DIRECTORY="/srv/tftpboot"</pre></li><li class="step"><p>
    Start the <code class="systemitem">atftpd</code><a class="indexterm" name="idm139781526522528"></a> service by
    running:
   </p><pre class="screen">systemctl start atftpd</pre></li></ol></div><div class="procedure"><a name="idm139781526520304"></a><p class="title"><b>Procedure B.2. Installing and Configuring DHCP</b></p><p>
   Contrary to the atftp server setup the following instructions can only
   serve as an example. Depending on your network structure, the IP addresses,
   ranges and domain settings need to be adapted to allow the DHCP server to
   work within your network. If you already have a DHCP server running in your
   network, make sure that the <code class="literal">filename</code> and
   <code class="literal">next-server</code> are correctly set in
   <code class="filename">/etc/dhcpd.conf</code> on this server.
  </p><p>
    The following steps describe how to set up a new DHCP server instance:
  </p><ol class="procedure" type="1"><li class="step"><p>
      Install the package <span class="package">dhcp-server</span>.
     </p></li><li class="step"><p>
      Create the file <code class="filename">/etc/dhcpd.conf</code> and include the
      following statements. Note that all <span class="emphasis"><em>values</em></span> listed
      below are examples, make sure to replace them with data fitting your
      network setup.
     </p><pre class="screen">option domain-name "example.org";
option domain-name-servers 192.168.100.2;
option broadcast-address 192.168.100.255;
option routers 192.168.100.2;
option subnet-mask 255.255.255.0;
default-lease-time 600;
max-lease-time 7200;
ddns-update-style none; ddns-updates off;
log-facility local7;

subnet 192.168.100.0 netmask 255.255.255.0 {
   filename "pxelinux.0";
   next-server 192.168.100.2;
   range dynamic-bootp 192.168.100.5 192.168.100.20;
}</pre></li><li class="step"><p>
      Edit the file <code class="filename">/etc/sysconfig/dhcpd</code> and setup the
      network interface the server should listen on:
     </p><pre class="screen">DHCPD_INTERFACE="eth0"</pre></li><li class="step"><p>
      Run the <code class="systemitem">dhcp</code><a class="indexterm" name="idm139781526506992"></a> server by
      calling:
     </p><pre class="screen">systemctl start wickedd-dhcp4</pre></li></ol></div></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a name="idm139781526504624"></a>Appendix C. GNU Licenses</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="#idm139781526503200">C.1. GNU Free Documentation License</a></span></dt></dl></div><p>
  This appendix contains the GNU Free Documentation License version 1.2.
 </p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm139781526503200"></a>C.1. GNU Free Documentation License<span class="permalink"><a alt="Permalink" title="C.1. GNU Free Documentation License" href="#idm139781526503200">¶</a></span></h2></div></div></div><p>
   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc. 51 Franklin
   St, Fifth Floor, Boston, MA 02110-1301 USA. Everyone is permitted to copy
   and distribute verbatim copies of this license document, but changing it
   is not allowed.
  </p><h5><a name="idm139781526501584"></a>
   0. PREAMBLE
  </h5><p>
   The purpose of this License is to make a manual, textbook, or other
   functional and useful document "free" in the sense of freedom: to assure
   everyone the effective freedom to copy and redistribute it, with or
   without modifying it, either commercially or noncommercially. Secondarily,
   this License preserves for the author and publisher a way to get credit
   for their work, while not being considered responsible for modifications
   made by others.
  </p><p>
   This License is a kind of "copyleft", which means that derivative works of
   the document must themselves be free in the same sense. It complements the
   GNU General Public License, which is a copyleft license designed for free
   software.
  </p><p>
   We have designed this License to use it for manuals for free
   software, because free software needs free documentation: a free program
   should come with manuals providing the same freedoms that the software
   does. But this License is not limited to software manuals; it can be used
   for any textual work, regardless of subject matter or whether it is
   published as a printed book. We recommend this License principally for
   works whose purpose is instruction or reference.
  </p><h5><a name="idm139781526498000"></a>
   1. APPLICABILITY AND DEFINITIONS
  </h5><p>
   This License applies to any manual or other work, in any medium, that
   contains a notice placed by the copyright holder saying it can be
   distributed under the terms of this License. Such a notice grants a
   world-wide, royalty-free license, unlimited in duration, to use that work
   under the conditions stated herein. The "Document", below, refers to any
   such manual or work. Any member of the public is a licensee, and is
   addressed as "you". You accept the license if you copy, modify or
   distribute the work in a way requiring permission under copyright law.
  </p><p>
   A "Modified Version" of the Document means any work containing the
   Document or a portion of it, either copied verbatim, or with modifications
   and/or translated into another language.
  </p><p>
   A "Secondary Section" is a named appendix or a front-matter section of the
   Document that deals exclusively with the relationship of the publishers or
   authors of the Document to the Document's overall subject (or to related
   matters) and contains nothing that could fall directly within that overall
   subject. (Thus, if the Document is in part a textbook of mathematics, a
   Secondary Section may not explain any mathematics.) The relationship could
   be a matter of historical connection with the subject or with related
   matters, or of legal, commercial, philosophical, ethical or political
   position regarding them.
  </p><p>
   The "Invariant Sections" are certain Secondary Sections whose titles are
   designated, as being those of Invariant Sections, in the notice that says
   that the Document is released under this License. If a section does not
   fit the above definition of Secondary then it is not allowed to be
   designated as Invariant. The Document may contain zero Invariant Sections.
   If the Document does not identify any Invariant Sections then there are
   none.
  </p><p>
   The "Cover Texts" are certain short passages of text that are listed, as
   Front-Cover Texts or Back-Cover Texts, in the notice that says that the
   Document is released under this License. A Front-Cover Text may be at most
   5 words, and a Back-Cover Text may be at most 25 words.
  </p><p>
   A "Transparent" copy of the Document means a machine-readable copy,
   represented in a format whose specification is available to the general
   public, that is suitable for revising the document straightforwardly with
   generic text editors or (for images composed of pixels) generic paint
   programs or (for drawings) some widely available drawing editor, and that
   is suitable for input to text formatters or for automatic translation to a
   variety of formats suitable for input to text formatters. A copy made in
   an otherwise Transparent file format whose markup, or absence of markup,
   has been arranged to thwart or discourage subsequent modification by
   readers is not Transparent. An image format is not Transparent if used for
   any substantial amount of text. A copy that is not "Transparent" is called
   "Opaque".
  </p><p>
   Examples of suitable formats for Transparent copies include plain ASCII
   without markup, Texinfo input format, LaTeX input format, SGML or XML
   using a publicly available DTD, and standard-conforming simple HTML,
   PostScript or PDF designed for human modification. Examples of transparent
   image formats include PNG, XCF and JPG. Opaque formats include proprietary
   formats that can be read and edited only by proprietary word processors,
   SGML or XML for which the DTD and/or processing tools are not generally
   available, and the machine-generated HTML, PostScript or PDF produced by
   some word processors for output purposes only.
  </p><p>
   The "Title Page" means, for a printed book, the title page itself, plus
   such following pages as are needed to hold, legibly, the material this
   License requires to appear in the title page. For works in formats which
   do not have any title page as such, "Title Page" means the text near the
   most prominent appearance of the work's title, preceding the beginning of
   the body of the text.
  </p><p>
   A section "Entitled XYZ" means a named subunit of the Document whose title
   either is precisely XYZ or contains XYZ in parentheses following text that
   translates XYZ in another language. (Here XYZ stands for a specific
   section name mentioned below, such as "Acknowledgements", "Dedications",
   "Endorsements", or "History".) To "Preserve the Title" of such a section
   when you modify the Document means that it remains a section "Entitled
   XYZ" according to this definition.
  </p><p>
   The Document may include Warranty Disclaimers next to the notice which
   states that this License applies to the Document. These Warranty
   Disclaimers are considered to be included by reference in this License,
   but only as regards disclaiming warranties: any other implication that
   these Warranty Disclaimers may have is void and has no effect on the
   meaning of this License.
  </p><h5><a name="idm139781526487680"></a>
   2. VERBATIM COPYING
  </h5><p>
   You may copy and distribute the Document in any medium, either
   commercially or noncommercially, provided that this License, the copyright
   notices, and the license notice saying this License applies to the
   Document are reproduced in all copies, and that you add no other
   conditions whatsoever to those of this License. You may not use technical
   measures to obstruct or control the reading or further copying of the
   copies you make or distribute. However, you may accept compensation in
   exchange for copies. If you distribute a large enough number of copies you
   must also follow the conditions in section 3.
  </p><p>
   You may also lend copies, under the same conditions stated above, and you
   may publicly display copies.
  </p><h5><a name="idm139781526485424"></a>
   3. COPYING IN QUANTITY
  </h5><p>
   If you publish printed copies (or copies in media that commonly have
   printed covers) of the Document, numbering more than 100, and the
   Document's license notice requires Cover Texts, you must enclose the
   copies in covers that carry, clearly and legibly, all these Cover Texts:
   Front-Cover Texts on the front cover, and Back-Cover Texts on the back
   cover. Both covers must also clearly and legibly identify you as the
   publisher of these copies. The front cover must present the full title
   with all words of the title equally prominent and visible. You may add
   other material on the covers in addition. Copying with changes limited to
   the covers, as long as they preserve the title of the Document and satisfy
   these conditions, can be treated as verbatim copying in other respects.
  </p><p>
   If the required texts for either cover are too voluminous to fit legibly,
   you should put the first ones listed (as many as fit reasonably) on the
   actual cover, and continue the rest onto adjacent pages.
  </p><p>
   If you publish or distribute Opaque copies of the Document numbering more
   than 100, you must either include a machine-readable Transparent copy
   along with each Opaque copy, or state in or with each Opaque copy a
   computer-network location from which the general network-using public has
   access to download using public-standard network protocols a complete
   Transparent copy of the Document, free of added material. If you use the
   latter option, you must take reasonably prudent steps, when you begin
   distribution of Opaque copies in quantity, to ensure that this Transparent
   copy will remain thus accessible at the stated location until at least one
   year after the last time you distribute an Opaque copy (directly or
   through your agents or retailers) of that edition to the public.
  </p><p>
   It is requested, but not required, that you contact the authors of the
   Document well before redistributing any large number of copies, to give
   them a chance to provide you with an updated version of the Document.
  </p><h5><a name="idm139781526480240"></a>
   4. MODIFICATIONS
  </h5><p>
   You may copy and distribute a Modified Version of the Document under the
   conditions of sections 2 and 3 above, provided that you release the
   Modified Version under precisely this License, with the Modified Version
   filling the role of the Document, thus licensing distribution and
   modification of the Modified Version to whoever possesses a copy of it. In
   addition, you must do these things in the Modified Version:
  </p><div class="orderedlist"><ol class="orderedlist" type="A"><li class="listitem"><p>
     Use in the Title Page (and on the covers, if any) a title distinct from
     that of the Document, and from those of previous versions (which should,
     if there were any, be listed in the History section of the Document).
     You may use the same title as a previous version if the original
     publisher of that version gives permission.
    </p></li><li class="listitem"><p>
     List on the Title Page, as authors, one or more persons or entities
     responsible for authorship of the modifications in the Modified Version,
     together with at least five of the principal authors of the Document
     (all of its principal authors, if it has fewer than five), unless they
     release you from this requirement.
    </p></li><li class="listitem"><p>
     State on the Title page the name of the publisher of the Modified
     Version, as the publisher.
    </p></li><li class="listitem"><p>
     Preserve all the copyright notices of the Document.
    </p></li><li class="listitem"><p>
     Add an appropriate copyright notice for your modifications adjacent to
     the other copyright notices.
    </p></li><li class="listitem"><p>
     Include, immediately after the copyright notices, a license notice
     giving the public permission to use the Modified Version under the terms
     of this License, in the form shown in the Addendum below.
    </p></li><li class="listitem"><p>
     Preserve in that license notice the full lists of Invariant Sections and
     required Cover Texts given in the Document's license notice.
    </p></li><li class="listitem"><p>
     Include an unaltered copy of this License.
    </p></li><li class="listitem"><p>
     Preserve the section Entitled "History", Preserve its Title, and add to
     it an item stating at least the title, year, new authors, and publisher
     of the Modified Version as given on the Title Page. If there is no
     section Entitled "History" in the Document, create one stating the
     title, year, authors, and publisher of the Document as given on its
     Title Page, then add an item describing the Modified Version as stated
     in the previous sentence.
    </p></li><li class="listitem"><p>
     Preserve the network location, if any, given in the Document for public
     access to a Transparent copy of the Document, and likewise the network
     locations given in the Document for previous versions it was based on.
     These may be placed in the "History" section. You may omit a network
     location for a work that was published at least four years before the
     Document itself, or if the original publisher of the version it refers
     to gives permission.
    </p></li><li class="listitem"><p>
     For any section Entitled "Acknowledgements" or "Dedications", Preserve
     the Title of the section, and preserve in the section all the substance
     and tone of each of the contributor acknowledgements and/or dedications
     given therein.
    </p></li><li class="listitem"><p>
     Preserve all the Invariant Sections of the Document, unaltered in their
     text and in their titles. Section numbers or the equivalent are not
     considered part of the section titles.
    </p></li><li class="listitem"><p>
     Delete any section Entitled "Endorsements". Such a section may not be
     included in the Modified Version.
    </p></li><li class="listitem"><p>
     Do not retitle any existing section to be Entitled "Endorsements" or to
     conflict in title with any Invariant Section.
    </p></li><li class="listitem"><p>
     Preserve any Warranty Disclaimers.
    </p></li></ol></div><p>
   If the Modified Version includes new front-matter sections or appendices
   that qualify as Secondary Sections and contain no material copied from the
   Document, you may at your option designate some or all of these sections
   as invariant. To do this, add their titles to the list of Invariant
   Sections in the Modified Version's license notice. These titles must be
   distinct from any other section titles.
  </p><p>
   You may add a section Entitled "Endorsements", provided it contains
   nothing but endorsements of your Modified Version by various parties--for
   example, statements of peer review or that the text has been approved by
   an organization as the authoritative definition of a standard.
  </p><p>
   You may add a passage of up to five words as a Front-Cover Text, and a
   passage of up to 25 words as a Back-Cover Text, to the end of the list of
   Cover Texts in the Modified Version. Only one passage of Front-Cover Text
   and one of Back-Cover Text may be added by (or through arrangements made
   by) any one entity. If the Document already includes a cover text for the
   same cover, previously added by you or by arrangement made by the same
   entity you are acting on behalf of, you may not add another; but you may
   replace the old one, on explicit permission from the previous publisher
   that added the old one.
  </p><p>
   The author(s) and publisher(s) of the Document do not by this License give
   permission to use their names for publicity for or to assert or imply
   endorsement of any Modified Version.
  </p><h5><a name="idm139781526459248"></a>
   5. COMBINING DOCUMENTS
  </h5><p>
   You may combine the Document with other documents released under this
   License, under the terms defined in section 4 above for modified versions,
   provided that you include in the combination all of the Invariant Sections
   of all of the original documents, unmodified, and list them all as
   Invariant Sections of your combined work in its license notice, and that
   you preserve all their Warranty Disclaimers.
  </p><p>
   The combined work need only contain one copy of this License, and multiple
   identical Invariant Sections may be replaced with a single copy. If there
   are multiple Invariant Sections with the same name but different contents,
   make the title of each such section unique by adding at the end of it, in
   parentheses, the name of the original author or publisher of that section
   if known, or else a unique number. Make the same adjustment to the section
   titles in the list of Invariant Sections in the license notice of the
   combined work.
  </p><p>
   In the combination, you must combine any sections Entitled "History" in
   the various original documents, forming one section Entitled "History";
   likewise combine any sections Entitled "Acknowledgements", and any
   sections Entitled "Dedications". You must delete all sections Entitled
   "Endorsements".
  </p><h5><a name="idm139781526456032"></a>
   6. COLLECTIONS OF DOCUMENTS
  </h5><p>
   You may make a collection consisting of the Document and other documents
   released under this License, and replace the individual copies of this
   License in the various documents with a single copy that is included in
   the collection, provided that you follow the rules of this License for
   verbatim copying of each of the documents in all other respects.
  </p><p>
   You may extract a single document from such a collection, and distribute
   it individually under this License, provided you insert a copy of this
   License into the extracted document, and follow this License in all other
   respects regarding verbatim copying of that document.
  </p><h5><a name="idm139781526453872"></a>
   7. AGGREGATION WITH INDEPENDENT WORKS
  </h5><p>
   A compilation of the Document or its derivatives with other separate and
   independent documents or works, in or on a volume of a storage or
   distribution medium, is called an "aggregate" if the copyright resulting
   from the compilation is not used to limit the legal rights of the
   compilation's users beyond what the individual works permit. When the
   Document is included in an aggregate, this License does not apply to the
   other works in the aggregate which are not themselves derivative works of
   the Document.
  </p><p>
   If the Cover Text requirement of section 3 is applicable to these copies
   of the Document, then if the Document is less than one half of the entire
   aggregate, the Document's Cover Texts may be placed on covers that bracket
   the Document within the aggregate, or the electronic equivalent of covers
   if the Document is in electronic form. Otherwise they must appear on
   printed covers that bracket the whole aggregate.
  </p><h5><a name="idm139781526451376"></a>
   8. TRANSLATION
  </h5><p>
   Translation is considered a kind of modification, so you may distribute
   translations of the Document under the terms of section 4. Replacing
   Invariant Sections with translations requires special permission from
   their copyright holders, but you may include translations of some or all
   Invariant Sections in addition to the original versions of these Invariant
   Sections. You may include a translation of this License, and all the
   license notices in the Document, and any Warranty Disclaimers, provided
   that you also include the original English version of this License and the
   original versions of those notices and disclaimers. In case of a
   disagreement between the translation and the original version of this
   License or a notice or disclaimer, the original version will prevail.
  </p><p>
   If a section in the Document is Entitled "Acknowledgements",
   "Dedications", or "History", the requirement (section 4) to Preserve its
   Title (section 1) will typically require changing the actual title.
  </p><h5><a name="idm139781526448864"></a>
   9. TERMINATION
  </h5><p>
   You may not copy, modify, sublicense, or distribute the Document except as
   expressly provided for under this License. Any other attempt to copy,
   modify, sublicense or distribute the Document is void, and will
   automatically terminate your rights under this License. However, parties
   who have received copies, or rights, from you under this License will not
   have their licenses terminated so long as such parties remain in full
   compliance.
  </p><h5><a name="idm139781526447312"></a>
   10. FUTURE REVISIONS OF THIS LICENSE
  </h5><p>
   The Free Software Foundation may publish new, revised versions of the GNU
   Free Documentation License from time to time. Such new versions will be
   similar in spirit to the present version, but may differ in detail to
   address new problems or concerns. See
   <a class="ulink" href="http://www.gnu.org/copyleft/" target="_top">http://www.gnu.org/copyleft/</a>.
  </p><p>
   Each version of the License is given a distinguishing version number. If
   the Document specifies that a particular numbered version of this License
   "or any later version" applies to it, you have the option of following the
   terms and conditions either of that specified version or of any later
   version that has been published (not as a draft) by the Free Software
   Foundation. If the Document does not specify a version number of this
   License, you may choose any version ever published (not as a draft) by the
   Free Software Foundation.
  </p><h5><a name="idm139781526444208"></a>
   ADDENDUM: How to use this License for your documents
  </h5><pre class="screen">Copyright (c) YEAR YOUR NAME.
Permission is granted to copy, distribute and/or modify
this document under the terms of the GNU Free Documentation
License, Version 1.2 or any later version published by the
Free Software Foundation; with no Invariant Sections,
no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled
“GNU Free Documentation License”.</pre><p>
   If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
   replace the “with...Texts.” line with this:
  </p><pre class="screen">with the Invariant Sections being LIST THEIR TITLES,
with the Front-Cover Texts being LIST, and with
the Back-Cover Texts being LIST.</pre><p>
   If you have Invariant Sections without Cover Texts, or some other
   combination of the three, merge those two alternatives to suit the
   situation.
  </p><p>
   If your document contains nontrivial examples of program code, we
   recommend releasing these examples in parallel under your choice of free
   software license, such as the GNU General Public License, to permit their
   use in free software.
  </p></div></div></div></body></html>
