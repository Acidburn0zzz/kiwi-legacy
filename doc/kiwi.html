<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>openSUSE-KIWI Image System</title><link rel="stylesheet" href="susebooks.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book" title="openSUSE-KIWI Image System"><div class="titlepage"><div><div><h1 class="title"><a name="id2434645"></a>openSUSE-KIWI Image System</h1></div><div><h2 class="subtitle">Cookbook</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Marcus</span> <span class="surname">Schäfer</span></h3><span class="contrib">Project, Design and Implementation</span> <div class="affiliation"><span class="jobtitle">Software Engineer<br></span><span class="orgname">SUSE LINUX Products GmbH<br></span></div><code class="email">&lt;<a class="email" href="mailto:ms@suse.de">ms@suse.de</a>&gt;</code></div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Thomas</span> <span class="surname">Schraitle</span></h3><span class="contrib">Various text improvements, migration to DocBook</span> <div class="affiliation"><span class="jobtitle">Documentation Specialist<br></span><span class="orgname">SUSE LINUX Products GmbH<br></span></div><code class="email">&lt;<a class="email" href="mailto:toms@suse.de">toms@suse.de</a>&gt;</code></div></div></div><div><p class="releaseinfo">KIWI Version 4.63</p></div><div><div class="legalnotice" title="License"><a name="id2511231"></a><p class="legalnotice-title"><b>License</b></p><p>Permission is granted to copy, distribute and/or modify this
    document under the terms of the GNU Free Documentation License,
    Version 1.2 or (at your option) version 1.3; with the Invariant
    Section being this copyright notice and license. A copy of the
    license version 1.2 is included in the appendix entitled <span class="quote">&#8220;<span class="quote">GNU
      Free Documentation License</span>&#8221;</span>.</p><p><span class="trademark">SUSE</span>®, <span class="trademark">openSUSE</span>®, the <span class="trademark">openSUSE</span>® logo, <span class="trademark">Novell</span>®, the <span class="trademark">Novell</span>® logo, the <span class="trademark">N</span>® logo, are registered trademarks
    of Novell, Inc. in the United States and other countries. <span class="trademark">Linux</span>® is a registered trademark of
    Linux Torvalds. All other thrid party trademarks are the property of
    their respective owners.</p><p>All information found in this book has been compiled with utmost
    attention to detail. However, this does not guarantee complete
    accuracy. Neither Novell, Inc., SUSE Linux Products GmbH, the
    authors, nor the translators shall be held liable for possible
    errors or the consequences thereof.</p></div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision KIWI V4.58</td><td align="left">2010-08-31</td><td align="left">toms</td></tr><tr><td align="left" colspan="3">
          <p>First migration to DocBook</p>
        </td></tr></table></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#chap.workflow">1. Basic Workflow</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.workflow.introduction">1.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.bootprocess">1.2. Boot Process</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.bootparameters">1.3. Boot Parameters</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.common-specific-code">1.4. Common and Distribution Specific Code</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.description">2. KIWI Image Description</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.description.config.xml">2.1. The config.xml File</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.description.image">2.1.1. <code class="sgmltag-element">image</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.description">2.1.2. <code class="sgmltag-element">description</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.profiles">2.1.3. <code class="sgmltag-element">profiles</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.preferences">2.1.4. <code class="sgmltag-element">preferences</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.users">2.1.5. <code class="sgmltag-element">users</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.drivers">2.1.6. <code class="sgmltag-element">drivers</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.repository">2.1.7. <code class="sgmltag-element">repository</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.packages">2.1.8. <code class="sgmltag-element">packages</code> Element</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.appliance">3. Creating Appliances with KIWI</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.appliance.history">3.1. History</a></span></dt><dt><span class="sect1"><a href="#sec.appliance.kiwi-model">3.2. The KIWI Model</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.maintenance">4. Maintenance of Operating System Images</a></span></dt><dt><span class="chapter"><a href="#chap.migration">5. System to Image Migration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.migrate.create-clean-repository">5.1. Create a Clean Repository Set First</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.watch-overlay">5.2. Watch the Overlay and Unpackaged Files</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.checklist">5.3. Checklist</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.turn-system-into-image">5.4. Turn my System Into an Image&#8230;</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.instsourcesetup">6. Installation Source</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.instsourcesetup.adapt-example">6.1. Adapt the Example&#8217;s config.xml</a></span></dt><dt><span class="sect1"><a href="#sec.instsourcesetup.create-local-inst-source">6.2. Create a Local Installation Source</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.iso">7. ISO Image&#8212;Live Systems</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.iso.building">7.1. Building the suse-live-iso Example</a></span></dt><dt><span class="sect1"><a href="#sec.iso.using">7.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.iso.flavours">7.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.split-mode">7.3.1. Split mode</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.usb">8. USB Image&#8212;Live-Stick System</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.usb.building">8.1. Building the suse-live-stick Example</a></span></dt><dt><span class="sect1"><a href="#sec.usb.using">8.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.usb.flavours">8.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.usb.split-stick">8.3.1. Split Stick</a></span></dt><dt><span class="sect2"><a href="#sec.usb.lvm">8.3.2. LVM Support</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.vmx">9. VMX Image&#8212;Virtual Disks</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.vmx.building">9.1. Building the suse-vm-guest Example</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.using">9.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.flavours">9.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.vmx.vmware-support">9.3.1. VMware support</a></span></dt><dt><span class="sect2"><a href="#sec.vmx.lvm">9.3.2. LVM Support</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.pxe">10. PXE Image&#8212;Thin Clients</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.pxe.setting-up">10.1. Setting Up the Required Services</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.atftp-server">10.1.1. Atftp Server</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.dhcp-server">10.1.2. DHCP Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.building">10.2. Building the suse-pxe-client Example</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.using">10.3. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.flavours">10.4. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.client-control-file">10.4.1. The PXE Client Control File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.client-config-file">10.4.2. The PXE Client Configuration File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.another-user">10.4.3. User another than tftp as Download Protocol</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.ram-only-image">10.4.4. RAM Only Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.union-image">10.4.5. Union Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.split-image">10.4.6. Split Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-nfs">10.4.7. Root Tree Over NFS</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-nbd">10.4.8. Root Tree Over NBD</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-aoe">10.4.9. Root Tree Over AoE</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.groups">10.5. Hardware Grouping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2555227">10.5.1. The Group Configuration File</a></span></dt><dt><span class="sect2"><a href="#id2555412">10.5.2. The Hardware Group File</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.oem">11. OEM Image&#8212;Preload Systems</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.oem.building">11.1. Building the suse-oem-preload Example</a></span></dt><dt><span class="sect1"><a href="#sec.oem.using">11.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.oem.flavours">11.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.oem.installation">11.3.1. Specializing the OEM install process</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partitioning">11.3.2. Influencing the OEM Partitioning</a></span></dt><dt><span class="sect2"><a href="#sec.oem.lvm">11.3.3. LVM Support</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partition-based-installation">11.3.4. Partition Based Installation</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chap.xen">12. Xen Image&#8212;Paravirtual Systems</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.xen.building">12.1. Building the suse-xen-guest Example</a></span></dt><dt><span class="sect1"><a href="#sec.xen.using">12.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.flavours">12.3. Flavours</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.ec2">13. EC2 Image&#8212;Amazon Elastic Compute Cloud</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.ec2.building">13.1. Building the suse-xen-guest Example for EC2</a></span></dt><dt><span class="sect1"><a href="#sec.ec2.using">13.2. Using the Image</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap.testing">14. KIWI Testsuite</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sec.testing.testsuite">14.1. Testsuite Packages</a></span></dt><dt><span class="sect1"><a href="#sec.testing.creating">14.2. Creating a Test</a></span></dt></dl></dd><dt><span class="appendix"><a href="#appendix">A. KIWI Man Pages</a></span></dt><dd><dl><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwi">kiwi</a></span><span class="refpurpose"> &#8212; Creating Operating System Images</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.config.sh">kiwi::config.sh</a></span><span class="refpurpose"> &#8212; Configuration File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.images.sh">kiwi::images.sh</a></span><span class="refpurpose"> &#8212; Configuration File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwirc">kiwi::kiwirc</a></span><span class="refpurpose"> &#8212; Resource file for the Kiwi imaging system</span></dt></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>1.1. <a href="#fig.imageservingarch">Image Serving Architecture</a></dt><dt>1.2. <a href="#fig.imagetypes">Image Types</a></dt><dt>1.3. <a href="#fig.workflow.bootprocess">Boot Process</a></dt><dt>2.1. <a href="#fig.description.imagedescrdir">Image Description Directory</a></dt><dt>4.1. <a href="#fig.maintain">Image Maintenance Scenarios</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>2.1. <a href="#tab.description.supported-types">Supported Types for zypper and smart</a></dt><dt>9.1. <a href="#tab.vmx.supported-disk-formats">Supported Virtual Disk Formats</a></dt><dt>13.1. <a href="#tab.ec2.kernel-image-ids">Amazon Kernel Image IDs</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>A.1. <a href="#id2559783">Template for config.sh</a></dt><dt>A.2. <a href="#id2560912">Template for images.sh</a></dt><dt>A.3. <a href="#id2561578">Template for .kiwi.rc</a></dt></dl></div><div class="chapter" title="Chapter 1. Basic Workflow"><div class="titlepage"><div><div><h2 class="title"><a name="chap.workflow"></a>Chapter 1. Basic Workflow</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.workflow.introduction">1.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.bootprocess">1.2. Boot Process</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.bootparameters">1.3. Boot Parameters</a></span></dt><dt><span class="sect1"><a href="#sec.workflow.common-specific-code">1.4. Common and Distribution Specific Code</a></span></dt></dl></div><a class="indexterm" name="id2541352"></a><div class="sect1" title="1.1. Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.introduction"></a>1.1. Introduction<span class="permalink"><a alt="Permalink" title="1.1. Introduction" href="#sec.workflow.introduction">¶</a></span></h2></div></div></div><p>The openSUSE KIWI Image System provides a complete operating
    system image solution for Linux supported hardware platforms as well
    as for virtualisation systems like Xen, VMWare, etc. The KIWI
    architecture was designed as a two level system. The first stage,
    based on a valid <span class="emphasis"><em>software package source</em></span>,
    creates a so called <span class="emphasis"><em>unpacked image</em></span> according to
    the provided image description. The second stage creates from a
    required unpacked image an operating system image. The result of the
    second stage is called a <span class="emphasis"><em>packed image</em></span> or short
    an image. </p><div class="figure"><a name="fig.imageservingarch"></a><p class="title"><b>Figure 1.1. Image Serving Architecture</b><span class="permalink"><a alt="Permalink" title="Figure 1.1. Image Serving Architecture" href="#fig.imageservingarch">¶</a></span></p><div class="figure-contents"><div class="mediaobjectco"><img border="0" usemap="#id2524396" src="images/intro.png" alt="Image Serving Architecture"><map name="id2524396"><area shape="rect" coords="NaN,NaN,NaN,NaN"><area shape="rect" coords="NaN,NaN,NaN,NaN"></map><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/1.png" alt="1" border="0"></p></td><td valign="top" align="left"><p>Encapsulated system reachable via chroot</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/2.png" alt="2" border="0"></p></td><td valign="top" align="left"><p>Encapsulated system reachable via kernel
                filesystem/extention drivers</p></td></tr></table></div></div></div></div><br class="figure-break"><p>Because this document contains conceptual information about an
    image system, it is important to understand what an operating system
    image is all about. A normal installation process is starting from a
    given installation source and installs single pieces of software
    until the system is complete. During this process manual user
    intervention may be required. However, an operating system image
    represents an already completed <span class="emphasis"><em>installation</em></span>,
    encapsulated as a file and optionally includes the configuration for
    a specific task. Such an operating system starts working as soon as
    the image has been brought to a system storage device no matter if
    this is a volatile or non volatile storage. The process of creating
    an image takes place without user interaction. This means, all
    requirements of the encapsulated system has to be fulfilled before
    the image is created. All of this information is stored in the
      <span class="emphasis"><em>image description</em></span>. </p></div><div class="sect1" title="1.2. Boot Process"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.bootprocess"></a>1.2. Boot Process<span class="permalink"><a alt="Permalink" title="1.2. Boot Process" href="#sec.workflow.bootprocess">¶</a></span></h2></div></div></div><a class="indexterm" name="id2518532"></a><a class="indexterm" name="id2517312"></a><p>The creation of an image with KIWI is always divided into two
    basic steps: the <span class="emphasis"><em>prepare</em></span> and the
      <span class="emphasis"><em>create</em></span> step. The create step requires the
    prepare step to be exited successfully. Within this first prepare
    step, KIWI builds a new root tree or, in KIWI speak, a new unpacked
    image. The building of a new root tree consists of the creation of
    the directory specified to hold it and the installation of the
    selected packages on it. The installation of software packages is
    driven by a package manager. KIWI supports the smart package
    managers. The prepare step executes the following major stages: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p title="Creating Root Directory"><b>Creating Root Directory. </b>To prevent accidental deletion of an existing root tree,
          KIWI will stop with an error message if this folder already
          exists, unless the option <code class="option">--force-new-root</code> is
          used in which case the existing root will be deleted. </p></li><li class="listitem"><p title="Installing Packages"><b>Installing Packages. </b>First the selected package manager (smart by default) is
          instructed to use the repositories specified in the image
          description file. Then the packages specified in the bootstrap
          section are installed. These packages are installed externally
          to the target root system (i. e. not chroot&#8217;ed) and
          establish the initial environment so the rest of the process
          may run chroot&#8217;ed. Essential packages in this section are
          filesystem and glibc-locale. In practice you only need to
          specify those two, since the rest of the packages will be
          pulled because of the dependency system. To save space in your
          image you could schedule a set of packages for deletion after
          the package installation phase is over by listing them in the
            <code class="sgmltag-element">delete</code> section</p></li><li class="listitem"><p title="Executing User Defined config.sh Script"><b>Executing User Defined config.sh Script. </b>At the end of the preperation stage the optional script
          named <code class="filename">config.sh</code> is called. This script
          should be used to configure the system which means, for
          example, the activation of services. For a detailed
          description what functions are already available to configure
          the system, refer to the <a class="xref" href="#ref.kiwi.config.sh" title="kiwi::config.sh"><span class="refentrytitle">kiwi::config.sh</span>(1)</a>
          man page.</p></li><li class="listitem"><p title="Managing New Root Tree"><b>Managing New Root Tree. </b>At this point you can make changes on your unpacked image
          so it fits your purpose better. Bear in mind that changes at
          this point will be discarded and not repeated automatically if
          you rerun the <span class="emphasis"><em>prepare</em></span> phase unless you
          include them in your original <code class="filename">config.xml</code>
          file and/or <code class="filename">config.sh</code> script. Please also
          note that the image description has been copied into the new
          root below the directory <code class="filename"><em class="replaceable"><code>new-root</code></em>/image</code><a class="indexterm" name="id2525207"></a>. Any
          subsequent create step will read the image description
          information from the new root tree and not from the original
          image description location. According to this if you need to
          change the image description data after the prepare call has
          finished, you need to change it inside the new root tree as
          well as in your original description directory to prevent
          loosing the change when your root tree will be removed later
          for some reason. </p></li></ul></div><p>After the prepare step has finished successfully, a subsequent
    building of an image file follows or, in KIWI speak, a new packed
    image. The building of an image requires a successfully prepared new
    root tree in the first place. Using this tree multiple image types
    can be created. So to speak it&#8217;s possible to create a VMware image
    and a Xen image from the same prepared root tree. The create step
    executes the following major stages: </p><div class="itemizedlist"><a class="indexterm" name="id2534352"></a><ul class="itemizedlist" type="disc"><li class="listitem"><p title="Executing User Defined Script images.sh"><b>Executing User Defined Script images.sh. </b><a class="indexterm" name="id2511197"></a>At the beginning of the creation stage the optional script
          named <code class="filename">images.sh</code> is called. This script
          has no distinctive use case like
            <code class="filename">config.sh</code>. However, it is most often
          used to remove packages which were pulled in by a dependency,
          but are not really required for later use of the operating
          system. For a detailed description what functions are already
          available to <code class="filename">images.sh</code>, refer to the
            <a class="xref" href="#ref.kiwi.images.sh" title="kiwi::images.sh"><span class="refentrytitle">kiwi::images.sh</span>(1)</a> man page.</p></li><li class="listitem"><p title="Creating Requested Image Type"><b>Creating Requested Image Type. </b><a class="indexterm" name="id2536370"></a>What image type(s) a KIWI image supports depends on what
          types has been setup in the main image description file
            <code class="filename">config.xml</code>. At least one type must be
          setup. The following picture shows what image types are
          currently supported by KIWI:</p><div class="figure"><a name="fig.imagetypes"></a><p class="title"><b>Figure 1.2. Image Types</b><span class="permalink"><a alt="Permalink" title="Figure 1.2. Image Types" href="#fig.imagetypes">¶</a></span></p><div class="figure-contents"><div class="mediaobjectco"><img border="0" usemap="#id2527707" src="images/types.png" alt="Image Types"><map name="id2527707"><area shape="rect" coords="NaN,NaN,NaN,NaN"><area shape="rect" coords="NaN,NaN,NaN,NaN"><area shape="rect" coords="NaN,NaN,NaN,NaN"><area shape="rect" coords="NaN,NaN,NaN,NaN"></map><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/1.png" alt="1" border="0"></p></td><td valign="top" align="left"><p>Live Image on CD, DVD or USB stick</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/2.png" alt="2" border="0"></p></td><td valign="top" align="left"><p>Full virtual system which can be played in VMWare, Xen, 
                  Amazon Cloud, etc. Guest configuration can be created.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/3.png" alt="3" border="0"></p></td><td valign="top" align="left"><p>Preload system with install media on CD or USB stick</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/4.png" alt="4" border="0"></p></td><td valign="top" align="left"><p>Network boot image. Kiwi also provides the bootp environment via the package kiwi-pxeboot</p></td></tr></table></div></div></div></div><br class="figure-break"></li></ul></div><p>Detailed information including a step by step guidance how to
    call KIWI and how to make use of the result image can be found in
    the image type specific sections later in this document. </p><p>Todays Linux systems are using a special boot image to control
      the boot process. This boot image is called initrd. The Linux
      kernel loads this compressed cpio initial ramdisk into RAM and
      calls init or (if present) the program linuxrc. The KIWI image
      system also takes care for the creation of this boot image. Each
      image type has it&#8217;s own special boot code and shares the common
      parts in a set of module functions. The image descriptions for the
      boot images are provided by KIWI and thus the user has in almost
      all cases no need to take care for the boot image. </p><div class="figure"><a name="fig.workflow.bootprocess"></a><p class="title"><b>Figure 1.3. Boot Process</b><span class="permalink"><a alt="Permalink" title="Figure 1.3. Boot Process" href="#fig.workflow.bootprocess">¶</a></span></p><div class="figure-contents"><div class="mediaobjectco"><img border="0" usemap="#id2534578" src="images/activation.png" alt="Boot Process"><map name="id2534578"><area shape="rect" coords="NaN,NaN,NaN,NaN"><area shape="rect" coords="NaN,NaN,NaN,NaN"></map><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/1.png" alt="1" border="0"></p></td><td valign="top" align="left"><p>Descriptions are provided by KIWI, use is recommended but
                not required</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/2.png" alt="2" border="0"></p></td><td valign="top" align="left"><p>A description needs to be created or a template can be
                used</p></td></tr></table></div></div></div></div><br class="figure-break"><p>Furthermore, KIWI automatically creates this boot image along
      with the requested image type. It does that by calling itself in a
      prepare and create call. There is no difference in terms of the
      description of such a boot image compared to the system image
      description. The system image description is the one the user
      creates and it represents the later operating system, whereas the
      boot image only lives temporarly in RAM as long as the system
      image will be activated. The boot image descriptions are stores in
        <code class="filename">/usr/share/kiwi/image/*boot</code> and can be
      build in the same way as the system image. A boot image without a
      corresponding system image doesn&#8217;t make sense though. </p></div><div class="sect1" title="1.3. Boot Parameters"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.bootparameters"></a>1.3. Boot Parameters<span class="permalink"><a alt="Permalink" title="1.3. Boot Parameters" href="#sec.workflow.bootparameters">¶</a></span></h2></div></div></div><a class="indexterm" name="id2529097"></a><a class="indexterm" name="id2528594"></a><p> When booting an image created by KIWI using one of the
      provided boot images there are some useful kernel parameters
      mainly meant for debugging purposes. Note the following parameters
      are only useful if the KIWI initrd is used. In case of any other
      initrd code written by yourself or simply because KIWI replaced
      itself with the distribution specfic mkinitrd tool the parameters
      might not have any effect. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p title="kiwidebug=1"><b><em class="parameter"><code>kiwidebug=1</code></em>. </b>If the boot process encounters a fatal error, the system
            normally reacts with a reboot after 120 seconds. This so
            called <span class="quote">&#8220;<span class="quote">exception</span>&#8221;</span> can be influenced by the
            kiwidebug parameter. If set to 1, the system will stop and
            provide the user with a shell prompt instead of a reboot.
            This shell contains some basic standard commands which could
            help to find the cause of the problem. </p></li><li class="listitem"><p title="kiwistderr=/dev/..."><b><em class="parameter"><code>kiwistderr=/dev/...</code></em> </b>While the system boots, KIWI writes messages to tty1 and
            tty3. The tty1 messages are highlevel information whereas
            the tty3 messages represents the shell debug output and any
            error messages from the commands called. With the kiwistderr
            parameter one can combine both message sets and specify
            where to write them to. It&#8217;s very common to set <code class="filename">/dev/console</code><a class="indexterm" name="id2533007"></a> as possible
            alternative to the default logging behaviour.</p></li></ul></div></div><div class="sect1" title="1.4. Common and Distribution Specific Code"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.workflow.common-specific-code"></a>1.4. Common and Distribution Specific Code<span class="permalink"><a alt="Permalink" title="1.4. Common and Distribution Specific Code" href="#sec.workflow.common-specific-code">¶</a></span></h2></div></div></div><a class="indexterm" name="id2533955"></a><a class="indexterm" name="id2537034"></a><p> KIWI has been developed to be usable for any Linux
      distribution. However, each Linux distribution is different. On
      one hand, KIWI provides common code </p><p>By design of a Linux distribution there are differences
      between each of them. With KIWI we provide on one hand the code
      which is common to all Linux distributions according to standards
      and on the other hand there is also code where we have to
      distinguish between the distribution type. </p><p>In case of such specific tasks which are almost all in the
      area of booting, KIWI provides a set of functions which all
      contains a distribution prefix. As this project uses SUSE Linux as
      base distribution all required distribution specific tasks has
      been implemented for SUSE. Other distributions could be missing.
      The existing implementation for SUSE turns out to be adapted to
      other distributions very easily though. </p><p>A look into the code therefore will show you functions which
      are prefixed by <span class="quote">&#8220;<span class="quote">suse</span>&#8221;</span> as well as scripts whose names
      starts with <span class="quote">&#8220;<span class="quote">suse-</span>&#8221;</span>. If you see such a prefix,
      script, or function, you can be assured that this is something
      distribution specific. If you plan to use KIWI with another
      distribution than SUSE, you need to adapt it. For example, the
      boot workflow is controlled by a program called
        <span class="command"><strong>linuxrc</strong></span> which is in KIWI a script represented
      by <span class="command"><strong>suse-linuxrc</strong></span>. Another example is the
      function <code class="function">suseStripKernel</code>, which is able to
      remove everything but a specified list of kernel drivers from the
      SUSE kernel. </p><p>The prefixed implementation allows us to integrate all the
      distribution specific tasks into one project but this of course
      requires the help and knowledge of the people who are familar with
      their preferred Linux distribution. </p></div></div><div class="chapter" title="Chapter 2. KIWI Image Description"><div class="titlepage"><div><div><h2 class="title"><a name="chap.description"></a>Chapter 2. KIWI Image Description</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.description.config.xml">2.1. The config.xml File</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.description.image">2.1.1. <code class="sgmltag-element">image</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.description">2.1.2. <code class="sgmltag-element">description</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.profiles">2.1.3. <code class="sgmltag-element">profiles</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.preferences">2.1.4. <code class="sgmltag-element">preferences</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.users">2.1.5. <code class="sgmltag-element">users</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.drivers">2.1.6. <code class="sgmltag-element">drivers</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.repository">2.1.7. <code class="sgmltag-element">repository</code> Element</a></span></dt><dt><span class="sect2"><a href="#sec.description.packages">2.1.8. <code class="sgmltag-element">packages</code> Element</a></span></dt></dl></dd></dl></div><a class="indexterm" name="id2518540"></a><p>In order to be able to create an image with KIWI a so called
    image description must be created. The image description is
    represented by a directory which has to contain at least one file
    named <code class="filename">config.xml</code> or alternatively <code class="filename">*.kiwi</code><a class="indexterm" name="id2508212"></a>. A good start for such a
    description can be found in the examples provided in
      <code class="filename">/usr/share/doc/packages/kiwi/examples</code>. </p><div class="figure"><a name="fig.description.imagedescrdir"></a><p class="title"><b>Figure 2.1. Image Description Directory</b><span class="permalink"><a alt="Permalink" title="Figure 2.1. Image Description Directory" href="#fig.description.imagedescrdir">¶</a></span></p><div class="figure-contents"><div class="mediaobject"><img src="images/description.png" alt="Image Description Directory"></div></div></div><br class="figure-break"><p>The following additional information is optional for the process
    of building an image, but most often mandatory for the functionality
    of the later operating system: </p><div class="variablelist"><dl><dt><span class="term"><code class="filename">images.sh</code></span></dt><dd><p> Optional configuration script while creating the packed
          image. This script is called at the beginning of the image
          creation process. It is designed to clean-up the image system.
          Affected are all the programs and files only needed while the
          unpacked image exists. </p></dd><dt><span class="term"><code class="filename">config.sh</code></span></dt><dd><p>Optional configuration script while creating the unpacked
          image. This script is called at the end of the installation,
          but <span class="emphasis"><em>before</em></span> the package scripts have run.
          It is designed to configure the image system, such as the
          activation or deactivation of certain services (<code class="systemitem">insserv</code><a class="indexterm" name="id2529436"></a>). The call is not made
          until after the switch to the image has been made with chroot.
        </p></dd><dt><span class="term"><code class="filename">root</code><a class="indexterm" name="id2543483"></a></span></dt><dd><p>Subdirectory that contains special files, directories, and
          scripts for adapting the image environment
            <span class="emphasis"><em>after</em></span> the installation of all the image
          packages. The entire directory is copied into the root of the
          image tree using <span class="command"><strong>cp</strong></span>
          <code class="option">-a</code>. </p></dd><dt><span class="term"><code class="filename">config-yast-firstboot.xml</code></span></dt><dd><p> Configuration file for the control of the YaST firstboot
          service. Similar to the AutoYaST approach, YaST also provides
          a boot time service called firstboot. Unfortunately there is
          no GUI available to setup the firstboot, but good
          documentation in
            <code class="filename">/usr/share/doc/packages/yast2-firstboot</code>.
          Once you have created such a firstboot file in your image
          description directory, KIWI will process the file and setup
          your image as follows: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>KIWI enables the firstboot service. </p></li><li class="listitem"><p>While booting the image, YaST is started in firstboot
              mode. </p></li><li class="listitem"><p>The firstboot service handles the instructions listed
              in the <code class="filename">fileconfig-yast-firstboot.xml</code>.
            </p></li><li class="listitem"><p>If the process finished successfully, the environment
              is cleaned and firstboot will not be called at next
              reboot.</p></li></ol></div></dd><dt><span class="term"><code class="filename">config-yast-autoyast.xml</code></span></dt><dd><p> Configuration file which has been created by AutoYaST. To
          be able to create such an AutoYaST profile, run: </p><pre class="screen"><span class="command"><strong>yast2</strong></span> autoyast</pre><p>Once you have saved the information from the AutoYaST UI
          as <code class="filename">config-yast-autoyast.xml</code> file in your
          image description directory KIWI will process on the file and
          setup your image as follows: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>While booting the image YaST is started in AutoYaST
              mode automatically </p></li><li class="listitem"><p>The AutoYaST description is parsed and the
              instructions are handled by YaST. In other words the
                <span class="emphasis"><em>system configuration</em></span> is performed
            </p></li><li class="listitem"><p>If the process finished successfully the environment
              is cleaned and AutoYaST won&#8217;t be called at next reboot.
            </p></li></ol></div></dd><dt><span class="term"><code class="filename">config-cdroot.tgz</code></span></dt><dd><p> Archive which is used for ISO images only. The data in
          the archive is uncompressed and stored in the CD/DVD root
          directory. This archive can be used, for example, to integrate
          a license file or information directly readable from the CD or
          DVD. </p></dd><dt><span class="term"><code class="filename">config-cdroot.sh</code></span></dt><dd><p>Along with the <code class="filename">config-cdroot.tgz</code> one
          can provide a script which allows to manipulate the extracted
          data. </p></dd><dt><span class="term"><code class="filename">config/</code><a class="indexterm" name="id2523557"></a></span></dt><dd><p>Optional subdirectory that contains Bash scripts that are
          called after the installation of all the image packages,
          primarily in order to remove the parts of a package that are
          not needed for the operating system. The name of the Bash
          script must resemble the package name listed in the
          config.xml. </p></dd></dl></div><div class="sect1" title="2.1. The config.xml File"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.description.config.xml"></a>2.1. The config.xml File<span class="permalink"><a alt="Permalink" title="2.1. The config.xml File" href="#sec.description.config.xml">¶</a></span></h2></div></div></div><a class="indexterm" name="id2514466"></a><p> The mandatory image definition file is divided into different
      sections which describes information like the image name and type
      as well as the packages and patterns the image should consist of. </p><p>The following information explains the basic structure of the
      XML document. When KIWI is executed, the XML structure is
      validated by the KIWI RELAX NG based schema. For details on
      attributes and values please refer to the schema documentation
      file at
        <code class="filename">/usr/share/doc/packages/kiwi/kiwi.rng.html</code>. </p><div class="sect2" title="2.1.1. image Element"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.image"></a>2.1.1. <code class="sgmltag-element">image</code> Element<span class="permalink"><a alt="Permalink" title="2.1.1. image Element" href="#sec.description.image">¶</a></span></h3></div></div></div><pre class="screen">&lt;image schemaversion="3.5" name="iname"
  displayname="text" 
  inherit="path" 
  kiwirevision="number" 
  id="10 digit number"&gt;
  <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code>
&lt;/image&gt;</pre><p>The image definition starts with an <code class="sgmltag-element">image</code>
        tag and requires the schema format at version 2.0. The attribute
          <code class="sgmltag-attribute">name</code><a class="indexterm" name="id2540037"></a> specifies the name
        of the image which is also used for the filenames created by
        KIWI. Because we don&#8217;t want spaces in filenames the <code class="sgmltag-attribute">name</code><a class="indexterm" name="id2522467"></a> attribute must not have any
        spaces in its name. </p><p>The following optional attributes can be inserted in the
          <code class="sgmltag-element">image</code> tag: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">displayname</code><a class="indexterm" name="id2524104"></a></span></dt><dd><p> allows setup of the boot menu title for isolinux and
              grub. So you can have <span class="emphasis"><em>suse-SLED-foo</em></span>
              as the image name but something like <span class="emphasis"><em>my cool
                Image</em></span> as the boot display name. </p></dd><dt><span class="term"><code class="sgmltag-attribute">inherit</code><a class="indexterm" name="id2539079"></a></span></dt><dd><p>inherits the packages information from another
                <code class="sgmltag-element">image</code> description </p></dd><dt><span class="term"><code class="sgmltag-attribute">kiwirevision</code><a class="indexterm" name="id2500025"></a></span></dt><dd><p>specifies a KIWI SVN revision number which is known to
              build a working image from this description. If the KIWI
              SVN revision is less than the specified value, the process
              will exit. The currently used SVN revision can be queried
              by calling <span class="command"><strong>kiwi</strong></span>
              <code class="option">--version</code>. </p></dd><dt><span class="term"><code class="sgmltag-attribute">id</code><a class="indexterm" name="id2510120"></a></span></dt><dd><p> sets an identification number which appears as file
                <code class="filename">/etc/ImageID</code> within the image.
            </p></dd></dl></div><p>Inside the <code class="sgmltag-element">image</code> section the following
        mandatory and optional subelements exists. The simplest image
        description must define the elements
          <code class="sgmltag-element">description</code>,
        <code class="sgmltag-element">preferences</code>, <code class="sgmltag-element">repository</code>
        and <code class="sgmltag-element">packages</code> (at least one of <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2518074"></a>="<code class="sgmltag-attvalue">bootstrap</code>"). </p></div><div class="sect2" title="2.1.2. description Element"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.description"></a>2.1.2. <code class="sgmltag-element">description</code> Element<span class="permalink"><a alt="Permalink" title="2.1.2. description Element" href="#sec.description.description">¶</a></span></h3></div></div></div><pre class="screen">&lt;description type="system"&gt;
  &lt;author&gt;an author&lt;/author&gt;
  &lt;contact&gt;mail&lt;/contact&gt;
  &lt;specification&gt;short info&lt;/specification&gt;
&lt;/description&gt;</pre><p>The mandatory <code class="sgmltag-element">description</code> section
        contains information about the creator of this image
        description. The attribute <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2544283"></a> could be either of the value system which
        indicates this is a system image description or at value boot
        for boot image descriptions. </p></div><div class="sect2" title="2.1.3. profiles Element"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.profiles"></a>2.1.3. <code class="sgmltag-element">profiles</code> Element<span class="permalink"><a alt="Permalink" title="2.1.3. profiles Element" href="#sec.description.profiles">¶</a></span></h3></div></div></div><pre class="screen">&lt;profiles&gt;
   &lt;profile name="name" description="text"/&gt;
   <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code>
&lt;/profiles&gt;</pre><p>The optional <code class="sgmltag-element">profiles</code> section lets you
        maintain one image description while allowing for variation of
        the sections packages and drivers that are included. A separate
        profile element must be specified for each variation. The
          <code class="sgmltag-element">profile</code> child element, which has <code class="sgmltag-attribute">name</code><a class="indexterm" name="id2514300"></a> and <code class="sgmltag-attribute">description</code><a class="indexterm" name="id2518072"></a> attributes, specifies
        an alias name used to mark sections as belonging to a profile,
        and a short description explaining what this profile does. </p><p>To mark a set of packages/drivers as belonging to a profile,
        simply annotate them with the <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="id2513574"></a> attribute. It is also possible to mark
        sections as belonging to multiple profiles by separating the
        names in the <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="id2523975"></a>
        attribute with a comma. If a <code class="sgmltag-element">packages</code> or
          <code class="sgmltag-element">drivers</code> tag does not have a <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="id2525096"></a> attribute, it is assumed
        to be present for all profiles. </p></div><div class="sect2" title="2.1.4. preferences Element"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.preferences"></a>2.1.4. <code class="sgmltag-element">preferences</code> Element<span class="permalink"><a alt="Permalink" title="2.1.4. preferences Element" href="#sec.description.preferences">¶</a></span></h3></div></div></div><pre class="screen">&lt;preferences profiles="name"&gt;
  &lt;version&gt;1.1.2&lt;/version&gt;
  &lt;packagemanager&gt;smart&lt;/packagemanager&gt;
  &lt;type image="name" ...&gt;
    &lt;ec2config|lvmvolumes|oemconfig|pxedeploy|size|split|machine&gt;
  &lt;/type&gt; 
&lt;/preferences&gt;</pre><p>The mandatory <code class="sgmltag-element">preferences</code> section
        contains information about the supported image type(s), the used
        package manager, the version of this image, and optional
        attributes. The image version must be a three-part version
        number of the format: <span class="bold"><strong>Major</strong></span>.<span class="bold"><strong>Minor</strong></span>.<span class="bold"><strong>Release</strong></span>.
        <a class="indexterm" name="id2527359"></a>
        In case of changes to the image description the following rules
        should apply: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>For smaller image modifications that do not add or
            remove any new packages, only the release number is
            incremented. The <code class="filename">config.xml</code> file
            remains unchanged. </p></li><li class="listitem"><p>For image changes that involve the addition or removal
            of packages the minor number is incremented and the release
            number is reset. </p></li><li class="listitem"><p>For image changes that change the size of the image file
            the major number is incremented. </p></li></ul></div><p>By default, KIWI use the smart package manager but it is
        also possible to use the SUSE package manager called
          <span class="command"><strong>zypper</strong></span>. </p><p>In general the specification of one
          <code class="sgmltag-element">preferences</code> section is sufficient. However,
        it&#8217;s possible to specify multiple <code class="sgmltag-element">preferences</code>
        sections and distinquish between the sections via the <code class="sgmltag-attribute">profiles</code><a class="indexterm" name="id2537180"></a> attribute. Data may also
        be shared between different profiles. Using profiles it is
        possible to, for example, configure specific preferences for OEM
        image generation. Activation of a given
          <code class="sgmltag-element">preferences</code> during image generation is
        triggered by the use of the <code class="option">--add-profile</code>
        command line argument.</p><p>For each <code class="sgmltag-element">preferences</code> block at least one
          <code class="sgmltag-element">type</code> element must be defined. It is
        possible to specify multiple <code class="sgmltag-element">type</code> elements in
        any <code class="sgmltag-element">preferences</code> block. To set a given
          <code class="sgmltag-element">type</code> description as the default image use
        the boolean attribute <code class="sgmltag-attribute">primary</code><a class="indexterm" name="id2536832"></a> and set its value to <code class="sgmltag-attvalue">true</code>. The image type to be created
        is determined by the value of the <code class="sgmltag-attribute">image</code><a class="indexterm" name="id2545871"></a> attribute. The following list describes the
        supported types and possible values of the image attribute: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="id2529016"></a>="<code class="sgmltag-attvalue">cpio</code>"</span></dt><dd><p>Use the cpio image type to specify the generation os a
              boot image (intrd). When generating a boot image it is
              possible to specify a specific boot profile and boot
              kernel using the optional <code class="sgmltag-attribute">bootprofile</code><a class="indexterm" name="id2517724"></a>="<code class="sgmltag-attvalue">default</code>" and <code class="sgmltag-attribute">bootkernel</code><a class="indexterm" name="id2544897"></a>="<code class="sgmltag-attvalue">std</code>" attributes. </p><p>A boot image should group the various supported
              kernels into profiles. If the user chooses not to use the
              profiles supplied by KIWI, it is required that one profile
              named std be created. This profile will be used if no
              other bootkernel is specified. Further it is required to
              create a profile named default. This profile is used when
              no bootprofile is specified. </p><p>It is recommended that special configurations that
              omit drivers, use special drivers and/or special packages
              be specified as profiles. </p><p>The bootprofile and bootkernel attribute are respected
              within the definition of a system image. Us the attribute
              and value <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2543047"></a>="<code class="sgmltag-attvalue">system</code>" of the <code class="sgmltag-element">description</code>
              element to specify the creation of a system image. The
              values of the bootprofile and bootkernel attributes are
              used by KIWI when generating the boot image. </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="id2538648"></a>="<code class="sgmltag-attvalue">iso</code>"</span></dt><dd><p>Specify the key-value pair <code class="sgmltag-attribute">image</code><a class="indexterm" name="id2535037"></a>="<code class="sgmltag-attvalue">iso</code>" to generate a live system suitable for
              deployment on optical media (CD or DVD). Use the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="id2525483"></a>="<code class="sgmltag-attvalue">isoboot/suse-*</code>" attribute
              when generating this image type to select the apropriate
              boot image for optical media. In addition the optional
                <code class="sgmltag-attribute">flags</code><a class="indexterm" name="id2530208"></a> attribute may
              be set to the following values with the effects described
              below:</p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attvalue">clic</code></span></dt><dd><p>Creates a fuse based compressed read-only
                    filesystem which allows write operations into a cow
                    file. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">compressed</code></span></dt><dd><p>Compressed filesystem with squashfs mounted with
                    an aufs based overlay mount to allow read-write
                    access. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">unified</code></span></dt><dd><p>Compressed &#64257;lesystem with squashfs mounted with
                    an aufs based overlay mount to allow read-write
                    access.</p></dd></dl></div><p>If the flags attribute is not used the filesystem will
              not be compressed and no union filesystem is used. In this
              case it is recommended to specify a
                <code class="sgmltag-element">split</code> section as a child of this type
              element. The specification of a split block is also
              recommended when <code class="sgmltag-attribute">flags</code><a class="indexterm" name="id2511017"></a>="<code class="sgmltag-attvalue">compressed</code>" is used. </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="id2529184"></a>="<code class="sgmltag-attvalue">oem</code>"</span></dt><dd><p>Use this type to create a virtual disk system suitable
              in a preload setting. In addition specify the attributes
                <code class="sgmltag-attribute">filesystem</code><a class="indexterm" name="id2488302"></a>, and
                <code class="sgmltag-attribute">boot</code><a class="indexterm" name="id2488315"></a>="<code class="sgmltag-attvalue">oemboot/suse-*</code>" to control
              the filesystem used for the virtual and to specify the
              proper boot image. Using the optional <code class="sgmltag-attribute">format</code><a class="indexterm" name="id2488338"></a> attribute and
              setting, the value to iso or usb will create self
              installing images suitable for optical media or a USB
              stick, respectively. Booting from the media will deploy
              the OEM preload image onto the selected storage device of
              the system. It is also possible to configure the system to
              use logical volumes. Use the optional <code class="sgmltag-attribute">lvm</code><a class="indexterm" name="id2488359"></a> attribute and specify
              the logical volume configuration with the
                <code class="sgmltag-element">lvmvolumes</code> child element. The default
              volume group name is kiwiVG. Further configuration of the
              image is performed using the appropriate
                <code class="sgmltag-element">*config</code> child block. </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="id2488391"></a>="<code class="sgmltag-attvalue">pxe</code>"</span></dt><dd><p>Creating a network boot image is supported by KIWI
              with the image="pxe" type. When specifying the creation of
              a netwoork boot image use the <code class="sgmltag-attribute">filesystem</code><a class="indexterm" name="id2488419"></a> and boot="netboot/suse-*"
              attributes to specify the filesystem of the image and the
              proper boot image. To compress the image file set the
                <code class="sgmltag-attribute">compressed</code><a class="indexterm" name="id2488436"></a> boolean
              attribute to true. This setting will compress the image
              file and has no influence on the filesystem used within
              the image. The compression is often use to support better
              transfer times when the pxe image is pushed to the boot
              server over a network connection. The pxe image layout is
              controlled by using the <code class="sgmltag-element">pxedeploy</code> child
              element. </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="id2530376"></a>="<code class="sgmltag-attvalue">split</code>"</span></dt><dd><p>The split image support allows the creation of an
              image as split files. Using this technique one can assign
              different filesystems and different read-write properties
              to the different sections of the image. The
                <code class="sgmltag-element">oem</code>, <code class="sgmltag-element">pxe</code>,
                <code class="sgmltag-element">usb</code>, and <code class="sgmltag-element">vmx</code> types
              can be created as a split system image. Use the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="id2502800"></a>="<code class="sgmltag-attvalue">oem|netboot|usb|vmx/suse-*</code>"
              attribute to select the underlying type of the split
              image. The attributes <code class="sgmltag-attribute">fsreadwrite</code><a class="indexterm" name="id2502821"></a>, <code class="sgmltag-attribute">fsreadonly</code><a class="indexterm" name="id2502835"></a> are used to controll the
              read-write properties of the filesystem specified as the
              attributes value. Use the appropriate
                <code class="sgmltag-element">*config</code> child block to specify the
              properties of the underlying image. For example when
              building a OEM based split image use the
                <code class="sgmltag-element">oemconfig</code> child section. </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="id2502869"></a>="<code class="sgmltag-attvalue">usb</code>"</span></dt><dd><p>Use the usb value to create a USB stick image. Set the
                <code class="sgmltag-attribute">filesystem</code><a class="indexterm" name="id2502895"></a>
              attribute to the desired supported filesystem for the
              image and use the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="id2502910"></a>="<code class="sgmltag-attvalue">usbboot/suse-*</code>" attribute to select the USB
              boot image for the system. For a USB image you may also
              select GRUB or Syslinux as a bootloader by setting the
              optional <code class="sgmltag-attribute">bootloader</code><a class="indexterm" name="id2502933"></a>
              attribute to grub or syslinux, respectively. The boot timeout
              value my be set by using the optional 
              <code class="sgmltag-attribute">boottimeout</code><a class="indexterm" name="id2502950"></a> attribute.
              The unit for the timeout value is seconds if GRUB is used
              as the boot loader and 1/10 seconds if syslinux is used as
              the boot loader. The USB image may also be created with LVM
              support. The same rules as indicated for the OEM image
              apply. </p></dd><dt><span class="term"><code class="sgmltag-attribute">image</code><a class="indexterm" name="id2502976"></a>="<code class="sgmltag-attvalue">vmx</code>"</span></dt><dd><p>Creation of a virtual disk system is enabled with the
              vmx value of the image attribute. Set the filesystem of
              the virtual disk with the filesystem attribute and select
              the appropriate boot image by setting <code class="sgmltag-attribute">boot</code><a class="indexterm" name="id2503004"></a>="<code class="sgmltag-attvalue">vmxboot/suse-*</code>" The optional
              format attribute is used to specify one of the
              virtualization formats supported by QEMU, such as vmdk
              (also the VMware format) or qcow2. For the virtual disk
              image the optional vga attribute may be used to configure
              the kernel framebuffer device. Acceptable values can be
              found in the Linux kernel documentation for the
              framebuffer device (see
                <code class="filename">Documentation/fb/vesafb.txt</code>). KIWI
              also supports the selection of the booloader for the
              virtual disk according to the rules indicated for the USB
              system. Last but not least the virtual disk system may
              also be created with a LVM based layout by using the
                <code class="sgmltag-attribute">lvm</code><a class="indexterm" name="id2503042"></a> attribute. The
              previously indicated rules apply. Use the
                <code class="sgmltag-element">machine</code> child element to specify
              appropriate configuration of the virtual disk system.
            </p></dd></dl></div><p>All of the mentioned types can specify the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="id2503070"></a> attribute which tells KIWI to
        call itself to build the requested boot image (initrd). It is
        possible to tell KIWI to check for an already built boot image
        which is a so called <span class="emphasis"><em>prebuilt boot image</em></span>.
        To activate searching for an appropriate prebuilt boot image the
        type section also provides the attribute <code class="sgmltag-attribute">checkprebuilt</code><a class="indexterm" name="id2503094"></a>="<code class="sgmltag-attvalue">true|false</code>". If specified KIWI will
        search for a prebuilt boot image in a directory named
          <code class="filename">/usr/share/kiwi/image/*boot/*-prebuilt</code>.
        Example: If the <code class="sgmltag-attribute">boot</code><a class="indexterm" name="id2503121"></a>
        attribute was set to <code class="sgmltag-attvalue">isoboot/suse-10.3</code> and <code class="sgmltag-attribute">checkprebuilt</code><a class="indexterm" name="id2503141"></a> is set to <code class="sgmltag-attvalue">true</code> KIWI will search the prebuilt boot image in
          <code class="filename">/usr/share/kiwi/image/isoboot/suse-10.3-prebuilt</code>.
        The directory KIWI searches for the prebuilt boot images can
        also be specified at the commandline with the
          <code class="option">--prebuiltbootimage</code> parameter. </p><p>Within the preferences section there are the following
        optional attributes: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">rpm-check-signatures</code><a class="indexterm" name="id2503186"></a></span></dt><dd><p>Specifies whether RPM should check the package
              signature or not </p></dd><dt><span class="term"><code class="sgmltag-attribute">rpm-excludedocs</code><a class="indexterm" name="id2503212"></a></span></dt><dd><p> Specifies whether RPM should skip installing package
              documentation </p></dd><dt><span class="term"><code class="sgmltag-attribute">rpm-force</code><a class="indexterm" name="id2503238"></a></span></dt><dd><p>Specifies whether RPM should be called with
                <code class="option">--force</code>
            </p></dd><dt><span class="term"><code class="sgmltag-attribute">keytable</code><a class="indexterm" name="id2503267"></a></span></dt><dd><p>Specifies the name of the console keymap to use. The
              value corresponds to a map file in
                <code class="filename">/usr/share/kbd/keymaps</code>. The
                <code class="varname">KEYTABLE</code> variable in
                <code class="filename">/etc/sysconfig/keyboard</code> file is set
              according to the keyboard mapping. </p></dd><dt><span class="term"><code class="sgmltag-attribute">timezone</code><a class="indexterm" name="id2503310"></a></span></dt><dd><p>Specifies the time zone. Available time zones are
              located in the <code class="filename">/usr/share/zoneinfo</code><a class="indexterm" name="id2503332"></a> directory. Specify the
              attribute value relative to <code class="filename">/usr/share/zoneinfo</code><a class="indexterm" name="id2503349"></a>. For example, specify
              Europe/Berlin for
                <code class="filename">/usr/share/zoneinfo/Europe/Berlin</code>.
              KIWI uses this value to configure the timezone in
                <code class="filename">/etc/localtime</code> for the image. </p></dd><dt><span class="term"><code class="sgmltag-attribute">locale</code><a class="indexterm" name="id2503385"></a></span></dt><dd><p> Specifies the name of the UTF-8 locale to use, which
              defines the contents of the <code class="envar">RC_LANG</code><a class="indexterm" name="id2503402"></a> system
              environment variable in
                <code class="filename">/etc/sysconfig/language</code>. Please
              note only UTF-8 locales are supported here which also
              means that the encoding must <span class="emphasis"><em>not</em></span> be
              part of the locale information. The KIWI schema validates
              the locale string according to the following
                pattern:<code class="literal">[a-z]{2}_[A-Z]{2}(,[a-z]{2}_[A-Z]{2})*</code>.
              This means you have to specifiy the locale like the
              following example: en_US or en_US,de_DE </p></dd><dt><span class="term"><code class="sgmltag-attribute">boot-theme</code><a class="indexterm" name="id2503446"></a></span></dt><dd><p>Specifies the name of the gfxboot and bootsplash theme
              to use </p></dd><dt><span class="term"><code class="sgmltag-attribute">defaultdestination</code><a class="indexterm" name="id2503472"></a></span></dt><dd><p>Used if the <code class="option">--destdir</code> option is not
              specified when calling KIWI</p></dd><dt><span class="term"><code class="sgmltag-attribute">defaultroot</code><a class="indexterm" name="id2546150"></a></span></dt><dd><p>Used if the option <code class="option">--root</code> is not
              specified when calling KIWI </p></dd><dt><span class="term"><code class="sgmltag-attribute">defaultbaseroot</code><a class="indexterm" name="id2546178"></a></span></dt><dd><p>Used if the option <code class="option">--base-root</code> is not
              specified when calling KIWI. It&#8217;s possible to prepare and
              create an image using a predefined non empty root
              directory as base information. This could speedup the
              build process a lot if the base root path already contains
              most of the image data. </p></dd><dt><span class="term"><code class="sgmltag-attribute">kernelcmdline</code><a class="indexterm" name="id2546215"></a></span></dt><dd><p> Specifies additional kernel parameters. The following
              example disables kernel messages:
                <code class="literal">kernelcmdline="quiet"</code>
            </p></dd></dl></div><p>The <code class="sgmltag-element">type</code> element may contain child
        elements to provide specific configuration information for the
        given type. The following lists the supported child elements: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-element">ec2config</code></span></dt><dd><p>The optional ec2config block is used to specify
              information relevant only to AWS EC2 images. The following
              information can be provided: </p><pre class="screen">&lt;ec2config&gt;
  &lt;ec2accountnr&gt; Your AWS account number &lt;/ec2accountnr&gt; 
  &lt;ec2certfile&gt; Path to the AWS cert-*.pem file &lt;/ec2certfile&gt;
  &lt;ec2privatekeyfile&gt; Path to the AWS pk-*.pem file &lt;/ec2privatekeyfile&gt;
&lt;/ec2config&gt;</pre></dd><dt><span class="term"><code class="sgmltag-element">lvmvolumes</code></span></dt><dd><p>Using the optional lvmvolumes section it possible to
              create a LVM (Logical Volume Management) based storage
              layout. By default, the volume group is named kiwiVG. It
              is possible to change the name of the group by setting the
                <code class="sgmltag-attribute">lvmgroup</code><a class="indexterm" name="id2546298"></a> attribute
              to the desired name. Individual volumes within the volume
              group are specified using the <code class="sgmltag-element">volume</code>
              element. </p><p>The following example shows the creation of a volume
              named usr and a volume named var inside the volume group
              systemVG. </p><pre class="screen"> &lt;lvmvolumes lvmgroup="systemVG"&gt; 
  &lt;volume name="usr" freespace="100M"/&gt; 
  &lt;volume name="var" size="200M"/&gt; 
&lt;/lvmvolumes&gt;</pre><p>With the optional <code class="sgmltag-attribute">freespace</code><a class="indexterm" name="id2546334"></a> attribute it is possible to add
              space to the volume. If the freespace attribute is not set
              the created volume will be 80&#8201;% to 90&#8201;% full. Using the
              optional <code class="sgmltag-attribute">size</code><a class="indexterm" name="id2546353"></a>
              attribute the absolute size of the given volume is
              specified. The size attribute takes precedence over the
              freespace attribute. Should the specified size be too
              small the value will be ignored and a volume with
              approximately 80&#8201;% to 90&#8201;% fill will be created. </p></dd><dt><span class="term"><code class="sgmltag-element">oemconfig</code></span></dt><dd><p>By default, the oemboot process will create or modify
              a swap, <code class="filename">/home</code> and
                <code class="filename">/</code> partition. It is possible to
              influence the behavior by the <code class="filename">oem-*</code>
              elements explained below. KIWI uses this information to
              create the file <code class="filename">/config.oempartition</code>
              as part of the automatically created oemboot boot image.
              The format of the file is a simple
                <code class="literal">key=value</code> format and created by the
                <span class="command"><strong>KIWIConfig.sh</strong></span> function named
                <code class="function">baseSetupOEMPartition</code>. </p><pre class="screen">&lt;oemconfig&gt;
   &lt;oem-systemsize&gt;2000&lt;/oem-systemsize&gt;
   &lt;oem-... &gt; 
&lt;/oemconfig&gt;</pre><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-boot-title&gt;</code>text<code class="sgmltag-endtag">&lt;/oem-boot-title&gt;</code></span></dt><dd><p>By default, the string <span>OEM</span> will be used as the boot manager
                    menu entry when KIWI creates the GRUB configuration
                    during deployment. The
                      <code class="sgmltag-element">oem-boot-title</code> element allows
                    you to set a custom name for the grub menu entry.
                    This value is represented by the
                      <code class="varname">OEM_BOOT_TITLE</code> variable in
                      <code class="filename">config.oempartition</code>. </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-home&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-home&gt;</code></span></dt><dd><p>Specify if a partition for the home directory
                    should be created. Creation of a home partition is
                    the default behavior. This value is represented by
                    the <code class="varname">OEM_WITHOUTHOME</code> variable in
                      <code class="filename">config.oempartition</code>. </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-kiwi-initrd&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-kiwi-initrd&gt;</code></span></dt><dd><p>If this element is set to true (default value is
                    false) the oemboot boot image (initrd) will
                      <span class="emphasis"><em>not</em></span> be replaced by the system
                    (mkinitrd) created initrd. This option is useful
                    when the system is installed on removable storage
                    such as a USB stick or a portable external drive.
                    For movable devices it is potentially necessary to
                    detect the storage location during every boot. This
                    detection process is part of the oemboot boot image.
                    This value is represented by the
                      <code class="varname">OEM_KIWI_INITRD</code> variable in
                      <code class="filename">config.oempartition</code>. </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-reboot&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-reboot&gt;</code></span></dt><dd><p>Specify if the system is to be rebooted after
                    the oem image has been deployed to the designated
                    storage device (default value is false). This value
                    is represented by the <code class="varname">OEM_REBOOT</code>
                    variable in
                    <code class="filename">config.oempartition</code>. </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-recovery&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-recovery&gt;</code></span></dt><dd><p>If this element is set to true (default value is
                    false), KIWI will create a recovery archivefrom the
                    prepared root tree. The archive will appear as
                      <code class="filename">/recovery.tar.bz2</code> in the
                    image file. During first boot of the image a single
                    recovery partition will be created and the recovery
                    archive will be moved to the recovery partition. An
                    additional boot menu entry is created that when
                    selected restores the original root tree on the
                    system. The user information on the <code class="filename">/home</code><a class="indexterm" name="id2546640"></a> partition or in
                    the <code class="filename">/home</code><a class="indexterm" name="id2546656"></a>
                    directory is not affected by the recovery process.
                    This value is represented by the OEM_RECOVERY
                    variable in
                    <code class="filename">config.oempartition</code>. </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-recoveryID&gt;</code>partition-id<code class="sgmltag-endtag">&lt;/oem-recoveryID&gt;</code></span></dt><dd><p>Specify the partition type for the recovery
                    partition. The default is to create a Linux
                    partition (id&#8201;=&#8201;83). This value is represented by
                    the <code class="varname">OEM_RECOVERY_ID</code> variable in
                      <code class="filename">config.oempartition</code>. </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-swap&gt;</code>true|false<code class="sgmltag-endtag">&lt;/oem-swap&gt;</code></span></dt><dd><p>Specify if a sawp partition should be created.
                    The creation of a swap partition is the default
                    behavior. This value is represented by the
                      <code class="varname">OEM_WITHOUTSWAP</code> variable in
                      <code class="filename">config.oempartition</code>. </p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-swapsize&gt;</code>number in MB<code class="sgmltag-endtag">&lt;/oem-swapsize&gt;</code></span></dt><dd><p>Set the size of the swap partition. If a swpa
                    partition is to be created and the size of the swap
                    partition is not specified with this optional
                    element, KIWI will calculate the size of the swpar
                    partition and create a swap partition equal to two
                    times the RAM installed on the system at initial
                    boot time. This value is represented by the
                      <code class="varname">OEM_SWAPSIZE</code> variable in
                      <code class="filename">config.oempartition</code>.</p></dd><dt><span class="term"><code class="sgmltag-starttag">&lt;oem-systemsize&gt;</code>number in MB<code class="sgmltag-endtag">&lt;/oem-systemsize&gt;</code></span></dt><dd><p>Set the size of the root partition. This value
                    is represented by the variable
                      <code class="varname">OEM_SYSTEMSIZE</code> in
                      <code class="filename">config.oempartition</code>. </p></dd></dl></div></dd><dt><span class="term"><code class="sgmltag-element">pxedeploy</code></span></dt><dd><p>Information contained in the optional
                <code class="sgmltag-element">pxedeploy</code> section is only considered
              if the <code class="sgmltag-attribute">image</code><a class="indexterm" name="id2486924"></a>
              attribute of the <code class="sgmltag-element">type</code> element is set to
                <code class="sgmltag-attvalue">pxe</code>. In order to use
              a PXE image it is necessary to create a network boot
              infrastructure. Creation of the network boot
              infrastructure is simplified by the KIWI provided package
                <span class="package">kiwi-pxeboot</span>. This package configures
              the basic PXE boot enviroment as expected by KIWI pxe
              images. The <span class="package">kiwi-pxeboot</span> package
              creates a directory structure in
                <code class="filename">/srv/tftpboot</code>. Files created by the
              KIWI create step need to be copied to the
                <code class="filename">/srv/tftpboot</code> directory structure.
              For additional details about the PXE image please refere
              to the PXE Image chapter later in this document. </p><p>In addition to the image files it is necessary that
              information be provided about the client setup. This
              information, such as the image to be used or the
              partitioning, is contained in a file with the name
                  <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>
              in the directory <code class="filename">/srv/tftpboot/KIWI</code>.
              The content of this file is created automatically by KIWI
              if the pexedeploy section is provided in the image
              description. A pxedeploy section is outlined below: </p><pre class="screen">&lt;pxedeploy server="IP" blocksize="4096"&gt;
   &lt;timeout&gt;seconds&lt;/timeout&gt;
   &lt;kernel&gt;kernel-file&lt;/kernel&gt;
   &lt;initrd&gt;initrd-file&lt;/initrd&gt; 
   &lt;partitions device="/dev/sda"&gt; 
     &lt;partition type="swap" number="1" size="MB"/&gt; 
     &lt;partition type="L" number="2" size="MB"
              mountpoint="/" target="true"/&gt; 
     &lt;partition type="fd"  number="3"/&gt; 
   &lt;/partitions&gt; 
   &lt;union ro="dev" rw="dev" type="aufs|clicfs|unionfs"/&gt; 
   &lt;configuration source="/KIWI/../file" dest="/../file" arch="..."/&gt;
   &lt;configuration .../&gt; 
&lt;/pxedeploy&gt; </pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The <code class="sgmltag-attribute">server</code><a class="indexterm" name="id2547085"></a>
                  attribute is used to specify the IP address of the PXE
                  server. The <code class="sgmltag-attribute">blocksize</code><a class="indexterm" name="id2547100"></a> attributes specifies the
                  blocksize for the image download. Other protocols are
                  supported by KIWI but require the
                    <em class="parameter"><code>kiwiserver</code></em> and
                    <em class="parameter"><code>kiwiservertype</code></em> kernel
                  parameters to be set when the client boots. </p></li><li class="listitem"><p>The value of the optional
                    <code class="sgmltag-element">timeout</code> element specifies the
                  grub timeout in seconds to be used when the KIWI
                  initrd configures and installs the grub boot loader on
                  the client machine after the first deployment to allow
                  standalone boot. </p></li><li class="listitem"><p>Passing kernel parameters is possible with the use
                  of the optional <code class="sgmltag-attribute">kernelcmdline</code><a class="indexterm" name="id2547150"></a> attribute in the
                    <code class="sgmltag-element">type</code> section. The value of this
                  attribute is a string specifying the settings to be
                  passed to the kernel by the GRUB bootloader. The KIWI
                  initrd includes these kernel options when installing
                  grub for standalone boot </p></li><li class="listitem"><p>The optional <code class="sgmltag-element">kernel</code> and
                    <code class="sgmltag-element">initrd</code> elements are used to
                  specify the file names for the kernel and initrd on
                  the boot server respectively. When using a special
                  boot method not supported by the distribution&#8217;s
                  standard mkinitrd, it is imperative that the KIWI
                  initrd remains on the PXE server and also be used for
                  local boot. If the configured image uses the
                    <code class="sgmltag-element">split</code> type or the
                    <code class="sgmltag-element">pexedeploy</code> section includes any
                  union information the kernel and initrd elements must
                  be used. </p></li><li class="listitem"><p>The <code class="sgmltag-element">partitions</code> section is
                  required if the system image is to be installed on a
                  disk or other permanent storage device. Each partition
                  is specified with one partition child element. The
                  mandatory type attribute specifies the partition type.
                  The possible values are the sfdisk supported types,
                  use the following command to obtain a list of
                  supported values: </p><pre class="screen"><span class="command"><strong>sfdisk</strong></span> --list-type </pre><p>The required <code class="sgmltag-attribute">number</code><a class="indexterm" name="id2547239"></a> attribute provides the number
                  of the partition to be created. The size of the
                  partition may be specified with the optional size
                  attribute. The optional mountpoint attribute provides
                  the value for the mount point of the partition. The
                  optional boolean target attribute identifies the
                  partion as the system image target partition. KIWI
                  always generates the swap partition as the first
                  partition of the netboot boot image. By default, the
                  second partition is used for the system image. Use the
                  boolean <code class="sgmltag-attribute">target</code><a class="indexterm" name="id2547263"></a>
                  attribute to change this behavior. Providing the value
                  image for the <code class="sgmltag-attribute">size</code><a class="indexterm" name="id2547277"></a> attribute triggers KIWI into
                  calculating the required size for this partition. The
                  calculated size is sufficient for the created image.
                </p></li><li class="listitem"><p>If the system image is based on a read-only
                  filesystem such as squashfs and should be mounted in
                  read-write mode use the optional union element. The
                  type attribute is used to specify one of the supported
                  overlay filesystem (<code class="systemitem">aufs</code><a class="indexterm" name="id2547307"></a>, <code class="systemitem">clicfs</code><a class="indexterm" name="id2547321"></a>, or <code class="systemitem">unionfs</code><a class="indexterm" name="id2547336"></a>). Use the ro
                  attribute to point to the read only device and the rw
                  attribute to point to the read-write device. </p></li><li class="listitem"><p>The optional <code class="sgmltag-element">configuration</code>
                  element is used to integrate a network client&#8217;s
                  configuration files that are stored on the server. The
                  source attribute specifies the path on the server for
                  the file to be downloaded. The dest attribute
                  specifies destination of the downloaded file on the
                  network client starting at the root (/) of the
                  filesystem. Multiple configuration elements may be
                  specified such that multiple files can be transferred
                  to the network client. In addition configuration files
                  can be bound to a specific client architecture by
                  setting the optional arch attribute. To specify
                  multiple architectures use a comma separated string.
                </p></li></ul></div></dd><dt><span class="term"><code class="sgmltag-element">size</code></span></dt><dd><p>Use the size element to specify the image size in
              Megabytes or Gigabytes. The unit attribute specifies
              whether the given value will be interpreted as Megabytes
                (<code class="sgmltag-attribute">unit</code><a class="indexterm" name="id2547411"></a>="<code class="sgmltag-attvalue">M</code>") or Gigabytes (<code class="sgmltag-attribute">unit</code><a class="indexterm" name="id2547428"></a>="<code class="sgmltag-attvalue">G</code>"). The optional boolean
              attribute additive specifies whether or not the given size
              should be added to the size of the generated image or not. </p><p>In the event of a size specification that is too small
              for the generated image, KIWI will expand the size
              automatically unless the image size exceeds the specified
              size by 100&#8201;MB or more. In this case KIWI will generate an
              error and exit. </p><p>Should the given size exceed the necessary size for
              the image KIWI will not alter the image size as the free
              space might be required for proper execution of components
              within the image. </p><p>If the size element is not used KIWI will create an
              image with containing approxiamtely 30&#8201;% free space. </p><pre class="screen">&lt;size unit="M"&gt;1000&lt;/size&gt;</pre></dd><dt><span class="term"><code class="sgmltag-element">split</code></span></dt><dd><p>For images of type split or iso the information
              provided in the optional <code class="sgmltag-element">split</code> section
              is is considered if the compressed attribute is is set to
              true. With the configuration in this block it is possible
              to determine which files are writable and whether these
              files should be persentently writable or temporarily. Note
              that for ISO images only temporary write access is
              possible. </p><p>When processing the provided configuration KIWI
              distinguishes between directories and files. For example,
              providing <code class="filename">/etc</code><a class="indexterm" name="id2547516"></a> as
              the value of the name attribute indicates that the
                <code class="filename">/etc</code><a class="indexterm" name="id2547532"></a> directory
              should be writable. However, this does not include any of
              the files or sub-directories within <code class="filename">/etc</code><a class="indexterm" name="id2547549"></a>. The content of /etc
              is populated as symbolic links to the read-only files. The
              advantage of setting only a directory to read-write access
              is that any newly created files will be stored on the disk
              instead of in <code class="systemitem">tmpfs</code><a class="indexterm" name="id2547568"></a>. Creating read-write access to a
              directory and it&#8217;s files requires two specifications as
              showb below. </p><pre class="screen">&lt;split&gt; 
  &lt;temporary&gt; 
    <code class="sgmltag-sgmlcomment">&lt;!-- read/write access to --&gt;</code>
    &lt;file name="/var"/&gt; 
    &lt;file name="/var/*"/&gt; 
    <code class="sgmltag-sgmlcomment">&lt;!-- but not on this file: --&gt;</code>
    &lt;except name="/etc/shadow"/&gt; 
  &lt;/temporary&gt;
  &lt;persistent&gt;
    <code class="sgmltag-sgmlcomment">&lt;!-- persistent read/write access to: --&gt;</code>
    &lt;file name="/etc"/&gt; 
    &lt;file name="/etc/*"/&gt; 
    <code class="sgmltag-sgmlcomment">&lt;!-- but not on this file: --&gt;</code>
    &lt;except name="/etc/passwd"/&gt; 
  &lt;/persistent&gt;
&lt;/split&gt;</pre><p>Use the except element to specify exceptions to
              previously configured rules. </p></dd><dt><span class="term"><code class="sgmltag-element">machine</code></span></dt><dd><p>The optional machine section serves to specify
              information about a VM guest machine. Using the data
              provided in this section, KIWI will create a guest
              configuration file required to run the image on the target
              machine. </p><p>If the target is a VMware virtual machine indicated by
              the format attribute set to vmdk, KIWI creates a VMware
              configuration file. If the target is a Xen virtual machine
              indicated by the domain attribute in the machine section
              KIWI will create a Xen guest config file. </p><p>The sample block below shows the general outline of
              the information that can be specified to generate the
              configuration file </p><pre class="screen">&lt;machine arch="arch" memory="MB"
  HWversion="number" guestOS="suse|sles"
  domain="dom0|domU"/&gt; 
   &lt;vmnic driver="name" interface="number" mode="mode"/&gt; 
   &lt;vmdisk controller="ide|scsi" id="number"/&gt; 
   &lt;vmdvd  controller="ide|scsi" id="number"/&gt; 
&lt;/machine&gt; </pre><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">arch</code><a class="indexterm" name="id2547675"></a></span></dt><dd><p> The virtualized architecture. Supported values
                    are <code class="sgmltag-attvalue">ix86</code> or
                      <code class="sgmltag-attvalue">x86_64</code>. The
                    default value is <code class="sgmltag-attvalue">ix86</code>. </p></dd><dt><span class="term"><code class="sgmltag-attribute">memory</code><a class="indexterm" name="id2547716"></a></span></dt><dd><p> The mandatory <code class="sgmltag-attribute">memory</code><a class="indexterm" name="id2547733"></a> attribute specifies how much
                    memory in MB should be allocated for the virtual
                    machine </p></dd><dt><span class="term"><code class="sgmltag-attribute">HWversion</code><a class="indexterm" name="id2547754"></a></span></dt><dd><p> The VMware hardware version number, the default
                    value is <code class="sgmltag-attvalue">3</code>.
                  </p></dd><dt><span class="term"><code class="sgmltag-attribute">guestOS</code><a class="indexterm" name="id2547784"></a></span></dt><dd><p> The guest OS identifier. For the ix86
                    architecture the default value is suse and for the
                    x86_64 architecture suse-64 is the default. At this
                    point only the SUSE and SLES guestOS types are
                    supported. </p></dd><dt><span class="term"><code class="sgmltag-attribute">domain</code><a class="indexterm" name="id2547812"></a></span></dt><dd><p> The Xen domain setup. This could be either a
                    dom0 which is the host machine hosting the guests
                    and therefore doesn&#8217;t require a configuration file,
                    or it could be set to domU which indicates this is a
                    guest and also requires a guest configuration which
                    is created by KIWI. </p></dd></dl></div><p>The following information can be provided to setup the
              virtual main storage device and CD/DVD drive connection: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">controller</code><a class="indexterm" name="id2547857"></a></span></dt><dd><p> Supported values for the mandatory <code class="sgmltag-attribute">controller</code><a class="indexterm" name="id2547874"></a> attribute
                    are <code class="sgmltag-attvalue">ide</code> and
                      <code class="sgmltag-attvalue">scsi</code>. </p></dd><dt><span class="term"><code class="sgmltag-attribute">id</code><a class="indexterm" name="id2547904"></a></span></dt><dd><p>The mandatory <code class="sgmltag-attribute">id</code><a class="indexterm" name="id2547921"></a> attribute specifies the disk id. If
                    only one disk is set the id value should be set to
                    0. </p></dd><dt><span class="term"><code class="sgmltag-attribute">device</code><a class="indexterm" name="id2547942"></a></span></dt><dd><p> The device attribute specifies the disk that
                    should appear in the para virtual instance.
                    Therefore only relevant for Xen </p></dd></dl></div><p>The following information can be provided to setup the
              virtual network interface: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">driver</code><a class="indexterm" name="id2547976"></a></span></dt><dd><p> The mandatory <code class="sgmltag-attribute">driver</code><a class="indexterm" name="id2547993"></a> attribute specifies the driver
                    to be used for the virtual network card. The
                    supported values are <code class="sgmltag-attvalue">e100</code>, <code class="sgmltag-attvalue">vlance</code>, and <code class="sgmltag-attvalue">vmxnet</code>. If the vmxnet driver is
                    specified the vmware tools must be installed in the
                    image. </p></dd><dt><span class="term"><code class="sgmltag-attribute">interface</code><a class="indexterm" name="id2548032"></a></span></dt><dd><p> The mandatory <code class="sgmltag-attribute">interface</code><a class="indexterm" name="id2548049"></a> attribute specifies the
                    interface number. If only one interface is set the
                    value should be set to 0. </p></dd><dt><span class="term"><code class="sgmltag-attribute">mode</code><a class="indexterm" name="id2548071"></a></span></dt><dd><p> The network mode used to communicate outside
                    the VM. In many cases the bridged mode is used.
                  </p></dd></dl></div></dd></dl></div></div><div class="sect2" title="2.1.5. users Element"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.users"></a>2.1.5. <code class="sgmltag-element">users</code> Element<span class="permalink"><a alt="Permalink" title="2.1.5. users Element" href="#sec.description.users">¶</a></span></h3></div></div></div><pre class="screen">&lt;users group="group_name" id="number"&gt; 
  &lt;user home="dir" id="number" name="user" pwd="..."
        pwdformat="encrypted|plain" realname="string" shell="path/&gt;
  <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code>
&lt;/users&gt;</pre><p>The optional <code class="sgmltag-element">users</code> element lists the users belonging to the
        group specified with the <code class="sgmltag-attribute">group</code><a class="indexterm" name="id2548131"></a> attribute. At least one user
        child element must be specified as part of the <code class="sgmltag-element">users</code> element.
        Multiple users elements may be specified. </p><p>The attributes <code class="sgmltag-attribute">home</code><a class="indexterm" name="id2548153"></a>,
          <code class="sgmltag-attribute">id</code><a class="indexterm" name="id2548166"></a>, <code class="sgmltag-attribute">name</code><a class="indexterm" name="id2548178"></a>, <code class="sgmltag-attribute">pwd</code><a class="indexterm" name="id2548191"></a>, <code class="sgmltag-attribute">realname</code><a class="indexterm" name="id2548203"></a>,
        and <code class="sgmltag-attribute">shell</code><a class="indexterm" name="id2548216"></a> specify the
        created users home directory, the user name, the user&#8217;s
        password, the user&#8217;s real name, and the user&#8217;s login shell,
        respectively. By default, the value of the password attribute is
        expected to be an encrypted string. An encrypted password can be
        created using <span class="command"><strong>kiwi</strong></span>
        <code class="option">--createpassword</code>. It is also possible to
        specify the password as a non encrypted string by using the
        pwdformat attribute and setting it&#8217;s value to
          <span class="quote">&#8220;<span class="quote">plain</span>&#8221;</span>. KIWI will then encrypt the password
        prior to the user being added to the system. </p><p>All specified users and groups will be created if they do
        not already exist. By default, the defined users will be part of
        the group specified with the group attribute of the users
        element and the default group called <span class="quote">&#8220;<span class="quote">users</span>&#8221;</span>. If it
        is desired to have the specified users to only be part of the
        given group it is necessary to specify the <code class="sgmltag-attribute">id</code><a class="indexterm" name="id2548271"></a> attribute. It is recommended to
        use a group id greater than 100. </p></div><div class="sect2" title="2.1.6. drivers Element"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.drivers"></a>2.1.6. <code class="sgmltag-element">drivers</code> Element<span class="permalink"><a alt="Permalink" title="2.1.6. drivers Element" href="#sec.description.drivers">¶</a></span></h3></div></div></div><pre class="screen">&lt;drivers type="type" profiles="name"&gt; 
  &lt;file name="filename"/&gt; 
  <code class="sgmltag-sgmlcomment">&lt;!-- ... --&gt;</code> 
&lt;/drivers&gt;</pre><p>The optional <code class="sgmltag-element">drivers</code> element is only
        useful for boot images (initrd). As a boot image doesn&#8217;t need to
        contain the complete kernel one can save a lot of space if only
        the required drivers are part of the image. Therefore the
        drivers section exists. If present only the drivers which
        matches the file names or glob patterns will be included into
        the boot image. The <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2548327"></a>
        attribute specifies one of the following driver types: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">drivers</code><a class="indexterm" name="id2548347"></a></span></dt><dd><p> Each file is specified relative to the <code class="filename">/lib/modules/<em class="replaceable"><code>Version</code></em>/kernel</code><a class="indexterm" name="id2548370"></a>
              directory. </p></dd><dt><span class="term"><code class="sgmltag-attribute">netdrivers</code><a class="indexterm" name="id2548388"></a></span></dt><dd><p> Each file is specified relative to the <code class="filename">/lib/modules/<em class="replaceable"><code>Version</code></em>/kernel/drivers</code><a class="indexterm" name="id2548411"></a>
              directory. </p></dd><dt><span class="term"><code class="sgmltag-attribute">scsidrivers</code><a class="indexterm" name="id2548431"></a></span></dt><dd><p> Each file is specified relative to the
                  <code class="filename">/lib/modules/<em class="replaceable"><code>Version</code></em>/kernel/drivers</code>
            </p></dd><dt><span class="term"><code class="sgmltag-attribute">usbdrivers</code><a class="indexterm" name="id2548464"></a></span></dt><dd><p> Each file is specified relative to the
                  <code class="filename">/lib/modules/<em class="replaceable"><code>Version</code></em>/kernel/drivers</code>
              directory. </p></dd></dl></div><p>According to the <code class="sgmltag-element">driver</code> element the
        specified files are searched in the corresponding directory. The
        information about the driver names is provided as environment
        variable named like the value of the <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2548503"></a> attribute and is processed by the function
          <code class="function">suseStripKernel</code>. According to this along
        with a boot image description a script called
          <span class="command"><strong>images.sh</strong></span> must exist which calls this
        function in order to allow the driver information to have any
        effect. </p></div><div class="sect2" title="2.1.7. repository Element"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.repository"></a>2.1.7. <code class="sgmltag-element">repository</code> Element<span class="permalink"><a alt="Permalink" title="2.1.7. repository Element" href="#sec.description.repository">¶</a></span></h3></div></div></div><pre class="screen">&lt;repository type="type" status="replaceable"
        alias="name" priority="number"&gt; 
   &lt;source path="URL"/&gt;
&lt;/repository&gt;</pre><p>The mandatory <code class="sgmltag-element">repository</code> element
        specifies the source URL and type used by the package manager.
        The <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2548557"></a> attribute
        specifies the repository type which must be supported by the
        package manager. At the moment KIWI supports the package
        managers smart and zypper whereas smart has support for more
        repository types compared to zypper. Therefore the possible
        values for the type attribute has beend copied from smart. The
        following table shows the possible repo types:</p><div class="table"><a name="tab.description.supported-types"></a><p class="title"><b>Table 2.1. Supported Types for zypper and smart</b><span class="permalink"><a alt="Permalink" title="Table 2.1. Supported Types for zypper and smart" href="#tab.description.supported-types">¶</a></span></p><div class="table-contents"><table summary="Supported Types for zypper and smart" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Type</th><th>smart Support</th><th>zypper Support</th></tr></thead><tbody><tr><td>apt-deb</td><td>yes</td><td>no</td></tr><tr><td>apt-rpm</td><td>yes</td><td>no</td></tr><tr><td>deb-dir</td><td>yes</td><td>no</td></tr><tr><td>mirrors</td><td>yes</td><td>no</td></tr><tr><td>red-carpet</td><td>yes</td><td>yes</td></tr><tr><td>rpm-dir</td><td>yes</td><td>yes</td></tr><tr><td>rpm-md</td><td>yes</td><td>yes</td></tr><tr><td>slack-site</td><td>yes</td><td>no</td></tr><tr><td>up2date-mirrors</td><td>yes</td><td>no</td></tr><tr><td>urpmi</td><td>yes</td><td>no</td></tr><tr><td>yast2</td><td>yes</td><td>yes</td></tr></tbody></table></div></div><br class="table-break"><p>Within the repository section there are the following
        optional attributes: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">status</code><a class="indexterm" name="id2548764"></a>="<code class="sgmltag-attvalue">replaceable</code>"</span></dt><dd><p>This attribute makes only sense for boot image
              descriptions. It indicates that the repository is allowed
              to become replaced by the repositories defined in the
              system image descriptions. Because KIWI automatically
              builds the boot image if required it should create that
              image from the same repositories which are used to build
              the system image to make sure both fit together. Therefore
              it is required to allow the repository to become
              overwritten which is indicated by the status attribute.
            </p></dd><dt><span class="term"><code class="sgmltag-attribute">alias</code><a class="indexterm" name="id2548804"></a>="<code class="sgmltag-attvalue">name</code>"</span></dt><dd><p>Specifies an alternative name used to identify the
              source channel. If not set the source attribute value is
              used and builds the alias name by replacing each
                <span class="quote">&#8220;<span class="quote">/</span>&#8221;</span> with a <span class="quote">&#8220;<span class="quote">_</span>&#8221;</span>. An alias name
              should be set if the source argument doesn&#8217;t really
              explain what this repository contains </p></dd><dt><span class="term"><code class="sgmltag-attribute">priority</code><a class="indexterm" name="id2548848"></a>="<code class="sgmltag-attvalue">number</code>"</span></dt><dd><p>Specifies the repository priority assigned to all
              packages available in this repository. For smart the
              following applies: If the exact same package is available
              in more than one channel, the repository with the
                <span class="emphasis"><em>highest</em></span> priority number is used.
              The value 0 means <span class="quote">&#8220;<span class="quote">no priority is set</span>&#8221;</span>. For
              zypper the following applies: If the exact same package is
              available in more than one channel, the repository with
              the <span class="emphasis"><em>lowest</em></span> priority number is used.
              The value 99 means <span class="quote">&#8220;<span class="quote">no priority is
              set</span>&#8221;</span>.</p></dd></dl></div><p>The source child element contains the path attribute, which
        specifies the location (URL) of the repository. The path
        specification can be any of the following, and can include the
          <code class="systemitem">%arch</code><a class="indexterm" name="id2548906"></a> macro which is
        expanded to the architecture of the image building host. </p><div class="variablelist"><dl><dt><span class="term"><code class="uri">this://<em class="replaceable"><code>PATH</code></em></code></span></dt><dd><p>A relative path name, which is relative to the image
              description directory being referenced. </p></dd><dt><span class="term"><code class="uri">iso://<em class="replaceable"><code>path/to/isofile</code></em></code></span></dt><dd><p>A path to a local .iso file which is then loopback
              mounted and used as a local path based repository.
              Alternatively one can do the loop mount himself and point
              a standard local path to the mounted directory </p><p>When using multiple .iso files from the same product, such
              SLES all .iso files need to be located in the same directory,
              but only the first .iso file needs to be added as a repository
              to the configuration. The first .iso file contains sufficient
              information for the package management tool to find packages
              in the other .iso files as long as they are located in the
              same directory. Attempting to use a second or third .iso file
              in a series as a stand alone repository will result in an
              error.</p></dd><dt><span class="term"><code class="uri">http://<em class="replaceable"><code>URL</code></em></code></span></dt><dd><p>A http protocol based network location </p></dd><dt><span class="term"><code class="uri">https://<em class="replaceable"><code>URL</code></em></code></span></dt><dd><p>A https protocol based network location </p></dd><dt><span class="term"><code class="uri">ftp://<em class="replaceable"><code>URL</code></em></code></span></dt><dd><p>A ftp protocol based network location </p></dd><dt><span class="term"><code class="uri">opensuse://<em class="replaceable"><code>PROJECTNAME</code></em></code></span></dt><dd><p>A special http based network location which is created
              from the given openSUSE buildservice project name. The
              result is pointing to an rpm-md repository on the openSUSE
              buildservice. For example:
              path="opensuse://openSUSE:10.3/standard" </p></dd><dt><span class="term"><code class="uri">file:///local/path</code></span></dt><dd><p>A local path which should be an absolute path
              description. The file:// prefix is optional and could also
              be omitted. </p></dd><dt><span class="term"><code class="uri">obs://$dir1/$dir2</code></span></dt><dd><p>A special buildservice path whereas
                <code class="varname">$dir1</code> and <code class="varname">$dir2</code>
              represents the buildservice project location. If this type
              is used as part of a boot attribute KIWI evaluates it to
                <code class="uri">this://images/$dir1/$dir2</code> and if used as part
              of a repository source path attribute it evaluates to
                <code class="uri">this://repos/$dir1/$dir2</code>
            </p></dd></dl></div></div><div class="sect2" title="2.1.8. packages Element"><div class="titlepage"><div><div><h3 class="title"><a name="sec.description.packages"></a>2.1.8. <code class="sgmltag-element">packages</code> Element<span class="permalink"><a alt="Permalink" title="2.1.8. packages Element" href="#sec.description.packages">¶</a></span></h3></div></div></div><pre class="screen">&lt;packages type="type" profiles="name" patternType="type"
        patternPackageType="type" 
   &lt;package name="name" arch="arch"/&gt; 
   &lt;package name="name" replaces="name"/&gt;
   &lt;package name="name" bootinclude="true" bootdelete="true"/&gt; 
   &lt;archive name="name" bootinclude="true"/&gt; 
   &lt;package .../&gt; 
   &lt;opensusePattern name="name"/&gt; 
   &lt;opensusePattern .../&gt;
   &lt;opensuseProduct name="name"/&gt; 
   &lt;opensuseProduct .../&gt; 
   &lt;ignore name="name"/&gt; 
   &lt;ignore .../&gt;
&lt;/packages&gt;</pre><p>The mandatory <code class="sgmltag-element">packages</code> element specifies
        the list of packages (element <code class="sgmltag-element">package</code>) and
        patterns (element <code class="sgmltag-element">opensusePattern</code>) to be used
        with the image. The value of the <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2549134"></a> attribute specifies how the packages and
        patterns listed are handled, supported values are as follows: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attvalue">bootstrap</code></span></dt><dd><p>Bootstrap packages, list of packages for the new
              operating system root tree. The packages list the required
              components to support a chroot environment in the new
              system root tree, such a glibc. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">delete</code></span></dt><dd><p>Delete packages, list of packages to be deleted from
              the image being created. </p><p>When using the delete type only
                <code class="sgmltag-element">package</code> elements are considered, all
              other specifications such as
                <code class="sgmltag-element">opensusePattern</code> are ignored. The
              given package names are stored in the
                $<code class="envar">delete</code><a class="indexterm" name="id2549198"></a> environment variable of the
                <code class="filename">/.profile</code> file created by KIWI. The
              list of package names is returned by the
                <code class="function">baseGetPackagesForDeletion</code>
              function. This list can then be used to delete the
              packages ignoring requirements or dependencies. This can
              be accomplished in the <span class="command"><strong>config.sh</strong></span> or
                <span class="command"><strong>images.sh</strong></span> script with the following
              code snippet: </p><pre class="screen"><span class="command"><strong>rpm</strong></span> -e --nodeps --noscripts \
$(<span class="command"><strong>rpm</strong></span> -q &#8216;baseGetPackagesForDeletion&#8216; | <span class="command"><strong>grep</strong></span> -v "is not installed")</pre><p>Note, that the delete value is indiscriminate of the
              image type being built. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">image</code></span></dt><dd><p>Image packages, list of packages to be installed in
              the image. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">iso</code></span></dt><dd><p>Image packages, a list of additional packages to be
              installed when building an ISO image. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">oem</code></span></dt><dd><p>Image packages, a list of additional packages to be
              installed when building an OEM image. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">pxe</code></span></dt><dd><p>Image packages, a list of additional packages to be
              installed when building an PXE image. </p></dd><dt><span class="term"><code class="sgmltag-attvalue">usb</code></span></dt><dd><p>Image packages, a list of additional packages to be
              installed when building a USB image.</p></dd><dt><span class="term"><code class="sgmltag-attvalue">vmx</code></span></dt><dd><p>Image packages, a list of additional packages to be
              installed when building a vmx virtual image of any format.
            </p></dd></dl></div><div class="sect3" title="2.1.8.1. Using Patterns"><div class="titlepage"><div><div><h4 class="title"><a name="sec.descriptions.using-patterns"></a>2.1.8.1. Using Patterns<span class="permalink"><a alt="Permalink" title="2.1.8.1. Using Patterns" href="#sec.descriptions.using-patterns">¶</a></span></h4></div></div></div><a class="indexterm" name="id2549381"></a><p> Using a pattern name enhances the package list with a
          number of additional packages belonging to this pattern.
          Support for patterns is SUSE-specific, and available with
          openSUSE 10.1 or later. The optional <code class="sgmltag-attribute">patternType</code><a class="indexterm" name="id2549403"></a> and <code class="sgmltag-attribute">patternPackageType</code><a class="indexterm" name="id2549416"></a> attributes
          specify which pattern references or packages should be used in
          a given pattern. The values of these attributes are only
          evaluated, if the KIWI pattern solver is used. If the new (up
          to SUSE 11.0) satsolver pattern solver is used these values
          are ignored because the satsolver can&#8217;t handle that at the
          moment. Allowed values for the <code class="sgmltag-attribute">pattern*</code><a class="indexterm" name="id2549442"></a> attributes are: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">only</code><a class="indexterm" name="id2549461"></a></span></dt><dd><p>RequiredIncorporates only patterns and packages that
                are required by the given pattern </p></dd><dt><span class="term"><code class="sgmltag-attribute">plusSuggested</code><a class="indexterm" name="id2549486"></a></span></dt><dd><p>Incorporates patterns and packages that are required
                and suggested by the given pattern </p></dd><dt><span class="term"><code class="sgmltag-attribute">plusRecommended</code><a class="indexterm" name="id2549511"></a></span></dt><dd><p>Incorporates patterns and packages that are required
                and recommended by the given pattern. </p></dd></dl></div><p>By default, only required patterns and packages are used.
          The result list of packages is solved into a clean conflict
          free list of packages by the package manager. This for example
          means that including a suggested package may include required
          and recommended packages as well according to the
          dependencies. If a pattern contains unwanted packages, you can
          use the ignore element to specify an ignore list, with the
          name attribute containing the package name. Please note that
          you can&#8217;t ignore a package if it is required by a package
          dependency of another package in your list. The package
          manager will automatically pull in the package even if you
          have ignored it. </p></div><div class="sect3" title="2.1.8.2. Architecture Restrictions"><div class="titlepage"><div><div><h4 class="title"><a name="sec.description.architecture-restrictions"></a>2.1.8.2. Architecture Restrictions<span class="permalink"><a alt="Permalink" title="2.1.8.2. Architecture Restrictions" href="#sec.description.architecture-restrictions">¶</a></span></h4></div></div></div><a class="indexterm" name="id2549570"></a><p> To restrict a package to a specific architecture, use the
          arch attribute to specify a comma separated list of allowed
          architectures. Such a package is only installed if the build
          systems architecture (<span class="command"><strong>uname</strong></span>
          <code class="option">-m</code>) matches one of the specified values of
          the arch attribute. </p></div><div class="sect3" title="2.1.8.3. Image Type Specific Packages"><div class="titlepage"><div><div><h4 class="title"><a name="sec.description.image-type-specific-packages"></a>2.1.8.3. Image Type Specific Packages<span class="permalink"><a alt="Permalink" title="2.1.8.3. Image Type Specific Packages" href="#sec.description.image-type-specific-packages">¶</a></span></h4></div></div></div><p> If a package is only required for a specific type of
          image and replaces another package you can use the replaces
          attribute to tell KIWI to install the package by replacing
          another one. For example you can specify the kernel package in
          the <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2549620"></a>="<code class="sgmltag-attvalue">image</code>" section as </p><pre class="screen">&lt;package name="kernel-default" replaces="kernel-xen"/&gt;</pre><p>and in the type="xen" section as </p><pre class="screen">&lt;package name="kernel-xen"  replaces="kernel-default"/&gt; </pre><p>The result is the xen kernel if you request a xen image
          and the default kernel in any other case. </p></div><div class="sect3" title="2.1.8.4. Packages to Become Included Into the Boot Image"><div class="titlepage"><div><div><h4 class="title"><a name="sec.description.packages.to.become.included"></a>2.1.8.4. Packages to Become Included Into the Boot Image<span class="permalink"><a alt="Permalink" title="2.1.8.4. Packages to Become Included Into the Boot Image" href="#sec.description.packages.to.become.included">¶</a></span></h4></div></div></div><p> The optional attributes bootinclude and bootdelete can be
          used to mark a package inside the system image description to
          become part of the corresponding boot image (initrd). This
          feature is most often used to specify bootsplash and/or
          graphics boot related packages inside the system image
          description but they are required to be part of the boot image
          as the data is used at boot time of the image. If the
          bootdelete attribute is specified along with the bootinclude
          attribute this means that the selected package will be marked
          as a <span class="quote">&#8220;<span class="quote">to become deleted</span>&#8221;</span> package and is removed
          by the contents of the <span class="command"><strong>images.sh</strong></span> script of
          the corresponding boot image description </p></div><div class="sect3" title="2.1.8.5. Data not Available as Packages to Become Included"><div class="titlepage"><div><div><h4 class="title"><a name="sec.description.data.not.available"></a>2.1.8.5. Data not Available as Packages to Become Included<span class="permalink"><a alt="Permalink" title="2.1.8.5. Data not Available as Packages to Become Included" href="#sec.description.data.not.available">¶</a></span></h4></div></div></div><p> With the optional <code class="sgmltag-element">archive</code> element it&#8217;s
          possible to include any kind of data into the image. The
          archive elements expects the name of a tarball which must
          exist as part of the system image description. KIWI then picks
          up the tarball and installs it into the image. If the
          bootinclude attribute is set along with the archive element
          the data will also become installed into the boot image.
        </p></div></div></div></div><div class="chapter" title="Chapter 3. Creating Appliances with KIWI"><div class="titlepage"><div><div><h2 class="title"><a name="chap.appliance"></a>Chapter 3. Creating Appliances with KIWI</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.appliance.history">3.1. History</a></span></dt><dt><span class="sect1"><a href="#sec.appliance.kiwi-model">3.2. The KIWI Model</a></span></dt></dl></div><div class="sect1" title="3.1. History"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.appliance.history"></a>3.1. History<span class="permalink"><a alt="Permalink" title="3.1. History" href="#sec.appliance.history">¶</a></span></h2></div></div></div><a class="indexterm" name="id2549740"></a><p> Traditionally, many computing functions were written as
      software applications running on top of a general-purpose
      operating system. The consumer (whether home computer user or the
      IT department of a company) bought a computer, installed the
      operating system or configured a pre-installed operating system,
      and then installed one or more applications on top of the
      operating system. An e-mail server was just an e-mail application
      running on top of Linux, Unix, Microsoft Windows, or some other
      operating system, on a computer that was not designed specifically
      for that application. </p></div><div class="sect1" title="3.2. The KIWI Model"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.appliance.kiwi-model"></a>3.2. The KIWI Model<span class="permalink"><a alt="Permalink" title="3.2. The KIWI Model" href="#sec.appliance.kiwi-model">¶</a></span></h2></div></div></div><a class="indexterm" name="id2549774"></a><p> With KIWI we started to use a different model. Instead of
      installing firewall software on top of a general purpose
      computer/operating system, the designers/engineers built images
      that are designed specifically for the task. These are so called
      appliances. When building appliances with KIWI the following
      proceeding has proven to work reliably. Nevertheless the following
      is just a recommendation and can be adapted to special needs and
      environments. </p><div class="procedure"><a name="proc.appliance.general-building"></a><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Choose an appropriate image description
          template from the provided KIWI examples. Add or adapt
          repositories, package names or both, according to the distribution
          you want to build an image for.</p></li><li class="step" title="Step 2"><p>Allow the image to create an in-place git repository to
          allow tracking of non-binary changes. This is done by adding
          the following line into your <span class="command"><strong>config.sh</strong></span> script:</p><pre class="screen">baseSetupPlainTextGITRepository</pre></li><li class="step" title="Step 3"><p>Prepare the preliminary version of your new appliance by
          calling <span class="command"><strong>kiwi</strong></span>
          <code class="option">--prepare</code>&#8230; and refer to
          <a class="xref" href="#chap.usb" title="Chapter 8. USB Image&#8212;Live-Stick System">Chapter 8, <i>USB Image&#8212;Live-Stick System</i></a> for details. </p></li><li class="step" title="Step 4"><p>Decide for a testing environment. In my opinion a real
          hardware based test machine which allows to boot from USB is a
          good and fast approach. According to this make sure you have a
          usb type in your <code class="filename">config.xml</code>
        </p><pre class="screen">&lt;type filesystem="ext3 boot="usbboot/suse-..."&gt;usb&lt;/type&gt;</pre></li><li class="step" title="Step 5"><p>Create the preliminary live stick image of your new
          appliance by calling <span class="command"><strong>kiwi</strong></span>
          <code class="option">--create</code>&#8230; After successful creation of the
          image files find an USB stick which is able to store your
          appliance and plug it into a free USB port on your image build
          machine. Use the <span class="command"><strong>kiwi</strong></span>
          <code class="option">--bootstick</code>&#8230; call to deploy the image on the
          stick. Refer to <a class="xref" href="#chap.usb" title="Chapter 8. USB Image&#8212;Live-Stick System">Chapter 8, <i>USB Image&#8212;Live-Stick System</i></a> for details. </p></li><li class="step" title="Step 6"><p>Plug in the stick on your test machine and boot it.
        </p></li><li class="step" title="Step 7"><p>After your test system has successfully booted from stick
          login into your appliance and start to tweak the system
          according to your needs. This includes all actions required to
          make the appliance work as you wish. Before you start take
          care for the following: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Create an initial package list. This can be done by
              calling: </p><pre class="screen"><span class="command"><strong>rpm</strong></span> -qa | <span class="command"><strong>sort</strong></span> &gt; /tmp/deployPackages</pre></li><li class="listitem"><p>Check the output of the command <span class="command"><strong>git</strong></span> <code class="option">status</code> and include
              everything which is unknown to git and surely will not be
              changed by you and will not become part of the image
              description overlay files to the <code class="filename">/.gitignore</code> files </p></li></ul></div><p>After the initial package list exists and the git
          repository is clean you can start to configure the system. You
          never should install additional software just by installing an
          unmanaged archive or build and install from source. It&#8217;s very
          hard to find out what binary files had been installed and it&#8217;s
          also not architecture safe. If there is really no other way
          for the software to become part of the image you should
          address this issue directly in your image description and the
            <span class="command"><strong>config.sh</strong></span> script but not after the
          initial deployment has happened. </p></li><li class="step" title="Step 8"><p>As soon as your system works as expected your new
          appliance is ready to enter the final stage. At this point you
          have done several changes to the system but they are all
          tracked and should now become part of your image description.
          To include the changes into your image description the
          following process should be used: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Check the differences between the currently installed
              packages and the initial deployment list. This can be done
              by calling:</p><pre class="screen"><span class="command"><strong>rpm</strong></span> -qa | <span class="command"><strong>sort</strong></span> &gt; /tmp/appliancePackages
<span class="command"><strong>diff</strong></span> -u /tmp/deployPackages /tmp/appliancePackages</pre><p>Add those packages which are labeled with (+) to the
                <code class="sgmltag-starttag">&lt;packages
                type="image"&gt;</code> section of your config.xml file
              and remove those packages which has been removed (&#8722;)
              appropriately. If there are packages which has been
              removed against the will of the package manager make sure
              you address the uninstallation of these packages in your
                <span class="command"><strong>config.sh</strong></span> script. If you have
              installed packages from repositories which are not part of
              your <code class="filename">config.xml</code> file you should also
              add these repositories in order to allow KIWI to install
              the packages </p></li><li class="listitem"><p>Check the differences made in the configuration files.
              This can be easily done by calling: </p><pre class="screen"><span class="command"><strong>git</strong></span> diff &gt;/tmp/appliancePatch</pre><p>The created patch should become part of your image
              description and you should make sure the patch is applied
              when preparing the image. According to this the command: </p><pre class="screen"><span class="command"><strong>patch</strong></span> -p0 &lt; appliancePatch</pre><p>needs to be added as part of your
                <span class="command"><strong>config.sh</strong></span> script. </p></li><li class="listitem"><p>Check for new non binary files added. This can be done
              by calling: </p><pre class="screen"><span class="command"><strong>git</strong></span> status</pre><p>All files not under version control so far will be
              listed by the command above. Check the contents of this
              list make sure to add all files which are not created
              automatically to become part of your image description. To
              do this simply clone (copy) these files with respect to
              the filesystem structure as overlay files in your image
              description <code class="filename">root/</code><a class="indexterm" name="id2550182"></a>
              directory. </p></li></ul></div></li><li class="step" title="Step 9"><p> All your valuable work is now stored in one image
          description and can be re-used in all KIWI supported image
          types. </p></li></ol></div><p>Congratulation! To make sure the appliance works as expected
      prepare a new image tree and create an image from the new tree. If
      you like you can deactivate the creation of the git repository
      which will save you some space on the filesystem. If this
      appliance is a server I recommend to leave the repository because
      it allows you to keep track of changes during the live time of
      this appliance. </p></div></div><div class="chapter" title="Chapter 4. Maintenance of Operating System Images"><div class="titlepage"><div><div><h2 class="title"><a name="chap.maintenance"></a>Chapter 4. Maintenance of Operating System Images</h2></div></div></div><a class="indexterm" name="id2550227"></a><p>Creating an image often results in an appliance solution for a
    customer and gives you the freedom of a working solution at that
    time. But software develops and you don&#8217;t want your solution to
    become outdated. Because of this together with an image people
    always should think of <span class="emphasis"><em>image-maintenance</em></span>. The
    following paragraph just reflects ideas how to maintain images
    created by KIWI: </p><div class="figure"><a name="fig.maintain"></a><p class="title"><b>Figure 4.1. Image Maintenance Scenarios</b><span class="permalink"><a alt="Permalink" title="Figure 4.1. Image Maintenance Scenarios" href="#fig.maintain">¶</a></span></p><div class="figure-contents"><div class="mediaobjectco"><img border="0" usemap="#id2550271" src="images/maintain.png" alt="Image Maintenance Scenarios"><map name="id2550271"><area shape="rect" coords="NaN,NaN,NaN,NaN"><area shape="rect" coords="NaN,NaN,NaN,NaN"><area shape="rect" coords="NaN,NaN,NaN,NaN"><area shape="rect" coords="NaN,NaN,NaN,NaN"><area shape="rect" coords="NaN,NaN,NaN,NaN"></map><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/1.png" alt="1" border="0"></p></td><td valign="top" align="left"><p>Image Description as part of a versioning system like
              Git, Subversion, etc. to track changes</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/2.png" alt="2" border="0"></p></td><td valign="top" align="left"><p>Software package source changes</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/3.png" alt="3" border="0"></p></td><td valign="top" align="left"><p><span class="simplelist">Faster, because already prepared, cannot handle image description changes, reuires free space to store
                <code class="filename">/tmp/myOSImage</code></span>
            </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/4.png" alt="4" border="0"></p></td><td valign="top" align="left"><p>Image Description changes</p></td></tr><tr><td width="5%" valign="top" align="left"><p><img src="images/callouts/5.png" alt="5" border="0"></p></td><td valign="top" align="left"><p><span class="simplelist">Covers all possible changes, does not require storage for prepared trees, slower, because KIWI prepare runs again</span>
            </p></td></tr></table></div></div></div></div><br class="figure-break"><p>The picture in <a class="xref" href="#fig.maintain" title="Figure 4.1. Image Maintenance Scenarios">Figure 4.1</a> shows two possible
    scenarios which requires an image to become updated. The first
    reason for updating an image are changes to the software, for
    example a new kernel should be used. If this change doesn&#8217;t require
    additional software or changes in the configuration the update can
    be done by KIWI itself using its <code class="option">--upgrade</code> option.
    In combination with <code class="option">--upgrade</code> KIWI allows to add
    an additional repository which may be needed if the updated software
    is not part of the original repository. An important thing to know
    is that this additional repository is <span class="emphasis"><em>not</em></span>
    stored into the original <code class="filename">config.xml</code> file of the
    image description. </p><p>Another reason for updating an image beside software updates are
    configuration changes or enhancements, for example an image should
    have replaced its browser with another better browser or a new
    service like apache should be enabled. In principal it&#8217;s possible to
    do all those changes manually within the physical extend but
    concerning maintenance this would be a nightmare. Why, because it
    will leave the system in an unversioned condition. Nobody knows what
    has changed since the very first preparation of this image. So in
    short:</p><a class="indexterm" name="id2550463"></a><div class="blockquote"><blockquote class="blockquote"><p>Dont&#8217;t modify physical extends manually!</p></blockquote></div><p>Changes to the image configuration should be done within the
    image description. The image description itself should be part of a
    versioning system like subversion. All changes can be tracked down
    then and maybe more important can be assigned to product tags and
    branches. As a consequence an image must be prepared from scratch
    and the old physical extend could be removed. </p></div><div class="chapter" title="Chapter 5. System to Image Migration"><div class="titlepage"><div><div><h2 class="title"><a name="chap.migration"></a>Chapter 5. System to Image Migration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.migrate.create-clean-repository">5.1. Create a Clean Repository Set First</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.watch-overlay">5.2. Watch the Overlay and Unpackaged Files</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.checklist">5.3. Checklist</a></span></dt><dt><span class="sect1"><a href="#sec.migrate.turn-system-into-image">5.4. Turn my System Into an Image&#8230;</a></span></dt></dl></div><a class="indexterm" name="id2550500"></a><p>KIWI provides an experimental module which allows you to turn
    your running system into an image description. This migration allows
    you to clone your currently running system into an image. The
    process has the following limitations at the moment: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Works for SUSE systems only (with zypper on board) </p></li><li class="listitem"><p>The process works semi automatically which means depending
        on the complexity of the system some manual postprocessing might
        be necessary </p></li></ul></div><p>When calling KIWI&#8217;s migrate mode it will try to find the base
    version of your operating system and uses the currently active
    repositories specified in the zypper database to match the software
    which exists in terms of packages and patterns. The result is a list
    of packages and patterns which represents your system so far. Of
    course there are normally some data which doesn&#8217;t belong to any
    package. These are for example configurations or user data. KIWI
    collects all this information and would copy it as overlay files as
    part of the image description. The process will skip all remote
    mounted filesystems and concentrate only on local filesystems. </p><div class="sect1" title="5.1. Create a Clean Repository Set First"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.migrate.create-clean-repository"></a>5.1. Create a Clean Repository Set First<span class="permalink"><a alt="Permalink" title="5.1. Create a Clean Repository Set First" href="#sec.migrate.create-clean-repository">¶</a></span></h2></div></div></div><p> When starting with the migration it is useful to let kiwi
      know about all the repositories from which packages has been
      installed to the system. In a first step call: </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --migrate mySystem </pre><p>This will create an HTML report where you can check which
      packages and patterns could be assigned to the given base
      repository. In almost all cases there will be information about
      packages which couldn&#8217;t be assigned. You should go to that list
      and think of the repository which contains that packages (Pacman,
      etc). If something is missing add it either to the zypper list on
      your system or use the KIWI options <code class="option">--add-repo</code> &#8230;
        <code class="option">--add-repotype</code>. </p><p>Continue calling the following command until your list is
      clean You should continue the migration if you have a clean list
      of solved packages without any package skipped except you know
      that this package can&#8217;t be provided or is not worth to become part
      of the migration. </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --migrate mySystem --nofiles [--skip package ... ]</pre></div><div class="sect1" title="5.2. Watch the Overlay and Unpackaged Files"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.migrate.watch-overlay"></a>5.2. Watch the Overlay and Unpackaged Files<span class="permalink"><a alt="Permalink" title="5.2. Watch the Overlay and Unpackaged Files" href="#sec.migrate.watch-overlay">¶</a></span></h2></div></div></div><a class="indexterm" name="id2550650"></a><a class="indexterm" name="id2550662"></a><p>Files which has been modified but belong to a package will be
      automatically copied into the overlay directory below
        <code class="filename">/tmp/mySystem/root</code>. You should check that
      no modified file is a binary because such a binary would be
      replaced by a new install of the package anyway. As a software
      deloper people tend to compile software from source and
      copy/install them into their system. Doing this could cause binary
      files previosly installed by a package to be reported as modified.
      You should remove such files from your overlay tree. </p><p>The migration also copy the entire <code class="filename">/etc</code>
      directory into the overlay root directory because it stores all
      important configuration files. Beside the important files there
      are most probably a bunch of file which doesn&#8217;t belong to any
      package exists only for historical reasons. kiwi creates a list of
      files and directories to support you best in sorting out what is
      required and what can be ignored. Nevertheless this is the most
      time consuming part of your migration review. Simply click on the
        <span class="emphasis"><em>all unpackaged files</em></span> link to take a look at
      the complete list. Those files you want to have in your image
      needs to be copied over to the
        <code class="filename">/tmp/mySystem/root</code> directory </p></div><div class="sect1" title="5.3. Checklist"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.migrate.checklist"></a>5.3. Checklist<span class="permalink"><a alt="Permalink" title="5.3. Checklist" href="#sec.migrate.checklist">¶</a></span></h2></div></div></div><a class="indexterm" name="id2550733"></a><a class="indexterm" name="id2550745"></a><p> After that you should walk through the following check list </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Change author and contact in <code class="filename">config.xml</code>
        </p></li><li class="listitem"><p>Set appropriate name for your image in
            <code class="filename">config.xml</code>. </p></li><li class="listitem"><p>Add/modify default type (oem) set in <code class="filename">config.xml</code> if needed
        </p></li><li class="listitem"><p>Make sure your X11 configuration is appropriate according
          to the new target. A failsafe version was created in
            <code class="filename">/tmp/mysys/root/etc/X11/xorg.conf.install</code>
          -&gt; fbdev based </p></li><li class="listitem"><p>Make sure <span class="command"><strong>yast2</strong></span> is installed to be able
          to reconfigure the system. If <span class="command"><strong>yast2</strong></span> is not
          installed these tasks needs to be done else. Otherwise yast&#8217;s
          second stage is started on first boot of the migrated image
        </p></li><li class="listitem"><p>If you want to access any remote filesystem it&#8217;s a good
          idea to let AutoYaST add them on first boot of the system
        </p></li><li class="listitem"><p>Check your network setup in
            <code class="filename">/etc/sysconfig/network</code>. Is this setup
          still possible in the cloned environment? Make sure you check
          for the MAC address of the card first. </p></li></ul></div></div><div class="sect1" title="5.4. Turn my System Into an Image&#8230;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.migrate.turn-system-into-image"></a>5.4. Turn my System Into an Image&#8230;<span class="permalink"><a alt="Permalink" title="5.4. Turn my System Into an Image&#8230;" href="#sec.migrate.turn-system-into-image">¶</a></span></h2></div></div></div><p>After the process has finished you should check the size of
      the image description. The description itself shouldn&#8217;t be that
      big. The size of a migrated image description mainly depends on
      how many overlay files exists in the <code class="filename">root/</code><a class="indexterm" name="id2550890"></a> directory. You should make sure to maintain
      only required overlay files. Now let&#8217;s try to create a clone image
      from the description. By default an OEM image which is a virtual
      disk which is able to run on real hardware too is created. On
      success you will also find a ISO file which is an installable
      version of the OEM image. If you burn the ISO on a DVD you can use
      that DVD to install your cloned image on another computer. </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> -p /tmp/migrated --root /tmp/mySys
<span class="command"><strong>kiwi</strong></span> --create /tmp/mySys -d /tmp/myResult </pre><p>If everything worked well you can test the created OEM image
      in any full virtual operating system environment like Qemu or
        <span class="trademark">VMware</span>&#8482;. Once created the image
      description can serve for all image types KIWI supports. </p></div></div><div class="chapter" title="Chapter 6. Installation Source"><div class="titlepage"><div><div><h2 class="title"><a name="chap.instsourcesetup"></a>Chapter 6. Installation Source</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.instsourcesetup.adapt-example">6.1. Adapt the Example&#8217;s config.xml</a></span></dt><dt><span class="sect1"><a href="#sec.instsourcesetup.create-local-inst-source">6.2. Create a Local Installation Source</a></span></dt></dl></div><a class="indexterm" name="id2550951"></a><p>Before you start to use any of the examples provided in the
    following chapters your build system has to have a valid
    installation source for the distribution you are about to create an
    image for. By default, all examples will connect to the network to
    find the installation source. It depends on your network bandwidth
    how fast an image creation process is and in almost all cases it is
    better to prepare a local installation source first. </p><div class="sect1" title="6.1. Adapt the Example&#8217;s config.xml"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.instsourcesetup.adapt-example"></a>6.1. Adapt the Example&#8217;s config.xml<span class="permalink"><a alt="Permalink" title="6.1. Adapt the Example&#8217;s config.xml" href="#sec.instsourcesetup.adapt-example">¶</a></span></h2></div></div></div><p> If you can make sure you have a local installation source
      it&#8217;s important to change the path attribute inside of the
      repository element of the appropriate example to point to your
      local source directory. A typically default repository element
      looks like the following: </p><pre class="screen">&lt;repository type="yast2"&gt;
   <code class="sgmltag-sgmlcomment">&lt;!--&lt;source path="/image/CDs/full-11.0-i386"/&gt;--&gt;</code>
   &lt;source path="opensuse://openSUSE:11.0/standard/"/&gt; 
&lt;/repository&gt;</pre></div><div class="sect1" title="6.2. Create a Local Installation Source"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.instsourcesetup.create-local-inst-source"></a>6.2. Create a Local Installation Source<span class="permalink"><a alt="Permalink" title="6.2. Create a Local Installation Source" href="#sec.instsourcesetup.create-local-inst-source">¶</a></span></h2></div></div></div><a class="indexterm" name="id2551023"></a><p> The following procedure describes how to create a local SUSE
      installation source which is stored below the path <code class="filename">/images/CDs</code><a class="indexterm" name="id2551044"></a>. If you are using the
      local path as described in this document you only need to flip
      the given path information inside of the example
        <code class="filename">config.xml</code> file. </p><div class="procedure"><a name="proc.instsourcesetup.local-inst"></a><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Find your SUSE standard installation CDs or the DVD and
          make them available to the build system. Most Linux systems
          auto-mount a previosly inserted media automatically. If this
          is the case you simply can change the directory to the auto
          mounted path below <code class="filename">/media</code><a class="indexterm" name="id2551085"></a>. If your system doesn&#8217;t mount the device
          automatically you can do this with the following command: </p><pre class="screen"><span class="command"><strong>mount</strong></span> -o loop /dev/<em class="replaceable"><code>drive-device-name</code></em> /mnt</pre></li><li class="step" title="Step 2"><p>If you do not have a DVD but a CD set, copy the contents
          of <span class="emphasis"><em>all</em></span> CDs into one directory. It&#8217;s
          absolutly important that you first start with the
            <span class="emphasis"><em>last</em></span> CD and copy the first CD at last.
          In case of CDs you should have a bundly of 4 CDs. Copy them in
          the order 4 3 2 1. </p></li><li class="step" title="Step 3"><p>Copy the contents of the CDs/DVD to your hard drive once
          you have access to the media. You need at least 4GB free space
          available. The following is intended to create a SUSE 11.0
          installation source: </p><pre class="screen"><span class="command"><strong>mkdir</strong></span> -p /image/CDs/full-11.0-i386/ 
<span class="command"><strong>cp</strong></span> -a /mnt/* /image/CDs/full-11.0-i386/ </pre><p>Remember if you have a CD set start with number 4 first
          and after that unplugg the CD and insert the next one to
          repeat the copy command until all CDs are copied into to
          /image </p></li></ol></div></div></div><div class="chapter" title="Chapter 7. ISO Image&#8212;Live Systems"><div class="titlepage"><div><div><h2 class="title"><a name="chap.iso"></a>Chapter 7. ISO Image&#8212;Live Systems</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.iso.building">7.1. Building the suse-live-iso Example</a></span></dt><dt><span class="sect1"><a href="#sec.iso.using">7.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.iso.flavours">7.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.iso.split-mode">7.3.1. Split mode</a></span></dt></dl></dd></dl></div><a class="indexterm" name="id2551180"></a><a class="indexterm" name="id2551191"></a><a class="indexterm" name="id2551203"></a><p>A live system image is an operating System on CD or DVD. In
    principal one can treat the CD/DVD as the hard disk of the system
    with the restriction that you can&#8217;t write data on it. So as soon as
    the media is plugged into the computer, the machine is able to boot
    from that media. After some time one can login to the system and
    work with it like on any other system. All write actions takes place
    in RAM space and therefore all changes will be lost as soon as the
    computer shuts down. </p><div class="sect1" title="7.1. Building the suse-live-iso Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.iso.building"></a>7.1. Building the suse-live-iso Example<span class="permalink"><a alt="Permalink" title="7.1. Building the suse-live-iso Example" href="#sec.iso.building">¶</a></span></h2></div></div></div><p>The latest example provided with KIWI is based on openSUSE
      11.2 and includes the base and KDE patterns. </p><pre class="screen"><span class="command"><strong>cd</strong></span> /usr/share/doc/packages/kiwi/examples cd suse-11.2
<span class="command"><strong>kiwi</strong></span> --prepare ./suse-live-iso --root /tmp/myiso </pre><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create /tmp/myiso --type iso -d /tmp/myiso-result</pre></div><div class="sect1" title="7.2. Using the Image"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.iso.using"></a>7.2. Using the Image<span class="permalink"><a alt="Permalink" title="7.2. Using the Image" href="#sec.iso.using">¶</a></span></h2></div></div></div><p>There are two ways to use the generated ISO image: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Burn the <code class="filename">.iso</code><a class="indexterm" name="id2551295"></a> file
          on a CD or DVD with your preferred burn program. Plug in the
          CD or DVD into a test computer and (re)boot the machine. Make
          sure the computer boot from the CD drive as first boot device.
        </p></li><li class="listitem"><p>Use a virtualisation system to test the image directly.
          Testing an iso can be done with any full virtual system for
          example: </p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/myiso-result
<span class="command"><strong>qemu</strong></span> -cdrom ./suse-11.2-live-iso.i686-2.5.1.iso -m 256</pre></li></ul></div></div><div class="sect1" title="7.3. Flavours"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.iso.flavours"></a>7.3. Flavours<span class="permalink"><a alt="Permalink" title="7.3. Flavours" href="#sec.iso.flavours">¶</a></span></h2></div></div></div><p>KIWI supports different filesystems and boot methods along
      with the ISO image type. The provided example by default uses a
        <code class="systemitem">squashfs</code><a class="indexterm" name="id2551354"></a> compressed
      root filesystem. By design of this filesystem it is not possible
      to write data on it. To be able to write on the filesystem another
      filesystem called aufs is used. <code class="systemitem">aufs</code><a class="indexterm" name="id2551372"></a> is an overlay filesystem which allows to
      combine two different filesystems into one. In case of a live
      system <code class="systemitem">aufs</code><a class="indexterm" name="id2551389"></a> is used to
      combine the squashfs compressed read only root tree with a tmpfs
      RAM filesystem. The result is a full writable root tree whereas
      all written data lives in RAM and is therefore not persistent.
        <code class="systemitem">squashfs</code><a class="indexterm" name="id2551408"></a> and/or
        <code class="systemitem">aufs</code><a class="indexterm" name="id2551422"></a> does not exist
      on all versions of SUSE and therefore the flags attribute in
        <code class="filename">config.xml</code> exists to be able to have the
      following alternative solutions: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">flags</code><a class="indexterm" name="id2551449"></a>="<code class="sgmltag-attvalue">unified</code>"</span></dt><dd><p>Compressed and unified root tree as explained above.
          </p></dd><dt><span class="term"><code class="sgmltag-attribute">flags</code><a class="indexterm" name="id2551480"></a>="<code class="sgmltag-attvalue">compressed</code>"</span></dt><dd><p> Does filesystem compression with squashfs, but don&#8217;t
            use an overlay filesystem for write support. A symbolic link
            list is used instead and thus a split element is required in
              <code class="filename">config.xml</code>. See the split mode
            section below for details. </p></dd><dt><span class="term"><code class="sgmltag-attribute">flags</code><a class="indexterm" name="id2551523"></a>="<code class="sgmltag-attvalue">clic</code>"</span></dt><dd><p> Creates a FUSE based <code class="systemitem">clicfs</code><a class="indexterm" name="id2551548"></a> image and allows write operations
            into a cow file. In case of an ISO the write happens into a
            ramdisk. </p></dd><dt><span class="term">Flags Not Set</span></dt><dd><p>If no <code class="sgmltag-attribute">flags</code><a class="indexterm" name="id2551576"></a>
            attribute is set no compressed filesystem, no overlay
            filesystem will be used. The root tree will be directly part
            of the ISO filesystem and the paths:
              <code class="filename">/bin</code>, <code class="filename">/boot</code>,
              <code class="filename">/lib</code>, <code class="filename">/lib64</code>,
              <code class="filename">/opt</code>, <code class="filename">/sbin</code>, and
              <code class="filename">/usr</code> will be read-only. </p></dd></dl></div><div class="sect2" title="7.3.1. Split mode"><div class="titlepage"><div><div><h3 class="title"><a name="sec.iso.split-mode"></a>7.3.1. Split mode<span class="permalink"><a alt="Permalink" title="7.3.1. Split mode" href="#sec.iso.split-mode">¶</a></span></h3></div></div></div><a class="indexterm" name="id2551636"></a><a class="indexterm" name="id2551647"></a><p>If no overlay filesystem is in use but the image filesystem
        is based on a compressed filesystem KIWI allows to setup which
        files and directories should be writable in a so called split
        section. In order to allow to login into the system, at least
        the <code class="filename">/var</code><a class="indexterm" name="id2551672"></a> directory should
        be writable. This is because the PAM authentification requires
        to be able to report any login attempt to
          <code class="filename">/var/log/messages</code> which therefore needs
        to be writable. The following split section can be used if the
        flag compressed is used: </p><pre class="screen">&lt;split&gt; 
  &lt;temporary&gt; 
   &lt;file name="/var"/&gt;
   &lt;file name="/var/*"/&gt; 
   &lt;file name="/boot"/&gt; 
   &lt;file name="/boot/*"/&gt; 
   &lt;file name="/etc"/&gt; 
   &lt;file name="/etc/*"/&gt; 
   &lt;file name="/home"/&gt; 
   &lt;file name="/home/*"/&gt; 
  &lt;/temporary&gt; 
&lt;/split&gt;</pre></div></div></div><div class="chapter" title="Chapter 8. USB Image&#8212;Live-Stick System"><div class="titlepage"><div><div><h2 class="title"><a name="chap.usb"></a>Chapter 8. USB Image&#8212;Live-Stick System</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.usb.building">8.1. Building the suse-live-stick Example</a></span></dt><dt><span class="sect1"><a href="#sec.usb.using">8.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.usb.flavours">8.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.usb.split-stick">8.3.1. Split Stick</a></span></dt><dt><span class="sect2"><a href="#sec.usb.lvm">8.3.2. LVM Support</a></span></dt></dl></dd></dl></div><a class="indexterm" name="id2551716"></a><a class="indexterm" name="id2551728"></a><a class="indexterm" name="id2551740"></a><p>A live USB stick image is a system on USB stick which allows you
    to boot and run from this device without using any other storage
    device of the computer. It is urgently required that the BIOS of the
    system which you plug the stick in supports booting from USB stick.
    Almost all new BIOS systems support that. The USB stick serves as OS
    system disk in this case and you can read and write data onto it. </p><div class="sect1" title="8.1. Building the suse-live-stick Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.usb.building"></a>8.1. Building the suse-live-stick Example<span class="permalink"><a alt="Permalink" title="8.1. Building the suse-live-stick Example" href="#sec.usb.building">¶</a></span></h2></div></div></div><p>The next example provided with KIWI is based on openSUSE 11.2
      and uses the default plus x11 pattern. The operating system is
      stored on a standard ext3 filesystem: </p><pre class="screen"><span class="command"><strong>cd</strong></span> /usr/share/doc/packages/kiwi/examples
<span class="command"><strong>cd</strong></span> suse-11.2
<span class="command"><strong>kiwi</strong></span> --prepare ./suse-live-stick --root /tmp/mystick </pre><p>There are two possible image types which allows you to drive
      the stick. Both are added into the <code class="filename">config.xml</code>
      of this example image description. If you already have access to
      the stick, use the first approach. In this case it is preferred
      over the second one. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The first image type named usb creates all required images
          for booting the OS but requires you to plug in the stick and
          let KIWI deploy the data onto this stick. </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create /tmp/mystick --type usb d /tmp/mystick-result </pre></li><li class="listitem"><p>The second image type named oem allows you to create a
          virtual disk which represents a virtual disk geometry
          including all partitions and boot information in one file. You
          simply can <span class="command"><strong>dd</strong></span> this file on the stick. </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create /tmp/mystick --type oem -d /tmp/mystick-result </pre></li></ul></div></div><div class="sect1" title="8.2. Using the Image"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.usb.using"></a>8.2. Using the Image<span class="permalink"><a alt="Permalink" title="8.2. Using the Image" href="#sec.usb.using">¶</a></span></h2></div></div></div><p>To use the created images deployed them on the USB stick. For
      the first image type (usb) you need KIWI itself to be able to
      deploy the image on the stick. The reason for this is that the usb
      image type has created the boot and the system image but there is
      no disk geometry or partition table available. KIWI creates a new
      partition table on the stick and imports the created images as
      follows: </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --bootstick \
    /tmp/mystick-result/ \
    initrd-usbboot-suse-11.2.i686-2.1.1.splash.gz \
    --bootstick-system \
    /tmp/mystick-result/ \
    suse-11.2-live-stick.i686-1.1.2</pre><p>In case of the second image type (oem) dump the raw data onto
      a device. On Linux the most popular tool to do this is the
        <span class="command"><strong>dd</strong></span> command. The OEM image is represented by
      the file with the <code class="filename">.raw</code><a class="indexterm" name="id2551905"></a>
      extension. As said, this is a virtual disk which already includes
      partition information. However, this partition information does
      not match the real USB stick geometry. This means, the KIWI boot
      image (oemboot) has to adapt the disk geometry on first boot. To
      deploy the image on the stick, run: </p><pre class="screen"><span class="command"><strong>dd</strong></span> if=/tmp/mystick-result/ \
      suse-11.2-live-stick.i686-1.1.2.raw 
      of=/dev/<em class="replaceable"><code>stick-device</code></em> bs=32k</pre><p>Testing of the live stick can be done with a test machine
      (booting from USB) or with a virtualization system. If you test
      with a virtualization system, for example qemu, be aware that the
      USB stick looks like a normal disk to the system. The KIWI boot
      process searches for the USB stick to be able to mount the correct
      storage device. However, in a virtual environment the disk doesn&#8217;t
      appear as a USB stick. If your virtualisation solution doesn&#8217;t
      provide a virtual BIOS which allows booting from USB stick, test
      the stick on real hardware. </p></div><div class="sect1" title="8.3. Flavours"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.usb.flavours"></a>8.3. Flavours<span class="permalink"><a alt="Permalink" title="8.3. Flavours" href="#sec.usb.flavours">¶</a></span></h2></div></div></div><p>USB sticks weren&#8217;t designed to serve as storage devices for
      operating systems. By design of these nice little gadgets their
      storage capacity is limited to only a few gigabytes. Therefore,
      KIWI supports compressed filesystems on USB sticks too: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-attribute">filesystem</code><a class="indexterm" name="id2551987"></a>="<code class="sgmltag-attvalue">squashfs</code>"</span></dt><dd><p>Compresses the image using the <code class="systemitem">squashfs</code><a class="indexterm" name="id2552013"></a> filesystem. The
            boot process will automatically use aufs as overlay
            filesystem to mount the complete tree read-write. For the
            write part an additional ext2 partition will be created on
            the stick. The support for this compression layer requires
              <code class="systemitem">squashfs</code><a class="indexterm" name="id2552038"></a> and
              <code class="systemitem">aufs</code><a class="indexterm" name="id2552053"></a> to be
            present in the distribution KIWI has used to build the image
          </p></dd><dt><span class="term"><code class="sgmltag-attribute">filesystem</code><a class="indexterm" name="id2552073"></a>="<code class="sgmltag-attvalue">clicfs</code>"</span></dt><dd><p>Creates a fuse based clicfs image and allows write
            operations into a cow file. </p></dd></dl></div><div class="sect2" title="8.3.1. Split Stick"><div class="titlepage"><div><div><h3 class="title"><a name="sec.usb.split-stick"></a>8.3.1. Split Stick<span class="permalink"><a alt="Permalink" title="8.3.1. Split Stick" href="#sec.usb.split-stick">¶</a></span></h3></div></div></div><a class="indexterm" name="id2552105"></a><p> If there is no overlay filesystem available, it is also
        possible to define a split section in
          <code class="filename">config.xml</code>. Use the split support to
        split the image into a compressed read-only and a read-write
        portion. To create a split stick the types needs to be adapted
        as follows: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Type setup for split usb type:</p><pre class="screen">&lt;type image="split" fsreadwrite="ext3"
   fsreadonly="squashfs" boot="usbboot/suse-11.2"/&gt;</pre></li><li class="listitem"><p>Type setup for split oem type: </p><pre class="screen">&lt;type image="split" fsreadwrite="ext3"
   fsreadonly="squashfs" boot="oemboot/suse-11.2"/&gt;</pre></li></ul></div><p>For both types, a split section inside the type section is
        required which defines the read-write data. A good starting
        point is to set <code class="filename">/var</code><a class="indexterm" name="id2552175"></a>, 
        <code class="filename">/home</code><a class="indexterm" name="id2552190"></a>, and 
        <code class="filename">/etc</code><a class="indexterm" name="id2552204"></a> as writable data. </p><pre class="screen">&lt;split&gt;
  &lt;persistent&gt; 
    <code class="sgmltag-sgmlcomment">&lt;!-- allow read/write access to: --&gt;</code>
    &lt;file name="/var"/&gt; 
    &lt;file name="/var/*"/&gt; 
    &lt;file name="/etc"/&gt; 
    &lt;file name="/etc/*"/&gt; 
    &lt;file name="/home"/&gt;
    &lt;file name="/home/*"/&gt;
    &lt;/persistent&gt; 
&lt;/split&gt;</pre><p>If no split section is added the default split section from
          <code class="filename">/usr/share/kiwi/modules/</code><a class="indexterm" name="id2552241"></a>, the file
          <code class="filename">KIWISplit.txt</code> is used. </p></div><div class="sect2" title="8.3.2. LVM Support"><div class="titlepage"><div><div><h3 class="title"><a name="sec.usb.lvm"></a>8.3.2. LVM Support<span class="permalink"><a alt="Permalink" title="8.3.2. LVM Support" href="#sec.usb.lvm">¶</a></span></h3></div></div></div><a class="indexterm" name="id2552264"></a><a class="indexterm" name="id2552276"></a><a class="indexterm" name="id2552284"></a><p>KIWI supports LVM, the Logical Volume Manager. In this mode,
        the disk partition table includes one lvm partition and one
        standard ext2 boot partition. KIWI creates the kiwiVG volume
        group and adds logical volumes as they are needed and configured
        according to the image type and filesystem. After booting, the
        user has full control over the volume group and is free to
        change, resize, or increase the group and the volumes inside.
        Support for LVM has been added for all image types which are
        disk based. This includes vmx, oem and usb. In order to use LVM
        for the usb type just add the <code class="option">--lvm</code> option as
        part of <span class="command"><strong>kiwi</strong></span>
        <code class="option">--bootstick</code> deployment or add the attribute
        <code class="sgmltag-attribute">lvm</code><a class="indexterm" name="id2552325"></a>="<code class="sgmltag-attvalue">true</code>" 
        as part of the <code class="sgmltag-element">type</code> section in
        your <code class="filename">config.xml</code> file. </p><p>The optional <code class="sgmltag-element">lvmvolumes</code> section can be used to set one or
        more top level directories into a separate volume. See 
        <a class="xref" href="#chap.description" title="Chapter 2. KIWI Image Description">Chapter 2, <i>KIWI Image Description</i></a> for a
        detailed explanation. </p></div></div></div><div class="chapter" title="Chapter 9. VMX Image&#8212;Virtual Disks"><div class="titlepage"><div><div><h2 class="title"><a name="chap.vmx"></a>Chapter 9. VMX Image&#8212;Virtual Disks</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.vmx.building">9.1. Building the suse-vm-guest Example</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.using">9.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.vmx.flavours">9.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.vmx.vmware-support">9.3.1. VMware support</a></span></dt><dt><span class="sect2"><a href="#sec.vmx.lvm">9.3.2. LVM Support</a></span></dt></dl></dd></dl></div><a class="indexterm" name="id2552373"></a><a class="indexterm" name="id2552385"></a><a class="indexterm" name="id2552396"></a><p>A VMX image is a virtual disk image for use in full
    virtualisation systems like Qemu or VMware. The image is a file
    containing the system represented by the configured packages in
    config.xml as well as partition data and bootloader information. The
    size of this virtual disk can be specified by using the size element
    in the <code class="filename">config.xml</code> file or by adding the
      <code class="option">--bootvm-disksize</code> command line argument. </p><div class="sect1" title="9.1. Building the suse-vm-guest Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vmx.building"></a>9.1. Building the suse-vm-guest Example<span class="permalink"><a alt="Permalink" title="9.1. Building the suse-vm-guest Example" href="#sec.vmx.building">¶</a></span></h2></div></div></div><p> The vm-guest example provided with KIWI is based on recent
      openSUSE releases, one example configuration per release. The
      example uses base pattern and the virtual disk is formated using
      the distribution default filesystem. </p><pre class="screen"><span class="command"><strong>cd</strong></span> /usr/share/doc/packages/kiwi/examples 
<span class="command"><strong>cd</strong></span> suse-11.2
<span class="command"><strong>kiwi</strong></span> --prepare ./suse-vm-guest --root /tmp/myvm </pre><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create /tmp/myvm --type vmx -d /tmp/myvm-result</pre></div><div class="sect1" title="9.2. Using the Image"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vmx.using"></a>9.2. Using the Image<span class="permalink"><a alt="Permalink" title="9.2. Using the Image" href="#sec.vmx.using">¶</a></span></h2></div></div></div><p>The generated virtual disk image serves as the hard disk of
      the selected virtualization system (QEMU, VMware, etc.). The
      virtual hard disk format differs across virtualization
      environments. Some virtualization environments support multiple
      virtual disk formats. Using the QEMU virtualization environment
      test the created image with the following command: </p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/myvm-result 
<span class="command"><strong>qemu</strong></span> suse-11.2-vm-guest.i686-1.1.2.raw -m 256 </pre></div><div class="sect1" title="9.3. Flavours"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.vmx.flavours"></a>9.3. Flavours<span class="permalink"><a alt="Permalink" title="9.3. Flavours" href="#sec.vmx.flavours">¶</a></span></h2></div></div></div><p>KIWI always generates a file in the <code class="filename">.raw</code><a class="indexterm" name="id2552521"></a> format. The .raw file is a
      disk image with a structure equivalent to the structure of a
      physical hard disk. Individual virtualization systems have
      specific formats to facilitate improved I/O performance to the
      virtual disk, represented by the image file, or additional
      specified virtual hard disk files. KIWI will generate a specific
      format when the format attribute of the type element is added. </p><pre class="screen">&lt;type image="vmx"... format="name"/&gt;</pre><p>The following table lists the supported virtual disk
      formats:</p><div class="table"><a name="tab.vmx.supported-disk-formats"></a><p class="title"><b>Table 9.1. Supported Virtual Disk Formats</b><span class="permalink"><a alt="Permalink" title="Table 9.1. Supported Virtual Disk Formats" href="#tab.vmx.supported-disk-formats">¶</a></span></p><div class="table-contents"><a class="indexterm" name="id2552565"></a><a class="indexterm" name="id2552577"></a><table summary="Supported Virtual Disk Formats" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>vmdk</td><td>Disk format for VMware</td></tr><tr><td>ovf</td><td>Open Virtual Format requires VMwares ovftool</td></tr><tr><td>qcow2</td><td>QEMU virtual disk format</td></tr></tbody></table></div></div><br class="table-break"><div class="sect2" title="9.3.1. VMware support"><div class="titlepage"><div><div><h3 class="title"><a name="sec.vmx.vmware-support"></a>9.3.1. VMware support<span class="permalink"><a alt="Permalink" title="9.3.1. VMware support" href="#sec.vmx.vmware-support">¶</a></span></h3></div></div></div><a class="indexterm" name="id2552653"></a><a class="indexterm" name="id2552664"></a><p>A VMware image is accompanied by a guest configuration file.
        This file includes information about the hardware to be
        represented to the guest image by the VMware virtualization
        environment as well as specification of resources such as
        memory. </p><p>Within the <code class="filename">config.xml</code> file it is
        possible to specify the VMware configuration settings. In
        addition it is possible to include selected packages in the
        created image that are specific to the VM image generation. The
        following <code class="filename">config.xml</code> snippet provides
        general guidance on the elements in
          <code class="filename">config.xml</code>. </p><pre class="screen">&lt;packages type="vmx"&gt; 
   <code class="sgmltag-sgmlcomment">&lt;!-- packages you need in VMware only --&gt;</code>
&lt;/packages&gt; 
&lt;type......&gt;
  &lt;machine memory="512"&gt; 
    &lt;vmdisk controller="ide" id="0"/&gt; 
  &lt;/machine&gt; 
&lt;/type&gt;</pre><p>Given the specification above KIWI will create a VMware
        guest configuration specifying the availability of 512 MB
        of RAM and an IDE disk controller interface for the VM guest.
        For aditional information about the configuration settings
        please refer to the <span class="emphasis"><em>machine</em></span> section. </p><p>The guest configuration can be loaded through VMware user
        interface and may be modified through the GUI. The configuration
        file has the <code class="filename">.vmx</code><a class="indexterm" name="id2552747"></a>
        extension as shown in the example below. </p><pre class="screen">/tmp/myvm-result/suse-11.2-vm-guest.i686-1.1.2.vmx</pre><p>Using the <code class="sgmltag-attribute">format</code><a class="indexterm" name="id2552770"></a>="<code class="sgmltag-attvalue">vmdk</code>"
        attribute of the <code class="sgmltag-starttag">&lt;type&gt;</code> start
        tag will create the VMware formated disk image (<code class="filename">.vmdk</code><a class="indexterm" name="id2552796"></a> file) and the required
        VMware guest configuration (<code class="filename">.vmx</code><a class="indexterm" name="id2552812"></a>) file. </p><p>In addition it is possible to create an image for the Xen
        virtualization framework. By adding the <code class="sgmltag-attribute">bootprofile</code><a class="indexterm" name="id2552829"></a> and <code class="sgmltag-attribute">bootkernel</code><a class="indexterm" name="id2552842"></a> attributes to the
          <code class="sgmltag-starttag">&lt;type&gt;</code> start tag with values
        of <code class="sgmltag-attvalue">xen</code> and <code class="sgmltag-attvalue">xenboot</code>, respectively. Please refer
        to the <a class="xref" href="#chap.xen" title="Chapter 12. Xen Image&#8212;Paravirtual Systems">Chapter 12, <i>Xen Image&#8212;Paravirtual Systems</i></a> for additional details.</p></div><div class="sect2" title="9.3.2. LVM Support"><div class="titlepage"><div><div><h3 class="title"><a name="sec.vmx.lvm"></a>9.3.2. LVM Support<span class="permalink"><a alt="Permalink" title="9.3.2. LVM Support" href="#sec.vmx.lvm">¶</a></span></h3></div></div></div><a class="indexterm" name="id2552882"></a><p>KIWI also provides support for LVM (Logical Volume
        Management). In this mode the disk partition table will include
        one lvm partition and one standard <code class="systemitem">ext2</code><a class="indexterm" name="id2552905"></a> boot partition. KIWI
        creates the kiwiVG volume group and adds logical volumes as they
        are needed and configured according to the image type and
        filesystem. After boot of the system the user has full control
        over the volume group and is free to change/resize/increase the
        group and the volumes inside. Support for LVM has been added for
        all image types which are disk based. This includes vmx, oem and
        usb. In order to use LVM for the vmx type just add the
          <code class="option">--lvm</code> option as part of the KIWI create step
        or add the attribute lvm="true" as part of the type section in
        your <code class="filename">config.xml</code> file. </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create /tmp/myvm --type vmx -d /tmp/myvm-result --lvm </pre><p>With the optional lvmvolumes section you can set one or more
        top level directories into a separate volume. See <a class="xref" href="#chap.description" title="Chapter 2. KIWI Image Description">Chapter 2, <i>KIWI Image Description</i></a> for a detailed explanation.
      </p></div></div></div><div class="chapter" title="Chapter 10. PXE Image&#8212;Thin Clients"><div class="titlepage"><div><div><h2 class="title"><a name="chap.pxe"></a>Chapter 10. PXE Image&#8212;Thin Clients</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.pxe.setting-up">10.1. Setting Up the Required Services</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.atftp-server">10.1.1. Atftp Server</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.dhcp-server">10.1.2. DHCP Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.building">10.2. Building the suse-pxe-client Example</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.using">10.3. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.pxe.flavours">10.4. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.pxe.client-control-file">10.4.1. The PXE Client Control File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.client-config-file">10.4.2. The PXE Client Configuration File</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.another-user">10.4.3. User another than tftp as Download Protocol</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.ram-only-image">10.4.4. RAM Only Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.union-image">10.4.5. Union Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.split-image">10.4.6. Split Image</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-nfs">10.4.7. Root Tree Over NFS</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-nbd">10.4.8. Root Tree Over NBD</a></span></dt><dt><span class="sect2"><a href="#sec.pxe.root-tree-over-aoe">10.4.9. Root Tree Over AoE</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec.pxe.groups">10.5. Hardware Grouping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2555227">10.5.1. The Group Configuration File</a></span></dt><dt><span class="sect2"><a href="#id2555412">10.5.2. The Hardware Group File</a></span></dt></dl></dd></dl></div><a class="indexterm" name="id2552967"></a><a class="indexterm" name="id2552979"></a><a class="indexterm" name="id2552990"></a><p>A PXE image consists of a boot image and a system image like all
    other image types too. But with a PXE image the image files are
    available seperately and needs to be copied at specific locations of
    a network boot server. PXE is a boot protocol implemented in most
    BIOS implementations which makes it so interesting. The protocol
    sends DHCP requests to assign an IP address and after that it uses
    tftp to download kernel and boot instructions. </p><div class="sect1" title="10.1. Setting Up the Required Services"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.setting-up"></a>10.1. Setting Up the Required Services<span class="permalink"><a alt="Permalink" title="10.1. Setting Up the Required Services" href="#sec.pxe.setting-up">¶</a></span></h2></div></div></div><p>Before you start to build pxe images with KIWI, setup the boot
      server. The boot server requires the services atftp and DHCP to
      run. </p><div class="sect2" title="10.1.1. Atftp Server"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.atftp-server"></a>10.1.1. Atftp Server<span class="permalink"><a alt="Permalink" title="10.1.1. Atftp Server" href="#sec.pxe.atftp-server">¶</a></span></h3></div></div></div><p>In order to setup the <code class="systemitem">atftp</code><a class="indexterm" name="id2553039"></a> server the following steps are required </p><div class="procedure"><a name="proc.pxe.atftp-server-setup"></a><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Install the packages <span class="package">atftp</span> and
              <span class="package">kiwi-pxeboot</span>. </p></li><li class="step" title="Step 2"><p>Edit the file
            <code class="filename">/etc/sysconfig/atftpd</code>. Set or modify
            the following variables: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="screen">ATFTPD_OPTIONS="--daemon --no-multicast"</pre></li><li class="listitem"><pre class="screen">ATFTPD_DIRECTORY="/srv/tftpboot"</pre></li></ul></div></li><li class="step" title="Step 3"><p>Run <code class="systemitem">atftpd</code><a class="indexterm" name="id2553117"></a> by
            calling the command:</p><pre class="screen"><span class="command"><strong>rcatftpd</strong></span> start</pre></li></ol></div></div><div class="sect2" title="10.1.2. DHCP Server"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.dhcp-server"></a>10.1.2. DHCP Server<span class="permalink"><a alt="Permalink" title="10.1.2. DHCP Server" href="#sec.pxe.dhcp-server">¶</a></span></h3></div></div></div><p> In contrast to the atftp server setup the following DHCP
        server setup can only serve as an example. Depending on your
        network structure, the IP addresses, ranges and domain settings
        needs to be adapted in order to allow the DHCP server to work
        within your network. If you already have a DHCP server running
        in your network, make sure that the filename and next-server
        information is provided by your server. The following steps
        describe how to setup a new DHCP server instance: </p><div class="procedure"><a name="proc.pxe.dhcp-server-setup"></a><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Install the package <span class="package">dhcp-server</span>.
          </p></li><li class="step" title="Step 2"><p>Create the file <code class="filename">/etc/dhcpd.conf</code> and include the
            following statements: </p><pre class="screen">option domain-name "example.org";
option domain-name-servers 192.168.100.2;
option broadcast-address 192.168.100.255;
option routers 192.168.100.2;
option subnet-mask 255.255.255.0;
default-lease-time 600;
max-lease-time 7200;
ddns-update-style none; ddns-updates off;
log-facility local7;

subnet 192.168.100.0 netmask 255.255.255.0 {
   filename "pxelinux.0";
   next-server 192.168.100.2;
   range dynamic-bootp 192.168.100.5 192.168.100.20;
}</pre></li><li class="step" title="Step 3"><p>Edit the file <code class="filename">/etc/sysconfig/dhcpd</code>
            and setup the network interface the server should listen on: </p><pre class="screen">DHCPD_INTERFACE="eth0"</pre></li><li class="step" title="Step 4"><p>Run the <code class="systemitem">dhcp</code><a class="indexterm" name="id2553235"></a> server by calling:</p><pre class="screen"><span class="command"><strong>rcdhcpd</strong></span> start</pre></li></ol></div></div></div><div class="sect1" title="10.2. Building the suse-pxe-client Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.building"></a>10.2. Building the suse-pxe-client Example<span class="permalink"><a alt="Permalink" title="10.2. Building the suse-pxe-client Example" href="#sec.pxe.building">¶</a></span></h2></div></div></div><p>The example provided with KIWI is based on open­SUSE 11.2 and
      creates an image for a Wyse VX0 terminal with a 128MB flash card
      and 512MB of RAM. The image makes use of the <code class="systemitem">squashfs</code><a class="indexterm" name="id2553281"></a> compressed
      filesystem and its root tree is deployed as unified (aufs) based
      system. </p><pre class="screen"><span class="command"><strong>cd</strong></span> /usr/share/doc/packages/kiwi/examples
<span class="command"><strong>cd</strong></span> suse-11.2
<span class="command"><strong>kiwi</strong></span> --prepare ./suse-pxe-client --root /tmp/mypxe</pre><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create /tmp/mypxe --type pxe -d /tmp/mypxe-result</pre></div><div class="sect1" title="10.3. Using the Image"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.using"></a>10.3. Using the Image<span class="permalink"><a alt="Permalink" title="10.3. Using the Image" href="#sec.pxe.using">¶</a></span></h2></div></div></div><p>In order to make use of the image all related image parts
      needs to be copied onto the boot server. According to the example
      the following steps needs to be performed: </p><div class="procedure"><a name="proc.pxe.using"></a><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Change working directory:</p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/mypxe-result</pre></li><li class="step" title="Step 2"><p>Copy of the boot and kernel image:</p><pre class="screen"><span class="command"><strong>cp</strong></span> initrd-netboot-suse-11.2.i686-2.1.1.splash.gz \
  /srv/tftpboot/boot/initrd
<span class="command"><strong>cp</strong></span> initrd-netboot-suse-11.2.i686-2.1.1.kernel \
  /srv/tftpboot/boot/linux</pre></li><li class="step" title="Step 3"><p>Copy of the system image and md5 sum:</p><pre class="screen"><span class="command"><strong>cp</strong></span> suse-11.2-pxe-client.i686-1.2.8 /srv/tftpboot/image 
<span class="command"><strong>cp</strong></span> suse-11.2-pxe-client.i686-1.2.8.md5 /srv/tftpboot/image</pre></li><li class="step" title="Step 4"><p>Copy of the image boot configuration. Normally the boot
          configuration applies to one client which means it is required
          to obtain the MAC address of this client. If the boot
          configuration should be used globaly, copy the KIWI generated
          file as config.default: </p><pre class="screen"><span class="command"><strong>cp</strong></span> suse-11.2-pxe-client.i686-1.2.8.config \
  /srv/tftpboot/KIWI/config.<em class="replaceable"><code>MAC</code></em> </pre></li><li class="step" title="Step 5"><p>Check the PXE configuration file. The PXE configuration
          controls which kernel and initrd are loaded and which kernel
          parameters are set. When installing the <span class="package">kiwi-pxeboot</span> package,
          a default configuration is added. To make sure the
          configuration is valid according to this example, insert the
          following information into the file
            <code class="filename">/srv/tftpboot/pxelinux.cfg/default</code>: </p><pre class="screen">DEFAULT KIWI-Boot

LABEL KIWI-Boot
    kernel boot/linux
    append initrd=boot/initrd vga=0x314
    IPAPPEND 1

LABEL Local-Boot
    localboot 0</pre></li><li class="step" title="Step 6"><p>Connect the client to the network and boot. </p></li></ol></div></div><div class="sect1" title="10.4. Flavours"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.flavours"></a>10.4. Flavours<span class="permalink"><a alt="Permalink" title="10.4. Flavours" href="#sec.pxe.flavours">¶</a></span></h2></div></div></div><p>All the different PXE boot based deployment methods are
      controlled by the
        <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code> (or
        <code class="filename">config.default</code>) file. When a new client
      boots up and there is no client configuration file the new client
      is registered by uploading a control file to the <code class="systemitem">TFTP</code><a class="indexterm" name="id2553516"></a> server. The
      following sections informs about the control and the configuration
      file. </p><div class="sect2" title="10.4.1. The PXE Client Control File"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.client-control-file"></a>10.4.1. The PXE Client Control File<span class="permalink"><a alt="Permalink" title="10.4.1. The PXE Client Control File" href="#sec.pxe.client-control-file">¶</a></span></h3></div></div></div><p>This section describes the netboot client control file: </p><pre class="screen">hwtype.$&lt;$MAC Address$&gt;$</pre><p>The control file is primarily used to set up new netboot
        clients. In this case, there is no configuration file
        corresponding to the client MAC address available. Using the MAC
        address information, the control file is created, which is
        uploaded to the <code class="systemitem">TFTP</code><a class="indexterm" name="id2553558"></a> servers upload directory
          <code class="filename">/var/lib/tftpboot/upload</code>. </p></div><div class="sect2" title="10.4.2. The PXE Client Configuration File"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.client-config-file"></a>10.4.2. The PXE Client Configuration File<span class="permalink"><a alt="Permalink" title="10.4.2. The PXE Client Configuration File" href="#sec.pxe.client-config-file">¶</a></span></h3></div></div></div><p>This section describes the netboot client configuration
        file: </p><pre class="screen">config.$&lt;$MAC Address$&gt;$</pre><p>The configuration file contains data about image,
        configuration, synchronization, or partition parameters. The
        configuration file is loaded from the TFTP server directory
          <code class="filename">/var/lib/tftpboot/KIWI</code> via TFTP for
        previously installed netboot clients. New netboot clients are
        immediately registered and a new configuration file with the
        corresponding MAC address is created. The standard case for the
        deployment of a PXE image is one image file based on a
        read-write filesystem which is stored onto a local storage
        device of the client. Below, find an example to cover this case. </p><pre class="screen">DISK=/dev/sda
PART=5;S;x,x;L;/
IMAGE=/dev/sda2;suse-11.2-pxe-client.i686;1.2.8;192.168.100.2;4096</pre><p>The following format is used: </p><pre class="screen">IMAGE=device;name;version;srvip;bsize;compressed,...,
CONF=src;dest;srvip;bsize,...,src;dest;srvip;bsize
PART=size;id;Mount,...,size;id;Mount
DISK=device</pre><div class="variablelist"><dl><dt><span class="term"><code class="varname">IMAGE</code></span></dt><dd><p>Specifies which image (name) should be loaded with
              which version (version) and to which storage device
              (device) it should be linked, e.&#8201;g., <code class="filename">/dev/ram1</code><a class="indexterm" name="id2553656"></a> or <code class="filename">/dev/hda2</code><a class="indexterm" name="id2553671"></a>. The netboot
              client partition (device) hda2 defines the root file
              system / and hda1 is used for the swap partition. The
              numbering of the hard disk device should not be confused
              with the RAM disk device, where <code class="filename">/dev/ram0</code><a class="indexterm" name="id2553690"></a> is used for the
              initial RAM disk and can not be used as storage device for
              the second stage system image. SUSE recommends to use the
              device <code class="filename">/dev/ram1</code><a class="indexterm" name="id2553707"></a>
              for the RAM disk. If the hard drive is used, a
              corresponding partitioning must be performed. </p><div class="variablelist"><dl><dt><span class="term">srvip</span></dt><dd><p>Specifies the server IP address for the TFTP
                    download. Must always be indicated, except in PART.
                  </p></dd><dt><span class="term">bsize</span></dt><dd><p>Specifies the block size for the TFTP download.
                    Must always be indicated, except in PART. If the
                    block size is too small according to the maximum
                    number of data packages (32768), linuxrc will
                    automatically calculate a new blocksize for the
                    download. </p></dd><dt><span class="term">compressed</span></dt><dd><p>Specifies if the image file on the TFTP server
                    is compressed and handles it accordingly. To specify
                    a compressed image download only the keyword
                      <code class="literal">"compressed"</code> needs to be added.
                    If compressed is not specified the standard download
                    workflow is used. <span class="bold"><strong>Note:</strong></span> The download will fail if you
                    specify <code class="literal">"compressed"</code> and the
                    image isn&#8217;t compressed. It will also fail if you
                    don&#8217;t specify <code class="literal">"compressed"</code> but
                    the image is compressed. The name of the compressed
                    image has to contain the suffix <code class="filename">.gz</code><a class="indexterm" name="id2553811"></a> and needs to be
                    compressed with the <span class="command"><strong>gzip</strong></span> tool.
                    Using a compressed image will automatically
                      <span class="emphasis"><em>deactivate</em></span> the multicast
                    download option of atftp. </p></dd></dl></div></dd><dt><span class="term"><code class="varname">CONF</code></span></dt><dd><p>Specifies a comma-separated list of source:target
              configuration files. The source (src) corresponds to the
              path on the TFTP server and is loaded via TFTP. The
              download is made to the file on the netboot client
              indicated by the target (dest). </p></dd><dt><span class="term"><code class="varname">PART</code></span></dt><dd><p>Specifies the partitioning data. The comma-separated
              list must contain the size (size), the type number (id),
              and the mount point (Mount). The size is measured in MB by
              default. Additionally all size specifications supported by
              the sfdisk program are allowed as well. The type number
              specifies the ID of the partition. Valid ID&#8217;s are listed
              via the <span class="command"><strong>sfdisk</strong></span>
              <code class="option">--list-types</code> command. The mount specifies
              the directory the partition is mounted to. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The first element of the list must define the swap
                  partition. </p></li><li class="listitem"><p>The second element of the list must define the
                  root partition. </p></li><li class="listitem"><p>The swap partition must not contain a mount point.
                  A lowercase letter <code class="literal">x</code> must be set
                  instead. </p></li><li class="listitem"><p>If a partition should take all the space left on a
                  disk one can set a lower <code class="literal">x</code> letter
                  as size specification. </p></li></ul></div></dd><dt><span class="term"><code class="varname">DISK</code></span></dt><dd><p>Specifies the hard disk. Used only with PART and
              defines the device via which the hard disk can be
              addressed, e.g., <code class="filename">/dev/hda</code><a class="indexterm" name="id2553962"></a>. </p></dd><dt><span class="term"><code class="varname">RELOAD_IMAGE</code></span></dt><dd><p>If set to a non-empty string, this forces the
              configured image to be loaded from the server even if the
              image on the disk is up-to-date. The primary purpose of
              this setting is to aid debugging. The option is sensible
              only for disk based systems. </p></dd><dt><span class="term"><code class="varname">RELOAD_CONFIG</code></span></dt><dd><p>If set to a non-empty string, this forces all config
              files to be loaded from the server. The primary purpose of
              this setting is to aid debugging. The option is sensible
              only for disk based systems. </p></dd><dt><span class="term"><code class="varname">COMBINED_IMAGE</code></span></dt><dd><p>If set to an non-empty string, indicates that the both
              image specified needs to be combined into one bootable
              image, whereas the first image defines the read-write part
              and the second image defines the read-only part. </p></dd><dt><span class="term"><code class="varname">KIWI_INITRD</code></span></dt><dd><p>Specifies the KIWI initrd to be used for local boot of
              the system. The variables value must be set to the name of
              the initrd file which is used via PXE network boot. If the
              standard tftp setup suggested with the kiwi-pxeboot
              package is used all initrd files resides in the <code class="filename">boot/</code><a class="indexterm" name="id2554051"></a> directory below the
              tftp server path <code class="filename">/var/lib/tftpboot</code><a class="indexterm" name="id2554067"></a>.
              Because the tftp server do a chroot into the tftp server
              path you need to specify the initrd file as the following
              example shows: </p><pre class="screen">KIWI_INITRD=/boot/<em class="replaceable"><code>name-of-initrd-file</code></em></pre></dd><dt><span class="term"><code class="varname">UNIONFS_CONFIG</code></span></dt><dd><p>For netboot and usbboot images there is the
              possibility to use unionfs or aufs as container filesystem
              in combination with a compressed system image. The
              recommended compressed filesystem type for the system
              image is <span class="bold"><strong>squashfs</strong></span>. In
              case of a USB stick system the usbboot image will
              automatically setup the unionfs/aufs filesystem. In case
              of a PXE network image the netboot image requires a
                  <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>
              setup like the following example shows: </p><pre class="screen">UNIONFS_CONFIG=/dev/sda2,/dev/sda3,aufs</pre><p>In this example the first device <code class="filename">/dev/sda2</code><a class="indexterm" name="id2554138"></a> represents the
              read/write filesystem and the second device <code class="filename">/dev/sda3</code><a class="indexterm" name="id2554154"></a> represents the
              compressed system image filesystem. The container
              filesystem aufs is then used to cover the read/write layer
              with the read-only device to one read/write filesystem. If
              a file on the read-only device is going to be written the
              changes inodes are part of the read/write filesystem.
              Please note the device specifications in
                <code class="varname">UNIONFS_CONFIG</code> must correspond with
              the IMAGE and PART information. The following example
              should explain the interconnections: </p><pre class="screen">IMAGE=/dev/sda3;image/myImage;1.1.1;192.168.1.1;4096
PART=200;S;x,300;L;/,x;L;x
UNIONFS_CONFIG=/dev/sda2,/dev/sda3,aufs
DISK=/dev/sda</pre><p>As the second element of the PART list must define the
              root partition it&#8217;s absolutely important that the first
              device in <code class="varname">UNIONFS_CONFIG</code> references
              this device as read/write device. The second device of
                <code class="varname">UNIONFS_CONFIG</code> has to reference the
              given IMAGE device name. </p></dd><dt><span class="term"><code class="varname">KIWI_KERNEL_OPTIONS</code></span></dt><dd><p>Specifies additional command line options to be passed
              to the kernel when booting from disk. For instance, to
              enable a splash screen, you might use
                <code class="literal">vga=0x317</code>
              <code class="literal">splash=silent</code>. </p></dd><dt><span class="term"><code class="varname">KIWI_BOOT_TIMEOUT</code></span></dt><dd><p>Specifies the number of seconds to wait at the grub
              boot screen when doing a local boot. The default is 10.
            </p></dd><dt><span class="term"><code class="varname">NBDROOT</code></span></dt><dd><p>Mount the system image root filesystem remotely via
              NBD (Network Block Device). This means there is a server
              which exports the root directory of the system image via a
              specified port. The kernel provides the block layer,
              together with a remote port that uses the nbd-server
              program. For more information on how to set up the server,
              see the nbd-server man pages. The kernel on the remote
              client can set up a special network block device named
                <code class="filename">/dev/nb0</code><a class="indexterm" name="id2554274"></a> using
              the nbd-client command. After this device exists, the
              mount program is used to mount the root filesystem. To
              allow the KIWI boot image to use that, the following
              information must be provided: </p><pre class="screen">NBDROOT=NBD.Server.IP.address;\
  NBD-Port-Number;/dev/NBD-Device;\
  NBD-Swap-Port-Number;/dev/NBD-Swap-Device;\
  NBD-Write-Port-Number;/dev/NBD-Write-Device</pre><p> The NBD-Device, NBD-Swap-Port-Number,
              NBD-Swap-Device, NBD-Write-Port-Number and
              NBD-Write-Device variables are optional. If the nbd root
              device is not set, the default values (<code class="filename">/dev/nb0</code><a class="indexterm" name="id2554308"></a>, port 2000)
              applies and if the nbd swap device is not set the default
              values (<code class="filename">/dev/nb1</code><a class="indexterm" name="id2554324"></a>,
              port 9210) applies. The swap space over the network using
              a network block device is only established if the client
              has less than 48 MB of RAM. The optional
              NBD-Write-Port-Number and NBD-Write-Device specifies a
              write COW location for the root filesystem. aufs is used
              as overlay filesystem in this case. </p></dd><dt><span class="term"><code class="varname">AOEROOT</code></span></dt><dd><p>Mount the system image root filesystem remotely via
              AoE (ATA over Ethernet). This means there is a server
              which exports a block device representing the the root
              directory of the system image via the AoE subsystem. The
              block device could be a partition of a real or a virtual
              disk. In order to use the AoE subsystem I recommend to
              install the <span class="package">aoetools</span> and
                <span class="package">vblade</span> packages from here first:
                <a class="ulink" href="http://download.opensuse.org/repositories/system:/aoetools" target="_top">http://download.opensuse.org/repositories/system:/aoetools</a>. Once installed the following example shows how to
              export the local <code class="filename">/dev/sdb1</code><a class="indexterm" name="id2554380"></a> partition via AoE:</p><pre class="screen"><span class="command"><strong>vbladed</strong></span> 0 1 eth0 /dev/sdb1 </pre><p> Some explanation about this command, each AoE device
              is identified by a couple Major/Minor, with major between
              0-65535 and minor between 0-255. AoE is based just over
              Ethernet on the OSI models so we need to indicate which
              ethernet card we&#8217;ll use. In this example we export
                <code class="filename">/dev/sdb1</code><a class="indexterm" name="id2554419"></a> with a
              major value of 0 and minor of 1 on the eth0 interface. We
              are ready to use our partition on the network! To be able
              to use the device KIWI needs the information which AoE
              device contains the root filesystem. In our example this
              is the device <code class="filename">/dev/etherd/e0.1</code><a class="indexterm" name="id2554439"></a>. According to this the
              AOEROOT variable must be set as follows: </p><pre class="screen">AOEROOT=/dev/etherd/e0.1</pre><p> KIWI is now able to mount and use the specified AoE
              device as the remote root filesystem. In case of a
              compressed read-only image with <code class="systemitem">aufs</code><a class="indexterm" name="id2554467"></a> 
              or <code class="systemitem">clicfs</code><a class="indexterm" name="id2554481"></a>, the
              AOEROOT variable can also contain a device for the write
              actions: </p><pre class="screen">AOEROOT=/dev/etherd/e0.1,/dev/ram1</pre><p> Writing to RAM is the default but you also can set
              another device like another aoe location or a local device
              for writing the data </p></dd><dt><span class="term"><code class="varname">NFSROOT</code></span></dt><dd><p>Mount the system image root filesystem remotely via NFS
              (Network File System). This means there is a
              server which exports the root filesystem of the network
              client in such a way that the client can mount it
              read/write. In order to do that, the boot image must know
              the server IP address and the path name where the root
              directory exists on this server. The information must be
              provided as in the following example: </p><pre class="screen">NFSROOT=NFS.Server.IP.address;/path/to/root/tree</pre><p> Optionally you can set a <code class="varname">UNIONFS_CONFIG</code> variable
              which defines an aufs based overlay NFS directory or
              device like: </p><pre class="screen">UNIONFS_CONFIG=/tmp/kiwi-11.1-cow,nfs,aufs # write to NFS directory
UNIONFS_CONFIG=/dev/ram1,nfs,aufs # write to RAM</pre><p> This way you can keep the original root tree clean
              from any modifications </p></dd><dt><span class="term"><code class="varname">KIWI_INITRD</code></span></dt><dd><p>Specifies the KIWI initrd to be used for a local boot
              of the system. The value must be set to the name of the
              initrd file which is used via PXE network boot. If the
              standard TFTP setup suggested with the kiwi-pxeboot
              package is used, all initrd files reside in the <code class="filename">/srv/tftpboot/boot/</code><a class="indexterm" name="id2554586"></a>
              directory. Because the TFTP server does a chroot into the
              TFTP server path, you must specify the initrd file as
              follows: </p><pre class="screen">KIWI_INITRD=/boot/name-of-initrd-file</pre></dd><dt><span class="term"><code class="varname">KIWI_KERNEL</code></span></dt><dd><p>Specifies the kernel to be used for a local boot of
              the system The same path rules as described for
                <code class="varname">KIWI_INITRD</code> applies for the kernel
              setup: </p><pre class="screen">KIWI_KERNEL=/boot/name-of-kernel-file</pre></dd><dt><span class="term"><code class="varname">ERROR_INTERRUPT</code></span></dt><dd><p>Specifies a message which is displayed during first
              deployment. Along with the message a shell is provided.
              This functionality should be used to send the user a
              message if it&#8217;s clear the boot process will fail because
              the boot environment or something else influences the pxe
              boot process in a bad way. </p></dd></dl></div></div><div class="sect2" title="10.4.3. User another than tftp as Download Protocol"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.another-user"></a>10.4.3. User another than tftp as Download Protocol<span class="permalink"><a alt="Permalink" title="10.4.3. User another than tftp as Download Protocol" href="#sec.pxe.another-user">¶</a></span></h3></div></div></div><p>By default all downloads controlled by the KIWI linuxrc code
        are performed by an atftp call and therefore uses the tftp
        protocol. With PXE the download protocol is fixed and thus you
        can&#8217;t change the way how the kernel and the boot image (initrd)
        is downloaded. As soon as Linux takes over control the following
        download protocols http, https and ftp are supported too. KIWI
        makes use of the <span class="command"><strong>curl</strong></span> program to support the
        additional protocols. </p><p>In order to select one of the additional download protocols
        the following kernel parameters needs to be setup: </p><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>kiwiserver</code></em></span></dt><dd><p>Name or IP address of the server who implements the
              protocol </p></dd><dt><span class="term"><em class="parameter"><code>kiwiservertype</code></em></span></dt><dd><p>Name of the download protocol which could be one of
              http, https or ftp </p></dd></dl></div><p>To setup this parameters edit the file
          <code class="filename">/srv/tftpboot/pxelinux.cfg/default</code> on
        your PXE boot server and change the append line accordingly.
        Please note all downloads except for kernel and initrd are now
        controlled by the given server and protocol. You need to make
        sure that this server provides the same directory and file
        structure as initially provided by the <span class="package">kiwi-pxeboot</span> package.
      </p></div><div class="sect2" title="10.4.4. RAM Only Image"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.ram-only-image"></a>10.4.4. RAM Only Image<span class="permalink"><a alt="Permalink" title="10.4.4. RAM Only Image" href="#sec.pxe.ram-only-image">¶</a></span></h3></div></div></div><a class="indexterm" name="id2554765"></a><p>If there is no local storage and no remote root mount setup
        the image can be stored into the main memory of the client.
        Please be aware that there should be still enough RAM space
        available for the operating system after the image has been
        deployed into RAM. Below, find an example: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Use a read-write filesystem in
              <code class="filename">config.xml</code>, for example
              <code class="literal">filesystem="ext3"</code>
          </p></li><li class="listitem"><p>Create
              <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>
          </p><pre class="screen">IMAGE=/dev/ram1;suse-11.2-pxe-client.i686;\
      1.2.8;192.168.100.2;4096</pre></li></ul></div></div><div class="sect2" title="10.4.5. Union Image"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.union-image"></a>10.4.5. Union Image<span class="permalink"><a alt="Permalink" title="10.4.5. Union Image" href="#sec.pxe.union-image">¶</a></span></h3></div></div></div><a class="indexterm" name="id2554835"></a><p>As used in the suse-pxe-client example it is possible to
        make use of the aufs or unionfs overlay filesystems to combine
        two filesystems into one. In case of thin clients there is often
        the need for a compressed filesystem due to space limitations.
        Unfortunately all common compressed filesystems provides only
        read-only access. Combining a read-only filesystem with a
        read-write filesystem is a solution for this problem. In order
        to use a compressed root filesystem make sure your
          <code class="filename">config.xml</code>&#8217;s filesystem attribute
        contains either <code class="systemitem">squashfs</code><a class="indexterm" name="id2554870"></a> 
        or <code class="systemitem">clicfs</code><a class="indexterm" name="id2554885"></a>. Below, find an example: </p><pre class="screen">DISK=/dev/sda
PART=5;S;x,62;L;/,x;L;x,
IMAGE=/dev/sda2;suse-11.2-pxe-client.i386;\
      1.2.8;192.168.100.2;4096
UNIONFS_CONFIG=/dev/sda3,/dev/sda2,aufs
KIWI_INITRD=/boot/initrd</pre></div><div class="sect2" title="10.4.6. Split Image"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.split-image"></a>10.4.6. Split Image<span class="permalink"><a alt="Permalink" title="10.4.6. Split Image" href="#sec.pxe.split-image">¶</a></span></h3></div></div></div><a class="indexterm" name="id2554911"></a><p>As an alternative to the <code class="varname">UNIONFS_CONFIG</code>
        method it is also possible to create a split image and combine
        the two portions with the <code class="varname">COMBINED_IMAGE</code>
        method. This allows to use different filesystems without the
        need for an overlay filesystem to combine them together. Below
        find an example: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Add a split type in <code class="filename">config.xml</code>, for
            example </p><pre class="screen">&lt;type fsreadonly="squashfs" 
   image="split" fsreadwrite="ext3" boot="netboot/suse-11.2"/&gt;</pre></li><li class="listitem"><p>Add a split section inside the type to describe the
              <code class="sgmltag-element">temporary</code> and
              <code class="sgmltag-element">persistent</code> parts. For example:</p><pre class="screen">&lt;split&gt;
  &lt;temporary&gt; 
    <code class="sgmltag-sgmlcomment">&lt;!-- allow RAM read/write access to: --&gt;</code>
    &lt;file name="/mnt"/&gt; 
    &lt;file name="/mnt/*"/&gt; 
  &lt;/temporary&gt;
  &lt;persistent&gt;
    <code class="sgmltag-sgmlcomment">&lt;!-- allow DISK read/write access to: --&gt;</code>
    &lt;file name="/var"/&gt; 
    &lt;file name="/var/*"/&gt; 
    &lt;file name="/boot"/&gt; 
    &lt;file name="/boot/*"/&gt;
    &lt;file name="/etc"/&gt; 
    &lt;file name="/etc/*"/&gt;
    &lt;file name="/home"/&gt;
    &lt;file name="/home/*"/&gt;
  &lt;/persistent&gt; 
&lt;/split&gt;</pre></li><li class="listitem"><p>Sample
              <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>: </p><pre class="screen">IMAGE=/dev/sda2;suse-11.2-pxe-client.i686;\
      1.2.8;192.168.100.2;4096,\
      /dev/sda3;suse-11.2-pxe-client-read-write.i686;\
      1.2.8;192.168.100.2;4096
PART=200;S;x,500;L;/,x;L;
DISK=/dev/sda
COMBINED_IMAGE=yes
KIWI_INITRD=/boot/initrd</pre></li></ul></div></div><div class="sect2" title="10.4.7. Root Tree Over NFS"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.root-tree-over-nfs"></a>10.4.7. Root Tree Over NFS<span class="permalink"><a alt="Permalink" title="10.4.7. Root Tree Over NFS" href="#sec.pxe.root-tree-over-nfs">¶</a></span></h3></div></div></div><p> Instead of installing the image onto a local storage device
        of the client it is also possible to let the client mount the
        root tree via an <code class="systemitem">NFS</code><a class="indexterm" name="id2555043"></a>
        remote mount. Below find an example: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Export the KIWI prepared tree via NFS.</p></li><li class="listitem"><p>Sample
              <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>: </p><pre class="screen">NFSROOT=192.168.100.7;/tmp/kiwi.nfsroot</pre></li></ul></div></div><div class="sect2" title="10.4.8. Root Tree Over NBD"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.root-tree-over-nbd"></a>10.4.8. Root Tree Over NBD<span class="permalink"><a alt="Permalink" title="10.4.8. Root Tree Over NBD" href="#sec.pxe.root-tree-over-nbd">¶</a></span></h3></div></div></div><p>As an alternative for root over NFS it is also possible to
        let the client mount the root tree via a special network block
        device. Below find an example: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Use nbd-server to export the KIWI prepared tree.</p></li><li class="listitem"><p>Sample
              <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>
          </p><pre class="screen">NBDROOT=192.168.100.7;2000;/dev/nbd0</pre></li></ul></div></div><div class="sect2" title="10.4.9. Root Tree Over AoE"><div class="titlepage"><div><div><h3 class="title"><a name="sec.pxe.root-tree-over-aoe"></a>10.4.9. Root Tree Over AoE<span class="permalink"><a alt="Permalink" title="10.4.9. Root Tree Over AoE" href="#sec.pxe.root-tree-over-aoe">¶</a></span></h3></div></div></div><p>As an alternative for root over NBD it is also possible to
        let the client mount the root device via a special ATA over
        Ethernet network block device. Below find an example: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Use the <span class="command"><strong>vbladed</strong></span> command to bind a
            block device to an ethernet interface. The block device can
            be a disk partition or a loop device (losetup) but not a
            directory like with NBD. </p></li><li class="listitem"><p>Sample
              <code class="filename">config.<em class="replaceable"><code>MAC</code></em></code>: </p><pre class="screen">AOEROOT=/dev/etherd/e0.1</pre><p>This would require the following command to be called
            first:</p><pre class="screen"><span class="command"><strong>vbladed</strong></span> 0 1 eth0 blockdevice</pre></li></ul></div></div></div><div class="sect1" title="10.5. Hardware Grouping"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.pxe.groups"></a>10.5. Hardware Grouping<span class="permalink"><a alt="Permalink" title="10.5. Hardware Grouping" href="#sec.pxe.groups">¶</a></span></h2></div></div></div><p>While the PXE standard takes care of the ability to create hardware groups via hardware or
      IP address groups, it does not take into account groups for non-contiguous hardware or IP
      addresses. The PXE standard makes the assumption that each hardware group will be clearly
      deliniated by a range of IP addresses, or the hardware is from the same vendor. While an ideal
      scenario, this may not be the case in an established, slightly dated installation where the
      hardware itself has out-lived the vendors that made them.</p><p>KIWI has the ability to create groups for non-contiguous configurations
      where different hardware types may be involved due to newer equipment being rotated into
      production or older hardware failing and replacements are from different vendors. In addition,
      an organization might decide to organize their equipment by function, rather then by vendor,
      and may not be able to use the same hardware from one end to the other. </p><div class="sect2" title="10.5.1. The Group Configuration File"><div class="titlepage"><div><div><h3 class="title"><a name="id2555227"></a>10.5.1. The Group Configuration File<span class="permalink"><a alt="Permalink" title="10.5.1. The Group Configuration File" href="#id2555227">¶</a></span></h3></div></div></div><p>To make use of the grouping functionality, some new configuration files will be
        required. These configuration files currently have to be manually managed rather then
        provided, however future versions of KIWI may provide a means of managing groups more
        effectively once this feature stabilizes. The number of configuration files required will
        depend on the number of hardware groups that will be created, rather then one configuration
        file for each MAC address that will reside on the network. </p><p>There will be one configuration file that will always be required if using groups,
        called:</p><pre class="screen">/srv/tftpboot/KIWI/config.group</pre><p>This file has a new static element that must exist, and one or more dynamic
        elements depending on the number of groups that will be created. For example, the
        config.group file defined below lists 3 distinct groups:</p><pre class="screen">KIWI_GROUP="test1, test2, test3"

test1_KIWI_MAC_LIST="11:11:11:11:11:11, 00:11:00:11:22:CA"

test2_KIWI_MAC_LIST="00:22:00:44:00:4D, 99:3F:21:A2:F4:32"

test3_KIWI_MAC_LIST="00:54:33:FA:44:33, 84:3D:45:2F:5F:33"</pre><p>Note: The above hardware addresses contain random entries, and may not reflect actual
        hardware.</p><p>As we can see in the above example the file contains 1 static element, KIWI_GROUP, and 3
        dynamic elements "test1_KIWI_MAC_LIST, test2_KIWI_MAC_LIST and test3_KIWI_MAC_LIST". The
        definitions of these elements are as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>KIWI_GROUP</p><p>This element is the only static definition that needs to exist when using groups.
            While there is no implicit limit to the number of groups that can be configured, it
            should be kept to a minimum for reasonable management or it could quickly become
            un-manageable. It will need to contain one or more group names separted by comma's (,) and
            spacing (for readability). In the above example, our group names were:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>test1</p></li><li class="listitem"><p>test2</p></li><li class="listitem"><p>test3</p></li></ul></div><p>Valid group names are made up of upper and lower case letters,  and can use numeric, and
            underscore characters. The same rules used to define bash/sh variable names should apply
            here, as these names will have to be used as fully defined bash/sh variables when
            linking hardware addresses to an assigned group. The following is an example that contains
            valid names:</p><pre class="screen">KIWI_GROUP="test1, test_my_name, LIST_HARDWARE, Multple_Case_Group_1"</pre></li><li class="listitem"><p>&lt;GROUP_NAME&gt;_KIWI_MAC_LIST</p><p>The name of this element is dynamic and depends entirely on the list of group names
            that were previously defined. Each group name that was used in the KIWI_GROUP
            variable, must contain a matching dynamic element, and have KIWI_MAC_LIST appended to
            the name. To continue with our previous example, to create hardware lists for the groups 
            already defined, we need 3 dynamic elements called:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>test1_KIWI_MAC_LIST</p></li><li class="listitem"><p>test2_KIWI_MAC_LIST</p></li><li class="listitem"><p>test3_KIWI_MAC_LIST</p></li></ul></div><p>These variables will contain a comma delimited list of the hardware addresses for
            all of the machines being assigned to the appropriate group, but there are some caveats
            that need to be kept in mind. The first caveat is for hardware addresses that contain
            the HEX characters A-F. The PXE standard uses capital letters for these characters, and
            as a result KIWI does upper case comparisons, so a MAC address that is defined with
            lower case letters in this list will never get matched.</p><p>The second caveat is that as the list gets longer, it can be harder to maintain
            and it has the potential to slow down the booting process. However, testing has been 
            completed with 1500+ hosts defined, and there was little delay when transfering the 
            file to a single host. The file size will have a larger impact when trying to download
            it to 1500+ hosts, so some consideration will have to take that into account. 
            The comparison itself still occurred in under half a second while searching 
            through all 1500+ MAC addresses across 3 defined groups.</p></li></ul></div></div><div class="sect2" title="10.5.2. The Hardware Group File"><div class="titlepage"><div><div><h3 class="title"><a name="id2555412"></a>10.5.2. The Hardware Group File<span class="permalink"><a alt="Permalink" title="10.5.2. The Hardware Group File" href="#id2555412">¶</a></span></h3></div></div></div><p>In addition to the config.group file, each defined group will require a
        config.&lt;GROUP_NAME&gt; file. This file is exactly like a standard KIWI config.&lt;MAC&gt; file,
        but is assigned to a group of hosts rather then a single unit. If we continue with the
        example we used in the previous section, we would need the following files:</p><pre class="screen">/srv/tftpboot/KIWI/config.test1
/srv/tftpboot/KIWI/config.test2
/srv/tftpboot/KIWI/config.test3</pre><p>The contents of these files is the same that would normally reside in a config.&lt;MAC&gt;
        file, and all defintions that would be supported for a single host, are supported for a
        group of hosts. In addition, if a host is matched to a group, yet the config.&lt;GROUP_NAME&gt;
        file does not exist, KIWI will error out.</p><p>For example, the following configiuration file, called config.test1 would be used for
        the group called "test1":</p><pre class="screen">DISK=/dev/sda
PART=5;S;x,x;L;/
IMAGE=/dev/sda2;suse-11.2-pxe-client.i686;1.2.8;192.168.100.2;4096
CONF=CONFIGURATIONS/xorg.conf.test1;/etc/X11/xorg.conf;192.168.100.2;4096,CONFIGURATIONS/syslog.conf;/etc/sysconfig/syslog.conf;192.168.100.2;4096</pre><p>As a result of this configuration file, the image would be configured consistantly
        across all the hosts assigned to test1. The following file called config.test2, contains a
        small change that may be specific to a function:</p><pre class="screen">DISK=/dev/sda
PART=5;S;x,x;L;/
IMAGE=/dev/sda2;suse-11.2-pxe-client.i686;1.2.8;192.168.100.2;4096
CONF=CONFIGURATIONS/xorg.conf.test2;/etc/X11/xorg.conf;192.168.100.2;4096,CONFIGURATIONS/syslog.conf;/etc/sysconfig/syslog.conf;192.168.100.2;4096</pre><p>As we can see, while group 1 and 2 share the syslog.conf configuration file, they have
        different xorg.conf files defined, therefore two distinct groups with one or more hosts
        assigned to each group can now be configured by managing a smaller number of files.</p></div></div></div><div class="chapter" title="Chapter 11. OEM Image&#8212;Preload Systems"><div class="titlepage"><div><div><h2 class="title"><a name="chap.oem"></a>Chapter 11. OEM Image&#8212;Preload Systems</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.oem.building">11.1. Building the suse-oem-preload Example</a></span></dt><dt><span class="sect1"><a href="#sec.oem.using">11.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.oem.flavours">11.3. Flavours</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec.oem.installation">11.3.1. Specializing the OEM install process</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partitioning">11.3.2. Influencing the OEM Partitioning</a></span></dt><dt><span class="sect2"><a href="#sec.oem.lvm">11.3.3. LVM Support</a></span></dt><dt><span class="sect2"><a href="#sec.oem.partition-based-installation">11.3.4. Partition Based Installation</a></span></dt></dl></dd></dl></div><a class="indexterm" name="id2555506"></a><a class="indexterm" name="id2555517"></a><a class="indexterm" name="id2555529"></a><p>An OEM image is a virtual disk image representing all partitions
    and bootloader information in the same fashion it exists on a
    physical disk. The image format matches the format of the VMX image
    type. All flavors discussed previously for the VMX image type apply
    to the OEM image type. </p><p>The basic idea behind an oem image is to provide the virtual
    disk data for OEM vendors to support easy deployment of the system
    to physical storage media. The deployment can be performed from any
    OS including Windows as long as a tool to dump data onto a disk
    device exists and is used. The oem image type may also be used to
    deploy an image on a USB stick. A USB stick is simply a removable
    physical storage device. </p><div class="sect1" title="11.1. Building the suse-oem-preload Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.building"></a>11.1. Building the suse-oem-preload Example<span class="permalink"><a alt="Permalink" title="11.1. Building the suse-oem-preload Example" href="#sec.oem.building">¶</a></span></h2></div></div></div><p>The OEM example provided with kiwi is based on recent openSUSE
      releases, one example configuration per release, and includes the
      default and x11 patterns. The image type is a split type utilizing
      the distributions default filesystem format for the read-write
      partition and the <code class="systemitem">squashfs</code><a class="indexterm" name="id2555578"></a> filesystem for the read-only partition.
      Using the additional <code class="sgmltag-attribute">installiso</code><a class="indexterm" name="id2555592"></a> attribute creates an installable ISO
      image. When booting from the ISO image the OEM disk image will be
      deployed to the storage media on the booting machine (after
      confirmation by the user). </p><p>The commands provided below use the openSUSE 11.2 based
      example built for the x86 architecture. </p><pre class="screen"><span class="command"><strong>cd</strong></span> /usr/share/doc/packages/kiwi/examples
<span class="command"><strong>cd</strong></span> suse-11.2
<span class="command"><strong>kiwi</strong></span> --prepare ./suse-oem-preload --root /tmp/myoem </pre><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create /tmp/myoem --type split -d /tmp/myoem-result</pre></div><div class="sect1" title="11.2. Using the Image"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.using"></a>11.2. Using the Image<span class="permalink"><a alt="Permalink" title="11.2. Using the Image" href="#sec.oem.using">¶</a></span></h2></div></div></div><p>The virtual disk image created by KIWI with the commands shown
      above can be tested using virtualization software such as QEMU,
      VMware, or VirtualBox. The virtual disk is represented by the file
      with the <code class="filename">.raw</code><a class="indexterm" name="id2555662"></a> extension,
      whereas the file with the <code class="filename">.iso</code><a class="indexterm" name="id2555678"></a> extension represents the installation disk for
      this oem image. The ISO image is bootable
        (<code class="filename">filename.iso</code>) and can be burned to optical
      media. It is recommended to test the image on a bare test system.
      The following command shows how to use QEMU to test the OEM disk
      image (<code class="filename">filename.raw</code>). </p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/myoem-result 
<span class="command"><strong>qemu</strong></span> suse-11.2-oem-preload.i686-1.1.2.raw -m 512</pre><p>or using the <span class="command"><strong>dd</strong></span> command you can dump the
      image onto a test hard disk or USB stick and upon reboot select
      the appropriate device as the boot device in the BIOS: </p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/myoem-result 
<span class="command"><strong>dd</strong></span> if=suse-11.2-oem-preload.i686-1.1.2.raw of=/dev/<em class="replaceable"><code>device</code></em> bs=32k</pre><p>Note, when testing an oem image using the virtual disk image,
      i.e. the <code class="filename">.raw</code><a class="indexterm" name="id2555760"></a> file, the
      geometry of the disk image is not changed and therefore retains
      the disk geometry of the host system. This implies that the
      re-partitioning performed for a physical disk install during the
      oem boot workflow will be skipped. </p><p>You can test the installation procedure in a virtual
      environment using the <code class="filename">.iso</code><a class="indexterm" name="id2555784"></a>
      file. In this case the re-partitioning code in the boot image will
      be executed. The following commnads show this procedure using
      QEMU. </p><pre class="screen"><span class="command"><strong>cd</strong></span> /tmp/myoem-result 
<span class="command"><strong>qemu-img</strong></span> create /tmp/mydisk 20G 
<span class="command"><strong>qemu</strong></span> -hda /tmp/mydisk -cdrom suse-11.2-oem-preload.i686-1.1.2.iso -boot d</pre></div><div class="sect1" title="11.3. Flavours"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.oem.flavours"></a>11.3. Flavours<span class="permalink"><a alt="Permalink" title="11.3. Flavours" href="#sec.oem.flavours">¶</a></span></h2></div></div></div><p>As indicated above the use of the <code class="sgmltag-attribute">installiso</code><a class="indexterm" name="id2555834"></a> and <code class="sgmltag-attribute">installstick</code><a class="indexterm" name="id2555846"></a> attributes for the oem image supports
      the creation of an installation image. The installation image can
      be created in two formats, one suitable for CD/DVD media and a
      second suitable for a USB stick. The self installing image deploys
      the oem image onto the selected storage device. The installation
      process is a simple image dump using the <span class="command"><strong>dd</strong></span> command.
      During this process the target system remains in terminal mode. The
      following configuration snippets show the use of the <code class="sgmltag-attribute">installiso</code><a class="indexterm" name="id2555873"></a> and <code class="sgmltag-attribute">installstick</code><a class="indexterm" name="id2555886"></a> attributes to create
      the ISO or USB installation image format respectively. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="screen">&lt;type image="name" ... installiso="true"/&gt;</pre><p>Creates a <code class="filename">.iso</code><a class="indexterm" name="id2555916"></a> file
          which can be burned onto a CD or a DVD. This represents an
          installation CD/DVD </p></li><li class="listitem"><pre class="screen">&lt;type image="name" ... installstick="true"/&gt;</pre><p>Creates a <code class="filename">.raw.install</code><a class="indexterm" name="id2555945"></a> file which can be dumped
            (<span class="command"><strong>dd</strong></span>) onto a USB stick. This represents an
          installation Stick </p></li></ul></div><div class="sect2" title="11.3.1. Specializing the OEM install process"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.installation"></a>11.3.1. Specializing the OEM install process<span class="permalink"><a alt="Permalink" title="11.3.1. Specializing the OEM install process" href="#sec.oem.installation">¶</a></span></h3></div></div></div><p>It is possible to specialize the OEM install process by providing
          shell scripts with the following names in the
          <code class="filename">root/kiwi-hooks</code> directory in the configuration
          tree as overlay files.
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="filename">preHWdetect.sh</code>
              This script is executed prior to the hardware scan on the
                  target machine.</p></li><li class="listitem"><p><code class="filename">preImageDump.sh</code>
              This script is executed immediately prior to the OEM
                  image dump onto the target storage device.</p></li><li class="listitem"><p><code class="filename">postImageDump.sh</code>
              This script is executed directly after the OEM image dump
                  onto the target storage device once the image checksum has
                  been successfully verified.</p></li></ul></div><p>
      </p></div><div class="sect2" title="11.3.2. Influencing the OEM Partitioning"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.partitioning"></a>11.3.2. Influencing the OEM Partitioning<span class="permalink"><a alt="Permalink" title="11.3.2. Influencing the OEM Partitioning" href="#sec.oem.partitioning">¶</a></span></h3></div></div></div><p>By default the oemboot process will create/modify a swap,
          <code class="filename">/home</code> and <code class="filename">/</code>
        partition. It is possible to influence the behavior with the
          <code class="sgmltag-element">oem-*</code> elements. See <a class="xref" href="#chap.description" title="Chapter 2. KIWI Image Description">Chapter 2, <i>KIWI Image Description</i></a> for details. </p></div><div class="sect2" title="11.3.3. LVM Support"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.lvm"></a>11.3.3. LVM Support<span class="permalink"><a alt="Permalink" title="11.3.3. LVM Support" href="#sec.oem.lvm">¶</a></span></h3></div></div></div><a class="indexterm" name="id2556068"></a><p>KIWI also provides support for LVM (Logical Volume
        Management). In this mode the disk partition table will include
        one lvm partition and one standard ext2 boot partition. KIWI
        creates the kiwiVG volume group, unless the lvmgroup attribute
        has been set, and adds logical volumes to the group based on the
        configuration given by the <code class="sgmltag-element">lvmvolumes</code> block
        for this type. The filesystem for the volume group is determined
        by the <code class="sgmltag-attribute">filesystem</code><a class="indexterm" name="id2556097"></a> attribute
        of the type element. After booting the system the user has full
        control over the volume group and is free to change
        (resize/increase) the group and the volumes inside. Support for
        LVM has been added for all disk based image types. This includes
        the vmx, oem and usb image types. In order to use LVM for the
        oem type just add the <code class="option">--lvm</code> command line option
        when executing the create step or add the attribute <code class="sgmltag-attribute">lvm</code><a class="indexterm" name="id2556121"></a>="<code class="sgmltag-attvalue">true</code>" to of the <code class="sgmltag-element">type</code> element in
        your <code class="filename">config.xml</code> file. </p><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create /tmp/myoem --type oem -d /tmp/myoem-result --lvm</pre><p>With the optional <code class="sgmltag-element">lvmvolumes</code> section you
        can specify to have one or more top level directories in a
        s -deparate volume. See <a class="xref" href="#chap.description" title="Chapter 2. KIWI Image Description">Chapter 2, <i>KIWI Image Description</i></a> for a
        detailed explanation. </p></div><div class="sect2" title="11.3.4. Partition Based Installation"><div class="titlepage"><div><div><h3 class="title"><a name="sec.oem.partition-based-installation"></a>11.3.4. Partition Based Installation<span class="permalink"><a alt="Permalink" title="11.3.4. Partition Based Installation" href="#sec.oem.partition-based-installation">¶</a></span></h3></div></div></div><p>The default installation method of an OEM is dumping the
        entire virtual disk on the selected target disk and repartition
        the disk to the real geometry. This works but will also wipe
        everything which was on the disk before. KIWI also supports the
        installation into already existing partitions. This means the
        user can setup a disk with free partitions for the KIWI OEM
        installation process. This way already existing data will not be
        touched. In order to activate the partition based install mode
        the following oem option has to be set in
          <code class="filename">config.xml</code>: </p><pre class="screen">&lt;oem-partition-install&gt;true&lt;/oem-partition-install&gt;</pre><p>Compared to the disk based install the following differences
        should be mentioned: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The bootloader will be setup to boot the installed
            system. There is no multiboot setup. The user is expected
            to implement the setup of a multiboot bootloader.
          </p></li><li class="listitem"><p>The oem options for system, swap and home doesn&#8217;t have
            any effect if the installation happens in predefined
            partitions. </p></li><li class="listitem"><p>There is no support for remote (PXE) OEM installation
            because kiwi has to loop mount the disk image in order to
            access the partitions which can&#8217;t be done remotely. </p></li><li class="listitem"><p>The raw disk image is stored uncompressed on the install
            media. This is because KIWI needs to loop mount the disk
            image which it can&#8217;t do if the file is only available as
            compressed version. This means the install media in this
            mode will be approximately double the size of a standard
            install media. </p></li></ul></div></div></div></div><div class="chapter" title="Chapter 12. Xen Image&#8212;Paravirtual Systems"><div class="titlepage"><div><div><h2 class="title"><a name="chap.xen"></a>Chapter 12. Xen Image&#8212;Paravirtual Systems</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.xen.building">12.1. Building the suse-xen-guest Example</a></span></dt><dt><span class="sect1"><a href="#sec.xen.using">12.2. Using the Image</a></span></dt><dt><span class="sect1"><a href="#sec.xen.flavours">12.3. Flavours</a></span></dt></dl></div><a class="indexterm" name="id2556280"></a><a class="indexterm" name="id2556291"></a><a class="indexterm" name="id2556303"></a><p>Xen is a free software virtual machine monitor. It allows
    several guest operating systems to be executed on the same computer
    hardware at the same time. </p><p>A Xen system is structured with the Xen hypervisor as the lowest
    and most privileged layer. Above this layer are one or more guest
    operating systems, which the hypervisor schedules across the
    physical CPUs. The first guest operating system, called in Xen
    terminology <span class="quote">&#8220;<span class="quote">domain 0</span>&#8221;</span> (dom0), is booted automatically
    when the hypervisor boots and given special management privileges
    and direct access to the physical hardware. The system administrator
    logs into dom0 in order to start any further guest operating
    systems, called <span class="quote">&#8220;<span class="quote">domain 0</span>&#8221;</span> (domU) in Xen terminology. </p><p>A Xen image is a virtual disk like a vmx but with the xen kernel
    installed. In order to run it a Xen dom0 server needs to run. Xen
    images in KIWI makes use of the PVGrub method supported by current
    Xen versions. Xen extracts the kernel and initrd from the virtual
    disk as well as the grub configuration and displays the menu which
    allows emulation of the Grub console </p><div class="sect1" title="12.1. Building the suse-xen-guest Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.building"></a>12.1. Building the suse-xen-guest Example<span class="permalink"><a alt="Permalink" title="12.1. Building the suse-xen-guest Example" href="#sec.xen.building">¶</a></span></h2></div></div></div><p>The latest example provided with KIWI is based on openSUSE
      11.3 and includes the base pattern. </p><pre class="screen"><span class="command"><strong>cd</strong></span> /usr/share/doc/packages/kiwi/examples cd suse-11.2
<span class="command"><strong>kiwi</strong></span> --prepare ./suse-xen-guest --root /tmp/myxen</pre><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create /tmp/myxen --type vmx -d /tmp/myxen-result</pre></div><div class="sect1" title="12.2. Using the Image"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.using"></a>12.2. Using the Image<span class="permalink"><a alt="Permalink" title="12.2. Using the Image" href="#sec.xen.using">¶</a></span></h2></div></div></div><p>In order to run a domain U the Xen tool <span class="command"><strong>xm</strong></span>
      needs to be called in conjunction with the KIWI genereated domain
      U configuration file </p><pre class="screen"><span class="command"><strong>xm</strong></span> create -c /tmp/myxen-result/  suse-11.2-xen-guest.i686-1.1.2.xenconfig </pre></div><div class="sect1" title="12.3. Flavours"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.xen.flavours"></a>12.3. Flavours<span class="permalink"><a alt="Permalink" title="12.3. Flavours" href="#sec.xen.flavours">¶</a></span></h2></div></div></div><p>With KIWI you can provide the information required to create a
      guest configuration as part of the <code class="filename">config.xml</code> file. Additionally
      you can group special packages which you may only need in this
      para virtual environment with a profile. </p><pre class="screen">&lt;packages type="image" profiles="xenFlavour"&gt;
  &lt;package name="kernel-xen" replaces="kernel-ec2"/&gt;
&lt;/packages&gt;
&lt;type ....&gt; 
  &lt;machine memory="512" domain="domU"&gt; 
    &lt;vmdisk ... device="/dev/xvda"/&gt;
  &lt;/machine&gt;
&lt;/type&gt; </pre><p>If this information is present KIWI will create a Xen domain U
      configuration with 512 MB of RAM and expects the disk at <code class="filename">/dev/xvda</code><a class="indexterm" name="id2556469"></a>. Additional information
      to setup the Xen guest machine properties are explained in the
      machine section. The KIWI Xen domain U configuration is stored in
      the file <code class="filename">/tmp/myxen-result/suse-11.2-xen-guest.i686-1.1.2.xenconfig</code>.</p></div></div><div class="chapter" title="Chapter 13. EC2 Image&#8212;Amazon Elastic Compute Cloud"><div class="titlepage"><div><div><h2 class="title"><a name="chap.ec2"></a>Chapter 13. EC2 Image&#8212;Amazon Elastic Compute Cloud</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.ec2.building">13.1. Building the suse-xen-guest Example for EC2</a></span></dt><dt><span class="sect1"><a href="#sec.ec2.using">13.2. Using the Image</a></span></dt></dl></div><a class="indexterm" name="id2556498"></a><a class="indexterm" name="id2556510"></a><a class="indexterm" name="id2556522"></a><a class="indexterm" name="id2556533"></a><p>The <span class="trademark">Amazon Elastic Compute Cloud</span>&#8482; (Amazon
    EC2) web service provides you with the ability to execute arbitrary
    applications in our computing environment. To use Amazon EC2 you
    simply: </p><div class="procedure"><a name="proc.ec2.using"></a><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Create an Amazon Machine Image (AMI) containing all your
        software, including your operating system and associated
        configuration settings, applications, libraries, etc. Such an
        AMI can be created by the KIWI ec2 image format. In order to do
        that KIWI makes use of the tools provided by Amazon. Your build
        system should have these tools installed. Due to license issues
        we are not allowed to distribute the tools which means you need
        to download, install and setup them from here:<a class="ulink" href="http://aws.amazon.com/documentation/ec2/" target="_top">http://aws.amazon.com/documentation/ec2/</a>
      </p></li><li class="step" title="Step 2"><p>Upload this AMI to the Amazon S3 (Amazon Simple Storage
        Service) service. This gives us reliable, secure access to your
        AMI. </p></li><li class="step" title="Step 3"><p>Register your AMI with Amazon EC2. This allows us to verify
        that your AMI has been uploaded correctly and to allocate a
        unique identifier for it. </p></li><li class="step" title="Step 4"><p>Use this AMI ID and the Amazon EC2 web service APIs to run,
        monitor, and terminate as many instances of this AMI as
        required. Currently, Amazon provides command line tools and Java
        libraries but you may also directly access the SOAP-based API.
      </p></li></ol></div><p>Please note while instances are running, you are billed for the
    computing and network resources that they consume. You should start
    creating an EC2 with KIWI after you can make sure your system is
    prepared for EC2 which means if you call the command
      <span class="command"><strong>ec2-describe-images</strong></span>
    <code class="option">-a</code> you will get a valid output. </p><div class="sect1" title="13.1. Building the suse-xen-guest Example for EC2"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.ec2.building"></a>13.1. Building the suse-xen-guest Example for EC2<span class="permalink"><a alt="Permalink" title="13.1. Building the suse-xen-guest Example for EC2" href="#sec.ec2.building">¶</a></span></h2></div></div></div><p>One example provided with KIWI is based on openSUSE 11.3 and
      includes the base pattern plus the vim editor. </p><p>Before you run KIWI you need to include some of your EC2
      account information into the image description
        <code class="filename">config.xml</code> file. The box below shows the
      values you need to adapt: </p><pre class="screen">&lt;ec2config&gt; ec2accountnr="12345678911"
   ec2privatekeyfile="Path to EC2 private key file" 
   ec2certfile="Path to EC2 public certificate file"
&lt;/ec2config&gt;</pre><p>After that call KIWI as follows: </p><pre class="screen"><span class="command"><strong>cd</strong></span> /usr/share/doc/packages/kiwi/examples 
<span class="command"><strong>cd</strong></span> suse-11.3
<span class="command"><strong>kiwi</strong></span> --prepare ./suse-xen-guest --add-profile \
  ec2Flavour --root /tmp/myec2</pre><pre class="screen"><span class="command"><strong>kiwi</strong></span> --create /tmp/myec2 --add-profile \ 
 ec2Flavour --type vmx -d /tmp/myec2-result</pre></div><div class="sect1" title="13.2. Using the Image"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.ec2.using"></a>13.2. Using the Image<span class="permalink"><a alt="Permalink" title="13.2. Using the Image" href="#sec.ec2.using">¶</a></span></h2></div></div></div><p> The generated image needs to be transfered over to Amazon
      which is done by the <span class="command"><strong>ec2-upload-bundle</strong></span> tool.
      You can do this by calling: </p><pre class="screen"><span class="command"><strong>ec2-upload-bundle</strong></span> -b myImages \
      -a <em class="replaceable"><code>AWS_Key_ID</code></em> -s <em class="replaceable"><code>AWS_secret_Key_ID</code></em> -m /tmp/myec2/ \
      suse-11.1-xen-guest.i686-1.1.2.ami.manifest.xml </pre><p>After this is done the image needs to be registered in order
      to receive a so called AMI id which starts with
        <span class="quote">&#8220;<span class="quote">ami-</span>&#8221;</span> followed by a random key sequence. To
      register call: </p><pre class="screen"><span class="command"><strong>ec2-register</strong></span> myImages/ suse-11.1-xen-guest.i686-1.1.2.ami.manifest.xml </pre><p>The result is the AMI id which you need to run an instance
      from your image. The command
        <span class="command"><strong>ec2-describe-images</strong></span> allows you to review your
      registered images. Since you will be running an instance of a
      public AMI, you will need to use a public/private keypair to
      ensure that only you will have access. One half of this keypair
      will be embedded into your instance, allowing you to login
      securely without a password using the other half of the keypair.
      Every keypair you generate requires a name. Be sure to choose a
      name that is easy to remember, perhaps one that describes the
      image&#8217;s content. For our example we&#8217;ll use the name gsg-keypair. </p><pre class="screen"><span class="command"><strong>ec2-add-keypair</strong></span> gsg-keypair </pre><p>The private key returned needs to be saved in a local file so
      that you can use it later. Using your favorite text editor, create
      a file named <code class="filename">id_rsa-gsg-keypair</code> and paste
      everything between (and including) the <code class="literal">-----BEGIN RSA
        PRIVATE KEY-----</code> and <code class="literal">-----END RSA PRIVATE
        KEY-----</code> lines into it. To review your keypairs call
        <span class="command"><strong>ec2-describe-keypairs</strong></span>. </p><p>We are almost done now but to be able to run an instance it&#8217;s
      required to select an appropriate AKI ID from the <a class="xref" href="#tab.ec2.kernel-image-ids" title="Table 13.1. Amazon Kernel Image IDs">Amazon Kernel Image IDs</a>  
      table below. For this host,
        <span class="emphasis"><em>aki-407d9529</em></span> is being chosen, because we
      are bundling an AMI representing a virtual disk with PVGrub. If
      the table below is outdated just check the current ID list at
      Amazon directly </p><div class="table"><a name="tab.ec2.kernel-image-ids"></a><p class="title"><b>Table 13.1. Amazon Kernel Image IDs</b><span class="permalink"><a alt="Permalink" title="Table 13.1. Amazon Kernel Image IDs" href="#tab.ec2.kernel-image-ids">¶</a></span></p><div class="table-contents"><table summary="Amazon Kernel Image IDs" border="1"><colgroup><col><col></colgroup><thead><tr><th>AKI</th><th>Name</th></tr></thead><tbody><tr><td>aki-407d9529</td><td><code class="filename">ec2-public-images/pv-grub-hd0-V1.01-i386.gz.manifest.xml</code></td></tr><tr><td>aki-427d952b</td><td><code class="filename">ec2-public-images/pv-grub-hd0-V1.01-x86_64.gz.manifest.xml</code></td></tr></tbody></table></div></div><br class="table-break"><p>Fire up your new ec2 instance with the following command: </p><pre class="screen"><span class="command"><strong>ec2-run-instances</strong></span> ami-... \
   --kernel aki-407d9529 \ 
   -k gsg-keypair </pre><p>To check the state of your instance(s) call the 
      command <span class="command"><strong>ec2-describe-instances</strong></span>.</p><p>If you see your instance at the status: <span class="emphasis"><em>running</em></span> you can login into it. If you can&#8217;t make
      sure you have allowed port 22 to be available </p><pre class="screen"><span class="command"><strong>ec2-authorize</strong></span> default -p 22 </pre><p>Congratulations ! You made it and can now use Amazons storage
      and computing power. </p></div></div><div class="chapter" title="Chapter 14. KIWI Testsuite"><div class="titlepage"><div><div><h2 class="title"><a name="chap.testing"></a>Chapter 14. KIWI Testsuite</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sec.testing.testsuite">14.1. Testsuite Packages</a></span></dt><dt><span class="sect1"><a href="#sec.testing.creating">14.2. Creating a Test</a></span></dt></dl></div><a class="indexterm" name="id2556980"></a><a class="indexterm" name="id2556992"></a><p>The KIWI test suite is useful to perform basic quality checks on
    the image root directory. The test cases are stored in
    subdirectories below <code class="filename">/usr/share/kiwi/tests</code>. To run the testsuite
    call KIWI as follows: </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   testsuite   <em class="replaceable"><code>image-root</code></em>  [  test <code class="option">name</code>    test <code class="option">name</code> ...]</p></div><p>If not test names are set the default tests rpm and ldd run. The
    name of a test corresponds with the name of the directory the test
    is implemented in. </p><div class="sect1" title="14.1. Testsuite Packages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.testing.testsuite"></a>14.1. Testsuite Packages<span class="permalink"><a alt="Permalink" title="14.1. Testsuite Packages" href="#sec.testing.testsuite">¶</a></span></h2></div></div></div><p> If a test requires special software to be installed but this
      software is not an essential part of the image itself it can be
      specified as testsuite packages in the system image
        <code class="filename">config.xml</code> as follows: </p><pre class="screen">&lt;packages type="testsuite"&gt; 
  &lt;package name="..."/&gt;
&lt;/packages&gt; </pre><p>The testsuite packages are installed when calling KIWI with
      the testsuite option and are removed after the tests has finished.
    </p></div><div class="sect1" title="14.2. Creating a Test"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.testing.creating"></a>14.2. Creating a Test<span class="permalink"><a alt="Permalink" title="14.2. Creating a Test" href="#sec.testing.creating">¶</a></span></h2></div></div></div><p> The test itself is defined by a XML description
        <code class="filename">test-case.xml</code> and its template definition
      file
        <code class="filename">/usr/share/kiwi/modules/KIWISchemaTest.rnc</code>
      The following example shows the basic structure of the
        <code class="sgmltag-element">rpm</code> test: </p><pre class="screen">&lt;test_case name="rpm" 
  summary="check rpm database and verify all rpms" 
  description="check if rpm db is present, run rpm&#8216;s build-in Verify method" </pre><pre class="screen">&lt;requirements&gt; 
  &lt;req type="directory"&gt;/var/lib/rpm&lt;/req&gt; 
  &lt;req type="file"&gt;/var/lib/rpm/__db.000&lt;/req&gt; 
  &lt;req type="file"&gt;/var/lib/rpm/Packages&lt;/req&gt;
&lt;/requirements&gt; </pre><pre class="screen">&lt;test type="binary" place="extern"&gt;
  &lt;file&gt;rpm.sh&lt;/file&gt;
  &lt;params&gt;CHROOT&lt;/params&gt; &lt;/test&gt;
&lt;/test_case&gt;</pre><p>There are basically two sections called
        <code class="sgmltag-element">equirements</code> and <code class="sgmltag-element">test</code>. In
      requirements you define what files/directories or packages has to
      be present in your image to run the test. For example if you need
      to check the RPM database, the database has to be present within
      the image. All requirements are checked, and if any of them fail
      the test won&#8217;t be executed and an error message is printed. There
      are three types of requirements: </p><div class="variablelist"><dl><dt><span class="term"><code class="sgmltag-element">file</code></span></dt><dd><p>Existence of a file</p></dd><dt><span class="term"><code class="sgmltag-element">directory</code></span></dt><dd><p>Existence of a directory </p></dd><dt><span class="term"><code class="sgmltag-element">rpm-package</code></span></dt><dd><p>Existence of a package </p></dd></dl></div><p>The test section defines the test script. It could be a
      binary, shell script or any other kind of executable. Scripts are
      expected to be in the same directory as where the XML definition
      for the test resides. There are two types of scripts, extern and
      intern. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>External scripts are executed outside of the image and are
          preferred. Their first parameter should be CHROOT. This
          parameter is changed to the real path of the image chroot
          directory. </p></li><li class="listitem"><p>Internal scripts are executed inside image using the
            <span class="command"><strong>chroot</strong></span> command. Files are copied into the
          image and deleted after execution. </p></li></ul></div><p>A test script always has to return 0 in case of a test to
      pass, or 1 if any error occur. All messages printed to standard
      and error output are stored and printed out of the test has
      failed. </p></div></div><div class="appendix" title="Appendix A. KIWI Man Pages"><div class="titlepage"><div><div><h2 class="title"><a name="appendix"></a>Appendix A. KIWI Man Pages</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwi">kiwi</a></span><span class="refpurpose"> &#8212; Creating Operating System Images</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.config.sh">kiwi::config.sh</a></span><span class="refpurpose"> &#8212; Configuration File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.images.sh">kiwi::images.sh</a></span><span class="refpurpose"> &#8212; Configuration File for KIWI image description</span></dt><dt><span class="refentrytitle"><a href="#ref.kiwi.kiwirc">kiwi::kiwirc</a></span><span class="refpurpose"> &#8212; Resource file for the Kiwi imaging system</span></dt></dl></div><p>The following pages will show you the man page of KIWI and the
    functions which can be used within <span class="command"><strong>config.sh</strong></span> and
      <span class="command"><strong>index.sh</strong></span>
  </p><div class="refentry" title="kiwi"><a name="ref.kiwi.kiwi"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi</span></h2><p>kiwi &#8212; Creating Operating System Images</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -l  |   --list }</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -o  |   --clone }  <em class="replaceable"><code>image-path</code></em>  { -d }  <em class="replaceable"><code>destination</code></em> </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -b  |   --build }  <em class="replaceable"><code>image-path</code></em>  { -d }  <em class="replaceable"><code>destination</code></em> </p></div></div><div class="refsect1" title="Basics"><a name="kiwi.image.basics"></a><h2>Basics</h2><p>
      KIWI is a complete imaging solution that is based on an image
      description. Such a description is represented by a directory
      which includes at least one <code class="filename">config.xml</code> file
      and may as well include other files like scripts or configuration
      data. The <span class="package">kiwi-templates</span> package provides example descriptions
      based on a JeOS system. JeOS means <span class="emphasis"><em>Just enough Operating System</em></span>.
      KIWI provides image templates based on that axiom which means a
      JeOS is a small, text only based image including a predefined
      remote source setup to allow installation of missing software
      components at a later point in time. 
    </p><p>
      Detailed description of the kiwi image system
      exists in the system design document in <a class="ulink" href="file:///usr/share/doc/packages/kiwi/kiwi.pdf" target="_top">file:///usr/share/doc/packages/kiwi/kiwi.pdf</a>. KIWI
      always operates in two steps. The KIWI <code class="option">--build</code> option just
      combines both steps into one to make it easier to start with KIWI.
      The first step is the preparation step and if that step was successful,
      a creation step follows which is able to create different image output
      types. If you have started with an example and want to add you own
      changes it might be a good idea to clone of from this example. This
      can be done by simply copying the entire image description or you can
      let KIWI do that for you by using the <span class="command"><strong>kiwi</strong></span> <code class="option">--clone</code> command.
    </p><p>
      In the preparation step,
      you prepare a directory including the contents of your new
      filesystem based on one or more software package source(s)
      The creation step is based on the result of the
      preparation step and uses the contents of the new image root tree to
      create the output image. If the image type ISO was requested, the
      output image would be a file with the suffix <code class="filename">.iso</code><a class="indexterm" name="id2557653"></a> representing a live system on
      CD or DVD. Other than that KIWI is able to create images for
      virtual and para-virtual (Xen) environments as well as for USB
      stick, PXE network clients and OEM customized Linux systems. 
    </p></div><div class="refsect1" title="Image Preparation and Creation"><a name="kiwi.image.prepcreate"></a><h2>Image Preparation and Creation</h2><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -p  |   --prepare }  <em class="replaceable"><code>image-path</code></em> <br> [ -r  |   --root <em class="replaceable"><code>image-root</code></em> |   --chache <em class="replaceable"><code>directory</code></em>]</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -c  |   --create }  <em class="replaceable"><code>image-root</code></em> <br> { -d  |   --destdir <em class="replaceable"><code>destination</code></em>} [--type <em class="replaceable"><code>image-type</code></em>]</p></div></div><div class="refsect1" title="Image Upgrade"><a name="kiwi.image.upgrade"></a><h2>Image Upgrade</h2><p>
      If the image root tree is stored and not removed, it can be
      used for upgrading the image according to the changes
      made in the repositories used for this image. If a distributor
      provides an update channel for package updates and an image
        <code class="filename">config.xml</code> includes this update channel as
      repository, it is useful to store the image root tree and upgrade
      the tree according to changes on the update channel. Given that the
      root tree exists it's also possible to add or remove software
      and recreate the image of the desired type.
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -u  |   --upgrade }  <em class="replaceable"><code>image-root</code></em>  [--add-package<em class="replaceable"><code>name</code></em>] [--add-pattern<em class="replaceable"><code>name</code></em>]</p></div></div><div class="refsect1" title="System to Image Migration"><a name="kiwi.image.system2image"></a><h2>System to Image Migration</h2><p>
      The migration module allows you to migrate your currently running
      system into an image description. The module will check for files
      not managed by a package manager and also inspects your system for
      package pattern and file consistency according to the currently active
      repositories. The system requires the zypper backend in order to
      work properly.
    </p><p>
      The migration process creates a cache file so that subsequent calls
      of the migration runs much faster. Please have in mind that if
      your system has changed (files created/deleted, etc.) the cache file
      might not be worth to become reused. In this case you should remove
      the cache first and start from scratch.
      The option <code class="option">--nofiles</code> will prevent the
      system from searching for unpackaged and packaged but modified files
      The option <code class="option">--notemplate</code> will prevent the creation of the image
      description files which are needed if you want to use KIWI to
      create a clone image from the result of the migration.
      With the options <code class="option">--exclude</code> and <code class="option">--skip</code> 
      you can tell the system to ignore
      specific directories and/or packages. This makes sense if you know
      before that some data is not worth to become migrated or can be
      restored easily later inside the cloned image like software
      repositories.
    </p><p>
      The migration process will always place it's result into the
      <code class="filename">/tmp/$OptionValueOf-m</code> directory. The reason for this is because
      <code class="filename">/tmp</code><a class="indexterm" name="id2557982"></a> is always excluded from the migration operation and therefore
      we can safely place new files there without influencing the
      migration itself. You should have at least 50 MB free space for
      the cache file and the image description all the rest are just
      hard links.
    </p><p>
      As one result a HTML based report file is created which
      contains important information about the system. You are free to
      ignore that information but with the risk that the migrated image
      does not represent the same system which is running at the moment. 
      The less issues left in the report the better is the result.
      In most cases a manual fine tuning is required. This includes
      the repository selection and the unmanaged files along with the
      configuration details of your currently running operating system.
      You should understand the module as a helper to migrate running
      servers into images. The implementation is still under
      construction so expect better migration results 
      in future releases :)
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -m  |   --migrate }  <em class="replaceable"><code>name</code></em>  [--exclude <em class="replaceable"><code>directory</code></em>...] [--skip <em class="replaceable"><code>package</code></em>...] [--nofiles] [--notemplate]</p></div></div><div class="refsect1" title="Image Postprocessing Modes"><a name="kiwi.image.postproc"></a><h2>Image Postprocessing Modes</h2><p>
      The KIWI post-processing modes are used for special image deployment
      tasks, like installing the image on a USB stick. So to say they are the
      third step after preparation and creation. KIWI calls the postprocessing
      modules automatically according to the specified output image type and
      attributes but it's also possible to call them manually.
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --bootstick <em class="replaceable"><code>initrd</code></em>  [--bootstick-system <em class="replaceable"><code>systemImage</code></em>] [--bootstick-device <em class="replaceable"><code>device</code></em>]</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --bootvm <em class="replaceable"><code>initrd</code></em>   --bootvm-system <em class="replaceable"><code>systemImage</code></em>  [--bootvm-disksize <em class="replaceable"><code>size</code></em>]</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --bootcd <em class="replaceable"><code>initrd</code></em> </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --installcd <em class="replaceable"><code>initrd</code></em>   --installcd-system <em class="replaceable"><code>vmx-system-image</code></em> </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --installstick <em class="replaceable"><code>initrd</code></em>   --installstick-system <em class="replaceable"><code>vmx-system-image</code></em> </p></div></div><div class="refsect1" title="Image format conversion"><a name="id2558258"></a><h2>Image format conversion</h2><p>
      The KIWI format conversion is useful to perform the creation of
	  another image output format like vmdk for VMware or ovf the open
      virtual machine format. Along with the conversion KIWI also creates
      the virtual machine configuration according to the format if
      there is a machine section specified in the XML description
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --convert <em class="replaceable"><code>systemImage</code></em>  [--format <em class="replaceable"><code>vmdk|ovf|qcow2</code></em>]</p></div></div><div class="refsect1" title="Testsuite"><a name="id2558302"></a><h2>Testsuite</h2><p>
      The KIWI test suite is useful to perform basic quality checks on
      the image root directory. The test cases are stored in subdirectories
      below <code class="filename">/usr/share/kiwi/tests</code>.
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --testsuite <em class="replaceable"><code>image-root</code></em>  [--test <em class="replaceable"><code>name</code></em>...]</p></div></div><div class="refsect1" title="Helper Tools"><a name="id2558347"></a><h2>Helper Tools</h2><p>
      The helper tools provide optional functions like
      creating a crypted password string for the users section of the
      <code class="filename">config.xml</code> file or signing the image
      description with an md5sum hash as well as adding splash data to
      the boot image used by the bootloader and the testsuite mode which
      allows testing the integrity of the new root tree.
    </p><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --createpassword </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --createhash
      <em class="replaceable"><code>image-path</code></em> </p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>  { -i  |   --info }  <em class="replaceable"><code>ImagePath</code></em>  {--select
      <em class="replaceable"><code>
		repo-patterns|patterns|types|sources|size|profiles|packages
	  </code></em>}</p></div><div class="cmdsynopsis"><p><code class="command">kiwi</code>   --setup-splash <em class="replaceable"><code>initrd</code></em> </p></div><p>
	The following list describes the helper tools more detailed
	</p><div class="variablelist"><dl><dt><span class="term">[<span class="optional"><code class="option">--createpassword</code></span>]</span></dt><dd><p>
			Create a crypted password hash and prints it on the console.
			The user can use the string as value for the pwd attribute in
			the XML users section
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--createhash <em class="replaceable"><code>image-path</code></em></code>
		</span>]</span></dt><dd><p>
			Sign your image description with a md5sum. The result is written to a file
			named <code class="filename">.checksum.md</code> and is checked if KIWI creates
			an image from this description.
		</p></dd><dt><span class="term">[<span class="optional">
			<code class="option">-i</code> | <code class="option">--info <em class="replaceable"><code>image-path</code></em></code>
			<code class="option">--select <em class="replaceable"><code>selection</code></em></code>
		</span>]</span></dt><dd><p>
			List general information about the image description. So far you can get
			information about the available patterns in the configured repositories with
			<em class="replaceable"><code>repo-patterns</code></em>, a list of used patterns for this image
			with <em class="replaceable"><code>patterns</code></em>, a list of supported image types
			with <em class="replaceable"><code>types</code></em>, a list of source URL's with
			<em class="replaceable"><code>sources</code></em>, an estimation about the install size and
			the size of the packages marked as to be deleted with <em class="replaceable"><code>size</code></em>,
			a list of profiles with <em class="replaceable"><code>profiles</code></em>, and a list of solved packages to become installed with <em class="replaceable"><code>packages</code></em>.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--setup-splash <em class="replaceable"><code>initrd</code></em></code>
		</span>]</span></dt><dd><p>
			Create splash screen from the data inside the initrd
			and re-create the initrd with the splash screen attached
			to the initrd cpio archive. This enables the kernel
			to load the splash screen at boot time. If splashy is used
			only a link to the original initrd will be created
		</p></dd></dl></div></div><div class="refsect1" title="Global Options"><a name="kiwi..global.options"></a><h2>Global Options</h2><div class="variablelist"><dl><dt><span class="term">[<span class="optional"><code class="option">--base-root</code>
			<em class="replaceable"><code>base-path</code></em></span>]</span></dt><dd><p>
			Refers to an already prepared root tree. KIWI will use
			this tree to skip the first stage of the prepare step and
			run the second stage directly.</p></dd><dt><span class="term">[<span class="optional"><code class="option">--base-root-mode</code>
			<em class="replaceable"><code>copy|union|recycle</code></em></span>]</span></dt><dd><p>
			Specifies the overlay mode for the base root tree.
			This can be either a copy of the tree, a union mount or
			the tree itself. The last mode (recycle) will modify the
			base root tree which might make it obsolete as base root
			for other kiwi calls
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--add-profile</code>
			<em class="replaceable"><code>profile-name</code></em></span>]</span></dt><dd><p>
			Use the specified profile. A profile is a part of the
			XML image description and therefore can enhance each section
			with additional information. For example adding packages.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repo</code>
			<em class="replaceable"><code>URL</code></em></span>]</span></dt><dd><p>
			Set/Overwrite repo URL for the first listed repo.
			The change is temporary and will not be written to the
			XML file.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repotype</code>
			<em class="replaceable"><code>type</code></em></span>]</span></dt><dd><p>
			Set/Overwrite repo type for the first listed repo.
			The supported repo types depends on the packagemanager.
			Commonly supported are rpm-md, rpm-dir and yast2.
			The change is temporary and will not be written to the
			XML file.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repoalias</code>
			<em class="replaceable"><code>name</code></em></span>]</span></dt><dd><p>
			Set/Overwrite alias name for the first listed repo.
			Alias names are optional free form text. If not set the source
			attribute value is used and builds the alias name by replacing
			each <span class="quote">&#8220;<span class="quote">/</span>&#8221;</span> with a <span class="quote">&#8220;<span class="quote">_</span>&#8221;</span>. An alias name should be set if the
			source argument doesn't really explain what this repository
			contains. The change is temporary and will not be written to the
			XML file.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--set-repoprio</code>
			<em class="replaceable"><code>number</code></em></span>]</span></dt><dd><p>
			Set/Overwrite priority for the first listed repo.
			Works with the smart packagemanager only. The Channel
			priority assigned to all packages available in
			this channel (0 if not set). If the exact same package
			is available in more than one channel, the highest
			priority is used.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--add-repo
			<em class="replaceable"><code>URL</code></em></code>,
			<code class="option">--add-repotype <em class="replaceable"><code>type</code></em></code>
			<code class="option">--add-repoalias <em class="replaceable"><code>name</code></em></code>
			<code class="option">--add-repoprio <em class="replaceable"><code>number</code></em></code>
		</span>]</span></dt><dd><p>
			Add the given repository and type for this run of an
			image prepare or upgrade process. Multiple
            <code class="option">--add-repo</code>/<code class="option">--add-repotype</code>
			options are possible. The change will not be written to the
			<code class="filename">config.xml</code> file</p></dd><dt><span class="term">[<span class="optional"><code class="option">--ignore-repos</code></span>]</span></dt><dd><p>
			Ignore all repositories specified so far, in XML or
			elsewhere. This option should be used in conjunction with
			subsequent calls to <code class="option">--add-repo</code> to specify
			repositories at the commandline that override previous
			specifications.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--logfile <em class="replaceable"><code>Filename</code></em></code>
			| <code class="option">terminal</code></span>]</span></dt><dd><p>
			Write to the log file
			<em class="replaceable"><code>Filename</code></em> instead of the terminal.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--gzip-cmd <em class="replaceable"><code>cmd</code></em></code></span>]</span></dt><dd><p>
			Specify an alternate command to run when compressing
			boot and system images. Command must accept
			<span class="command"><strong>gzip</strong></span> options.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--log-port <em class="replaceable"><code>PortNumber</code></em></code></span>]</span></dt><dd><p>
			Set the log server port. By default port 9000 is used. If
			multiple KIWI processes runs on one system it's recommended
			to set the logging port per process.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--package-manager <em class="replaceable"><code>smart|zypper</code></em></code>
		</span>]</span></dt><dd><p>
			Set the package manager to use for this image. If set it
			will temporarly overwrite the value set in the xml
			description.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">-A</code> | <code class="option">--target-arch <em class="replaceable"><code>i586|x86_64|armv5tel|ppc</code></em></code>
		</span>]</span></dt><dd><p>
			Set a special target-architecture. This overrides the 
			used architecture for the image-packages in <code class="filename">zypp.conf</code>.
			When used with smart this option doesn't have any effect.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--debug</code></span>]</span></dt><dd><p>
			Prints a stack trace in case of internal errors
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--verbose <em class="replaceable"><code>1|2|3</code></em></code>
		</span>]</span></dt><dd><p>
			Controls the verbosity level for the instsource module
		</p></dd></dl></div></div><div class="refsect1" title="Image Preparation Options"><a name="kiwi.prepare.options"></a><h2>Image Preparation Options</h2><div class="variablelist"><dl><dt><span class="term">[<span class="optional"><code class="option">-r</code> | <code class="option">--root
			<em class="replaceable"><code>RootPath</code></em></code></span>]</span></dt><dd><p>
			Set up the physical extend, chroot system below the given
			root-path path. If no <code class="option">--root</code> option is
			given, KIWI will search for the attribute defaultroot in
			<code class="filename">config.xml</code>. If no root directory is
			known, a <span class="command"><strong>mktmp</strong></span> directory will be created
			and used as root directory.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--force-new-root</code></span>]</span></dt><dd><p>
			Force creation of new root directory. If the directory
			already exists, it is deleted.
		</p></dd></dl></div></div><div class="refsect1" title="Image Upgrade/Preparation Options"><a name="kiwi.prepare.upgrade.options"></a><h2>Image Upgrade/Preparation Options</h2><div class="variablelist"><dl><dt><span class="term">[<span class="optional"><code class="option">--cache</code> <em class="replaceable"><code>directory</code></em>
        </span>]</span></dt><dd><p>
            When specifying a cache directory KIWI will create a cache each for
			patterns and packages and re-use them if possible for subsequent
            root tree preparations of this and/or other images 
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--add-package</code> <em class="replaceable"><code>package</code></em>
		</span>]</span></dt><dd><p>
			Add the given package name to the list of image packages
			multiple <code class="option">--add-package</code> options are possible. The change
			will not be written to the XML description.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--add-pattern</code> <em class="replaceable"><code>name</code></em>
        </span>]</span></dt><dd><p>
            Add the given pattern name to the list of image packages
            multiple <code class="option">--add-pattern</code> options are possible. The change
            will not be written to the xml description. Patterns can be handled
            by SUSE based repositories only.
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--del-package</code> <em class="replaceable"><code>package</code></em>
		</span>]</span></dt><dd><p>
			Removes the given package by adding it the list of packages
			to become removed. The change will not be written to the xml
			description.
		</p></dd></dl></div></div><div class="refsect1" title="Image Creation Options"><a name="kiwi.create.options"></a><h2>Image Creation Options</h2><div class="variablelist"><dl><dt><span class="term">[<span class="optional"><code class="option">-d</code> | <code class="option">--destdir
			<em class="replaceable"><code>DestinationPath</code></em></code></span>]</span></dt><dd><p>
			Specify destination directory to store the image file(s)
			If not specified, KIWI will try to find the attribute 
			<em class="replaceable"><code>defaultdestination</code></em> which can be
			specified in the <em class="replaceable"><code>preferences</code></em> section
			of the <code class="filename">config.xml</code> file. If it exists its value is used as
			destination directory. If no destination information can be found,
			an error occurs.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">-t</code> | <code class="option">--type
			<em class="replaceable"><code>Imagetype</code></em></code></span>]</span></dt><dd><p>
			Specify the output image type to use for this image. Each type
            is described in a <em class="replaceable"><code>type</code></em> section of the
            preferences section. At least one type has to be specified in the
            <code class="filename">config.xml</code> description. By default,
            the types specifying the <span class="emphasis"><em>primary</em></span> attribute will be
            used. If there is no primary attribute set, the first type
            section of the preferences section is the primary type.
            The types are only evaluated when KIWI runs the
            <code class="option">--create</code> step. With the
            option <code class="option">--type</code> one can distinguish between the
            types stored in <code class="filename">config.xml</code>
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">-s</code> | <code class="option">--strip</code></span>]</span></dt><dd><p>
			Strip shared objects and executables only make sense in
			combination with <code class="option">--create</code>
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--prebuiltbootimage
			<em class="replaceable"><code>Directory</code></em></code></span>]</span></dt><dd><p>
			Search in <em class="replaceable"><code>Directory</code></em> for
			pre-built boot images.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--isocheck</code></span>]</span></dt><dd><p>
			in case of an iso image the checkmedia program generates
			a md5sum into the ISO header. If the <code class="option">--isocheck</code> option is
			specified a new boot menu entry will be generated which
			allows to check this media
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--lvm</code></span>]</span></dt><dd><p>
			Use the logical volume manager to control the disk.
			The partition table will include one lvm partition and
			one standard ext2 boot partition. Use of this option
			makes sense for the create step only and also only for
			the image types: vmx, oem, and usb
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-blocksize <em class="replaceable"><code>number</code></em></code>
		</span>]</span></dt><dd><p>
			When calling KIWI in creation mode this option will set
			the block size in bytes. For ISO images with the old style
			ramdisk setup a blocksize of 4096 bytes is required
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-journalsize <em class="replaceable"><code>number</code></em></code>
		</span>]</span></dt><dd><p>
			When calling KIWI in creation mode this option will set
			the journal size in mega bytes for ext[23] based filesystems
			and in blocks if the reiser filesystem is used
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-inodesize <em class="replaceable"><code>number</code></em></code>
		</span>]</span></dt><dd><p>
			When calling KIWI in creation mode this option will set
			the inode size in bytes. This option has no effect if the
			reiser filesystem is used
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-inoderatio <em class="replaceable"><code>number</code></em></code>
        </span>]</span></dt><dd><p>
            Set the bytes/inode ratio. This option has no
            effect if the reiser filesystem is used
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-max-mount-count <em class="replaceable"><code>number</code></em></code>
		</span>]</span></dt><dd><p>
			When calling kiwi in creation mode this option will set the number
			of mounts after which the filesystem will be checked. Set to 0 to
			disable checks.
			This option applies only to ext[234] filesystems.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--fs-check-interval <em class="replaceable"><code>number</code></em></code>
		</span>]</span></dt><dd><p>
			When calling kiwi in creation mode this option will set the maximal time
			between two filesystem checks. Set to 0 to disable time-dependent checks.
			This option applies only to ext[234] filesystems.
		</p></dd><dt><span class="term">[<span class="optional"><code class="option">--partitioner <em class="replaceable"><code>fdisk|parted</code></em></code>
        </span>]</span></dt><dd><p>
			Select the tool to create partition tables. Supported are
			fdisk (sfdisk) and parted. By default fdisk is used
        </p></dd><dt><span class="term">[<span class="optional"><code class="option">--check-kernel</code></span>]</span></dt><dd><p>
			Activates check for matching kernels between boot and
			system image. The kernel check also tries to fix the boot
			image if no matching kernel was found.
        </p></dd></dl></div></div><div class="refsect1" title="For More Information"><a name="kiwi.moreinfo"></a><h2>For More Information</h2><p>More information about KIWI, its files can be found at:</p><div class="variablelist"><dl><dt><span class="term"><a class="ulink" href="http://en.opensuse.org/Portal:KIWI" target="_top">http://en.opensuse.org/Portal:KIWI</a></span></dt><dd><p>KIWI wiki</p></dd><dt><span class="term"><code class="filename">config.xml</code></span></dt><dd><p>The configuration XML file that contains every
            aspect for the image creation.</p></dd><dt><span class="term"><a class="ulink" href="file:///usr/share/doc/packages/kiwi/kiwi.pdf" target="_top">file:///usr/share/doc/packages/kiwi/kiwi.pdf</a></span></dt><dd><p>The system design document which describes some details
            about the building process.</p></dd><dt><span class="term"><a class="ulink" href="file:///usr/share/doc/packages/kiwi/schema/kiwi.xsd.html" target="_top">file:///usr/share/doc/packages/kiwi/schema/kiwi.xsd.html</a></span></dt><dd><p>The KIWI RELAX NG XML Schema documentation.
          </p></dd><dt><span class="term"><a class="ulink" href="file:///usr/share/doc/packages/kiwi/schema/test.xsd.html" target="_top">file:///usr/share/doc/packages/kiwi/schema/test.xsd.html</a></span></dt><dd><p>The KIWI RELAX NG XML Schema documentation.
          </p></dd></dl></div></div></div><div class="refentry" title="kiwi::config.sh"><div class="refentry.separator"><hr></div><a name="ref.kiwi.config.sh"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi::config.sh</span></h2><p>KIWI::config.sh &#8212; Configuration File for KIWI image description</p></div><div class="refsect1" title="Description"><a name="kiwi.config.description"></a><h2>Description</h2><p>
      The KIWI image description allows to have an optional <code class="filename">config.sh</code> script
      in place. This script should be designed to take over control of adding
      the image operating system configuration. Configuration in that sense
      means stuff like activating services, creating configuration files, prepare
      an environment for a firstboot workflow, etc. What you shouldn't do in
      <code class="filename">config.sh</code> is breaking your systems integrity by for example removing
      packages or pieces of software. Something like that can be done in <code class="filename">images.sh</code>.
      The <code class="filename">config.sh</code> script is called <span class="emphasis"><em>after</em></span> the user and groups have
      been set up. If there are SUSE Linux related YaST XML information, these are
      validated before <code class="filename">config.sh</code> is called too. If you exit config.sh with an
      exit code != 0 kiwi will exit with an error too.
    </p><div class="example"><a name="id2559783"></a><p class="title"><b>Example A.1. Template for config.sh</b></p><div class="example-contents"><pre class="programlisting">
#======================================
# Functions...
#--------------------------------------
test -f /.kconfig &amp;&amp; . /.kconfig
test -f /.profile &amp;&amp; . /.profile

#======================================
# Greeting...
#--------------------------------------
echo "Configure image: [$kiwi_iname]..."

#======================================
# Call configuration code/functions
#--------------------------------------
...

#======================================
# Exit safely
#--------------------------------------
exit</pre></div></div><br class="example-break"></div><div class="refsect1" title="Common functions"><a name="kiwi.config.functions"></a><h2>Common functions</h2><p>
      The <code class="filename">.kconfig</code> file allows to make use of a common set of functions. Those which
      are SUSE Linux specific starts with the name <span class="emphasis"><em>suse</em></span>. Those which
      are common to all linux systems starts with the name <span class="emphasis"><em>base</em></span>.
      The following list describes which functions are available for <code class="filename">config.sh</code>
    </p><div class="variablelist"><dl><dt><span class="term">[<span class="optional">baseCleanMount</span>]</span></dt><dd><p>
            Umount the system filesystems <code class="filename">/proc</code>, 
            <code class="filename">/dev/pts</code>, and
            <code class="filename">/sys</code>.
          </p></dd><dt><span class="term">[<span class="optional">baseDisableCtrlAltDel</span>]</span></dt><dd><p>
            Disable the <span class="keycap"><strong>Ctrl</strong></span>-<span class="keycap"><strong>Alt</strong></span>-<span class="keycap"><strong>Del</strong></span> key sequence setting in <code class="filename">/etc/inittab</code>
          </p></dd><dt><span class="term">[<span class="optional">baseGetPackagesForDeletion</span>]</span></dt><dd><p>
            Return the name(s) of packages which will be deleted
          </p></dd><dt><span class="term">[<span class="optional">baseGetProfilesUsed</span>]</span></dt><dd><p>
            Return the name(s) of profiles used to build this image
          </p></dd><dt><span class="term">[<span class="optional">baseSetRunlevel {value}</span>]</span></dt><dd><p>
             Set the default run level
          </p></dd><dt><span class="term">[<span class="optional">baseSetupBoot</span>]</span></dt><dd><p>
             Set up the linuxrc as init
          </p></dd><dt><span class="term">[<span class="optional">baseSetupBusyBox {-f}</span>]</span></dt><dd><p>
             activates busybox if installed for all links from
             the <code class="filename">busybox/busybox.links</code> file&#8212;you can 
             choose custom apps to be forced into busybox with the 
            <code class="option">-f</code> option as first parameter, for example: 
          </p><pre class="screen">baseSetupBusyBox -f /bin/zcat /bin/vi</pre></dd><dt><span class="term">[<span class="optional">baseSetupInPlaceGITRepository</span>]</span></dt><dd><p>
            Create an in place git repository of the root
            directory. This process may take some time and you
            may expect problems with binary data handling
          </p></dd><dt><span class="term">[<span class="optional">baseSetupInPlaceSVNRepository {path_list}</span>]</span></dt><dd><p>
            Create an in place subversion repository for the
            specified directories. A standard call could look like this
            baseSetupInPlaceSVNRepository <code class="filename">/etc</code>,
            <code class="filename">/srv</code>, and <code class="filename">/var/log</code> 
          </p></dd><dt><span class="term">[<span class="optional">baseSetupPlainTextGITRepository</span>]</span></dt><dd><p>
            Create an in place git repository of the root
            directory containing all plain/text files.
          </p></dd><dt><span class="term">[<span class="optional">baseSetupUserPermissions</span>]</span></dt><dd><p>
            Search all home directories of all users listed in <code class="filename">/etc/passwd</code>
            and change the ownership of all files to belong to the correct
            user and group.
          </p></dd><dt><span class="term">[<span class="optional">baseStripAndKeep {list of info-files to keep}</span>]</span></dt><dd><p>
              helper function for strip* functions
              read stdin lines of files to check for removing
              params: files which should be keep
          </p></dd><dt><span class="term">[<span class="optional">baseStripDocs {list of docu names to keep}</span>]</span></dt><dd><p>
             remove all documentation, except one given as parameter
          </p></dd><dt><span class="term">[<span class="optional">baseStripInfos {list of info-files to keep}</span>]</span></dt><dd><p>
             remove all info files, except one given as parameter
          </p></dd><dt><span class="term">[<span class="optional">baseStripLocales {list of locales}</span>]</span></dt><dd><p>
             remove all locales, except one given as parameter
          </p></dd><dt><span class="term">[<span class="optional">baseStripMans {list of manpages to keep}</span>]</span></dt><dd><p>
             remove all manual pages, except one given as parameter
             example: baseStripMans more less
          </p></dd><dt><span class="term">[<span class="optional">baseStripRPM</span>]</span></dt><dd><p>
             remove rpms defined in <code class="filename">config.xml</code> under image=delete section
          </p></dd><dt><span class="term">[<span class="optional">baseStripTools {list of toolpath} {list of tools}</span>]</span></dt><dd><p>
              helper function for suseStripInitrd function
              params: toolpath, tools
          </p></dd><dt><span class="term">[<span class="optional">baseStripUnusedLibs</span>]</span></dt><dd><p>
             remove libraries which are not directly linked
             against applications in the bin directories
          </p></dd><dt><span class="term">[<span class="optional">baseUpdateSysConfig {filename} {variable} {value}</span>]</span></dt><dd><p>
             update sysconfig variable contents
          </p></dd><dt><span class="term">[<span class="optional">Debug {message}</span>]</span></dt><dd><p>
            Helper function to print a message 
            if the variable <code class="varname">DEBUG</code> is set to 1
          </p></dd><dt><span class="term">[<span class="optional">Echo {echo commandline}</span>]</span></dt><dd><p>
            Helper function to print a message to the controling terminal
          </p></dd><dt><span class="term">[<span class="optional">Rm {list of files}</span>]</span></dt><dd><p>
            Helper function to delete files and anounce it to log
          </p></dd><dt><span class="term">[<span class="optional">Rpm {rpm commandline}</span>]</span></dt><dd><p>
            Helper function to the RPM function and anounce it to log
          </p></dd><dt><span class="term">[<span class="optional">suseActivateDefaultServices</span>]</span></dt><dd><p>
            Call all postin scriptlets which among other things activates
            all required default services using suseInsertService
          </p></dd><dt><span class="term">[<span class="optional">suseActivateServices</span>]</span></dt><dd><p>
            Check all services in <code class="filename">/etc/init.d/</code><a class="indexterm" name="id2560363"></a> and activate them
            by calling suseInsertService
          </p></dd><dt><span class="term">[<span class="optional">suseCloneRunlevel {runlevel}</span>]</span></dt><dd><p>
            Clone the given runlevel to work in the same way
            as the default runlevel 3.
          </p></dd><dt><span class="term">[<span class="optional">suseConfig</span>]</span></dt><dd><p>
            Setup keytable language and timezone if specified in <code class="filename">config.xml</code> and
            call SuSEconfig afterwards
          </p></dd><dt><span class="term">[<span class="optional">suseInsertService {servicename}</span>]</span></dt><dd><p>
            Recursively insert a service. If there is a service
            required for this service it will be inserted first. The suse
            insserv program is used here
          </p></dd><dt><span class="term">[<span class="optional">suseRemoveService {servicename}</span>]</span></dt><dd><p>
            Remove a service and its dependant services
            using the suse insserv program
          </p></dd><dt><span class="term">[<span class="optional">suseService {servicename} {on|off}</span>]</span></dt><dd><p>
            Activate/Deactivate a service by using the chkconfig program
            The function requires the service name and the value on or off
            as parameters
          </p></dd><dt><span class="term">[<span class="optional">suseServiceDefaultOn</span>]</span></dt><dd><p>
            Activates the following services to be on by default using the
            chkconfig program: boot.rootfsck boot.cleanup boot.localfs boot.localnet
            boot.clock policykitd dbus consolekt haldaemon network atd syslog cron kbd
          </p></dd><dt><span class="term">[<span class="optional">suseSetupProductInformation</span>]</span></dt><dd><p>
            This function will use zypper to search for the installed
            product and install all product specific packages. This function
            only makes sense if zypper is used as packagemanager
          </p></dd><dt><span class="term">[<span class="optional">suseStripPackager {-a}</span>]</span></dt><dd><p>
             Remove smart o zypper packages and db files
             Also remove rpm package and db if <code class="option">-a</code> given
          </p></dd></dl></div></div><div class="refsect1" title="Profile environment variables"><a name="kiwi.config.environment"></a><h2>Profile environment variables</h2><p>
      The .profile environment file contains a specific set of variables which
      are listed below. Some of the functions above makes use of the variables.
	</p><div class="variablelist"><dl><dt><span class="term">[<span class="optional">$kiwi_compressed</span>]</span></dt><dd><p>
			The value of the compressed attribute set in the type element
			in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_delete</span>]</span></dt><dd><p>
            A list of all packages which are part of the packages section
            with <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2560576"></a>="<code class="sgmltag-attvalue">delete</code>" in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_drivers</span>]</span></dt><dd><p>
            A comma seperated list of the driver entries as listed in the
            drivers section of the <code class="filename">config.xml</code>. Similar variables exists for
            the <code class="sgmltag-element">usbdrivers</code> and <code class="sgmltag-element">scsidrivers</code> sections
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_iname</span>]</span></dt><dd><p>
            The name of the image as listed in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_iversion</span>]</span></dt><dd><p>
            The image version string major.minor.release
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_keytable</span>]</span></dt><dd><p>
            The contents of the keytable setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_language</span>]</span></dt><dd><p>
            The contents of the locale setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_profiles</span>]</span></dt><dd><p>
            A list of profiles used to build this image
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_size</span>]</span></dt><dd><p>
            The predefined size value for this image. This is not the computed
            size but only the optional size value of the preferences section
            in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_timezone</span>]</span></dt><dd><p>
            The contents of the timezone setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_type</span>]</span></dt><dd><p>
            The basic image type. Can be a simply filesystem image type of
            ext2, ext3, reiserfs, squashfs, cpio, or one of the following complex
            image types: iso, split, usb, vmx, oem, xen, or pxe.
          </p></dd></dl></div></div></div><div class="refentry" title="kiwi::images.sh"><div class="refentry.separator"><hr></div><a name="ref.kiwi.images.sh"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi::images.sh</span></h2><p>KIWI::images.sh &#8212; Configuration File for KIWI image description</p></div><div class="refsect1" title="Description"><a name="kiwi.images.description"></a><h2>Description</h2><p>
      The KIWI image description allows to have an optional <code class="filename">images.sh</code> script
      in place. This script is called at the beginning of the KIWI create step.
      It is allowed to remove software there to shrink down the size of the
      image. Most often <code class="filename">images.sh</code> is used for boot images because they needs
      to be small. As <code class="filename">images.sh</code> is called in the create step you should be
      aware to design the script in a way that it can be called multiple times
      without shooting itself into its knee. As KIWI allows to create different
      image types from one previosly prepared tree one needs to take into account
      that <code class="filename">images.sh</code> can be called more than one time. If you exit <code class="filename">images.sh</code>
      with an exit code != 0 KIWI will exit with an error too.
    </p><div class="example"><a name="id2560912"></a><p class="title"><b>Example A.2. Template for images.sh</b></p><div class="example-contents"><pre class="programlisting">#======================================
# Functions...
#--------------------------------------
test -f /.kconfig &amp;&amp; . /.kconfig
test -f /.profile &amp;&amp; . /.profile

#======================================
# Greeting...
#--------------------------------------
echo "Configure image: [$kiwi_iname]..."

#======================================
# Call configuration code/functions
#--------------------------------------
...

#======================================
# Exit safely
#--------------------------------------
exit</pre></div></div><br class="example-break"></div><div class="refsect1" title="Common functions"><a name="kiwi.image.functions"></a><h2>Common functions</h2><p>
      The <code class="filename">.kconfig</code> file allows to make use of a common set of functions. Those which
      are SUSE Linux specific starts with the name <span class="emphasis"><em>suse</em></span>. Those which
      are common to all linux systems starts with the name <span class="emphasis"><em>base</em></span>.
      The following list describes which functions are available for
      <code class="filename">images.sh</code>.
    </p><div class="variablelist"><dl><dt><span class="term">[<span class="optional">baseCleanMount</span>]</span></dt><dd><p>
            Umount the system filesystems <code class="filename">/proc</code>, 
            <code class="filename">/dev/pts</code>, and
            <code class="filename">/sys</code>.
          </p></dd><dt><span class="term">[<span class="optional">baseGetProfilesUsed</span>]</span></dt><dd><p>
            Return the name(s) of profiles used to build this image.
          </p></dd><dt><span class="term">[<span class="optional">baseGetPackagesForDeletion</span>]</span></dt><dd><p>
            Return the list of packages setup in the packages <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2561040"></a>="<code class="sgmltag-attvalue">delete</code>"
            section of the <code class="filename">config.xml</code> used to build
            this image.
          </p></dd><dt><span class="term">[<span class="optional">baseSetupOEMPartition</span>]</span></dt><dd><p>
             Writes the file <code class="filename">/config.oempartition</code> depending on the following
             <code class="filename">config.xml</code> parameters: oem-reboot, oem-swapsize, oem-systemsize,
			 oem-home,oem-swap,oem-boot-title,oem-recovery, oem-kiwi-initrd.
			 kiwi takes the information from <code class="filename">config.xml</code> and creates the
			 config.oempartition file as part of the automatically created
             boot image (initrd). The information must be available as part
             of the boot image because it controls the OEM repartition
             workflow on first boot of an OEM image. Detailed information
             about the meaning of each option can be found in the OEM
             chapter of the KIWI cookbook.
          </p></dd><dt><span class="term">[<span class="optional">suseGFXBoot {theme} {loadertyp}</span>]</span></dt><dd><p>
            This function requires the gfxboot and at least one bootsplash-theme-*
            package to be installed in order to work correctly. The function
            creates from this package data a graphics boot screen for the isolinux
            and grub boot loaders. Additionally it creates the bootsplash files
            for the resolutions 800x600, 1024x768, and 1280x1024
          </p></dd><dt><span class="term">[<span class="optional">suseStripKernel</span>]</span></dt><dd><p>
            This function removes all kernel drivers which are not listed in
            the *drivers sections of the <code class="filename">config.xml</code>
            file.
          </p></dd><dt><span class="term">[<span class="optional">suseStripInitrd</span>]</span></dt><dd><p>
            This function removes a whole bunch of tools binaries and libraries which
            are not required in order to boot a suse system with KIWI.
          </p></dd><dt><span class="term">[<span class="optional">Rm {list of files}</span>]</span></dt><dd><p>
            Helper function to delete files and anounce it to log.
          </p></dd><dt><span class="term">[<span class="optional">Rpm {rpm commandline}</span>]</span></dt><dd><p>
            Helper function to the rpm function and anounce it to log.
          </p></dd><dt><span class="term">[<span class="optional">Echo {echo commandline}</span>]</span></dt><dd><p>
            Helper function to print a message to the controling
            terminal.
          </p></dd><dt><span class="term">[<span class="optional">Debug {message}</span>]</span></dt><dd><p>
            Helper function to print a message 
            if the variable <code class="varname">DEBUG</code> is set to 1.
          </p></dd></dl></div></div><div class="refsect1" title="Profile environment variables"><a name="kiwi.images.environment"></a><h2>Profile environment variables</h2><p>
      The .profile environment file contains a specific set of variables which
      are listed below. Some of the functions above makes use of the variables.
	</p><div class="variablelist"><dl><dt><span class="term">[<span class="optional">$kiwi_iname</span>]</span></dt><dd><p>
            The name of the image as listed in config.xml
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_iversion</span>]</span></dt><dd><p>
            The image version string major.minor.release
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_keytablee</span>]</span></dt><dd><p>
            The contents of the keytable setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_language</span>]</span></dt><dd><p>
            The contents of the locale setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_timezone</span>]</span></dt><dd><p>
            The contents of the timezone setup as done in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_delete</span>]</span></dt><dd><p>
            A list of all packages which are part of the packages section
            with <code class="sgmltag-attribute">type</code><a class="indexterm" name="id2561354"></a>="<code class="sgmltag-attvalue">delete</code>" in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_profiles</span>]</span></dt><dd><p>
            A list of profiles used to build this image
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_drivers</span>]</span></dt><dd><p>
            A comma seperated list of the driver entries as listed in the
            drivers section of the <code class="filename">config.xml</code>. Similar variables exists for
            the usbdrivers and scsidrivers sections
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_size</span>]</span></dt><dd><p>
            The predefined size value for this image. This is not the computed
            size but only the optional size value of the preferences section
            in <code class="filename">config.xml</code>
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_compressed</span>]</span></dt><dd><p>
			The value of the compressed attribute set in the type element 
			in config.xml
          </p></dd><dt><span class="term">[<span class="optional">$kiwi_type</span>]</span></dt><dd><p>
            The basic image type. Can be a simply filesystem image type of
            ext2, ext3, reiserfs, squashfs, and cpio or one of the following complex
            image types: iso split usb vmx oem xen pxe
          </p></dd></dl></div></div></div><div class="refentry" title="kiwi::kiwirc"><div class="refentry.separator"><hr></div><a name="ref.kiwi.kiwirc"></a><div class="titlepage"></div><div class="refnamediv"><h2><span class="refentrytitle">kiwi::kiwirc</span></h2><p>KIWI::kiwirc &#8212; Resource file for the Kiwi imaging system</p></div><div class="refsect1" title="Description"><a name="kiwi.kiwirc.description"></a><h2>Description</h2><p>
      The KIWI imaging toolchain supports the use of an optional resource
      file named <code class="filename">.kiwirc</code> located in the users home directory.
    </p><p>
      The file is sourced by a Perl process and thus Perl compatible syntax
      for the supported variable sttings is required.
    </p><div class="example"><a name="id2561578"></a><p class="title"><b>Example A.3. Template for .kiwi.rc</b></p><div class="example-contents"><pre class="screen">$BasePath='/usr/share/kiwi';
$Gzip='bzip2';
$LogServerPort='4455';
$System='/usr/share/kiwi/image';</pre></div></div><br class="example-break"></div><div class="refsect1" title="Supported Resource Settings"><a name="kiwi.kiwirc.settings"></a><h2>Supported Resource Settings</h2><p>
      KIWI recognizes the BasePath, Gzip, LogServerPort, LuksCipher, and 
      System settings in the <code class="filename">.kiwirc</code> file.
    </p><div class="variablelist"><dl><dt><span class="term">[<span class="optional">BasePath</span>]</span></dt><dd><p>
            Path to the location of the KIWI image system components, such as
            modules, tests, image descriptions etc.
          </p><p>
            The default value is <code class="filename">/usr/share/kiwi</code>
          </p></dd><dt><span class="term">[<span class="optional">Gzip</span>]</span></dt><dd><p>
            Specify the compression utility to be used for various compression
            tasks during image generation.
          </p><p>
            The default value is <span class="command"><strong>gzip</strong></span> <code class="option">-9</code>
          </p></dd><dt><span class="term">[<span class="optional">LogServerPort</span>]</span></dt><dd><p>
            Specify a port number for log message queing.
          </p><p>
            The default value is off
          </p></dd><dt><span class="term">[<span class="optional">LuksCipher</span>]</span></dt><dd><p>
            Specify the cipher for the encrypted Luks filesystem.
          </p></dd><dt><span class="term">[<span class="optional">System</span>]</span></dt><dd><p>
            Specify the location of the KIWI system image description.
          </p><p>
            The default value is the value of BasePath concatenated with
            /image.
          </p></dd></dl></div></div></div></div></div></body></html>
