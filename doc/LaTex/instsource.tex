\chapter{Creation of Installation Sources and Products}
\label{chapter:instsrc}
\minitoc


A \textbf{Product} or \textbf{Installation Source} is what you find on an
installation disk or in an online repository. In contrast to a live disk the
media contain plain RPM archives and YaST metadata for installation. Furthermore
there is an installation system and kernel which will be booted from the medium
in case it is a disk. For remote installation sources (e.g. a FTP tree) the user
can download the \textit{initrd} and \textit{kernel} and add a boot menu entry
manually to boot the installation system.

This is described nicely in the openSUSE Wiki\footnote{
\href{http://en.opensuse.org/Network\_Install}{http://en.opensuse.org/Network\_Install}}.


\section{Prerequisites}
\label{sec:prereq}

First of all the installation source creation requires the packages
\textit{kiwi-instsource} and supplementing plugins from the packages
\textit{kiwi-inst\-source-plugins-open\-SU\-SE-<VERSION>-<RELEASE>}.
They are configured to \textit{supplement} the kiwi-inst\-source
package through RPM magic. This means that it may be necessary to subscribe to
multiple repositories if the plugin packages reside elsewhere than the other
kiwi packages. The plugins are packaged in extra packages for two reasons.
First of all, the YaST metadata is no fixed standard but tends to change from
release to release, so the code creating the metadata is version specific.
Finally the concept allows users to make their own
custom plugins for special purposes. This mechanism will be explained in more
detail in \vref{subsec:plugins}.

You need some source directories containing the available RPM files on the very
same harddisk where you want to create the installation sources. The reason for
that is the fact that hard links are used to speed up the installation source
creation. There are plans to integrate support for mixed environments, but those
have been delayed due to more important issues. If you use a \textit{full
tree\footnote{a tree containing only RPM files which have been built using no
other RPMs then those available in the same tree}} be prepared to use 10--10\,GB
per full tree, so if you build installation sources for multiple architectures
this may easily sum up to 120\,GB. I recommend at least a 300\,GB harddisk.

It is possible to use a mounted DVD as ``full tree'', but in that case you have
to get the \textit{meta\-packages} from some other source.


\section{Interface}
\label{sec:interface}

The interface for installation source creation is implemented in two steps. The
first one is an extension of the existing config syntax as described in
\vref{subsec:config-extend}, the second one is the implementation of easily
configurable plugins for the metadata creation as described in
\vref{subsec:plugins}.


\subsection{Configuration File Extension}
\label{subsec:config-extend}

The \textit{config.xml} file now supports a new optional element called
\textbf{instsource}. Its purpose is to specify the things that are significant
for an installation repository:
\begin{itemize}
  \item{metadata}
  \item{media structure}
  \item{additional iso information for disc media}
  \item{package signing keys}
\end{itemize}

Furthermore the installation source needs some information for architectures. It
is easily possible to create an installation DVD that boots on 32\,bit and
64\,bit Intel and also PowerPC architecture. In such a case several conditions
must be met:
\begin{itemize}
  \item{the packages must be available for each architecture}
  \item{the disc must boot on each architecture}
  \item{YaST metadata must be available for each architecture}
\end{itemize}

Additionally multiple boot catalog entries must be made in the iso filesystem.

In the following \vref{lst:configmin} only the element \texttt{inst\-source} is
shown and it is limited to an absolute minimum. A complete list of required
variables is shown in \vref{tab:variables}.
This example shows the basic structure of the extension.

\begin{lstlisting}[language=xml, caption={Installation source extensions},
label={lst:configmin}]
<instsource>
  <architectures>
    <arch id="i386" name="dummy" fallback="noarch" />
    <arch id="noarch" name="dummy" />
    <requiredarch ref="i586" />
  </architectures>
  <productoptions>
    <productvar name="DISTNAME">openSUSE</productvar>

    <productinfo name="CONTENTSTYLE">11</productinfo>

    <productoption name="BETA_VERSION">Alpha 0</productoption>
  </productoptions>
  <instrepo name="repository_1" priority="1" local="true">
    <source path="obs://openSUSE:Factory/standard" />
  </instrepo>
  <metadata>
    <repopackage name="installation-images" medium="0" removearch="src,nosrc" onlyarch="i586," />
  </metadata>
  <repopackages>
    <repopackage name="vim"/>
  </repopackages>
</instsource>
\end{lstlisting}

So basically the \texttt{instsource} section consists of five types of information.

\begin{description}

  \item[architectures]{%

    Contains a list of architectures defining a fallback chain. The specified fallback must be an
    existing id to pass validation. Omitting the optional fallback means ``no fallback''.
  }

  \item[productoptions]{%

    Contains three types of subattributes with different impact.
    An expansion mechanism is implemented allowing sharing information. You can specify VERSION=\dots
    and refer to the content using \texttt{\$VERSION} in the variable's string.
    The syntax is the same for all, and the arguments may contain whitespace.
    \begin{description}
      \item[productvar]{%

	Used for theming metapackages, specifying variables to be used as descibed above and for creating
	the \texttt{media.<n>} files and the \texttt{products} file.
      }
      \item[productoption]{%

	Global settings like debugmedium number and plugin location. No effect on created files but on the structure.
      }
      \item[productinfo]{%

	All tags listed here are put into the \textit{content file\footnote{\href{http://en.opensuse.org/Standards/YaST2\_Repository\_Metadata/media\#The\_content\_file}{http://en.opensuse.org/Standards/YaST2\_Repository\_Metadata/media\#The\_content\_file}}} directly.
      }
    \end{description}
  }

  \item[metadata]{%
    Contains a set of metapackages specified as repopackage. Metapackages are explained in more detail in \vref{sec:metapacks}.
  }

  \item[instrepo]{%
    Specifies a location where packages are taken from. In the most basic form this can be one plain directory containing
    plain rpm files without any naming convention besides \texttt{name.rpm} or \texttt{name.spm}. Of course it is also
    possible to use a mounted DVD. The metadata of that is ignored.
    Any number of repositories can be used. The priority must be unique, smaller number means higher priority. The name attribute
    can be used as reference for the \textit{force\-repo} attribute in the \texttt{repopackage} element. Referring to an undefined
    repo results in validation error.
  }

  \item[repopackages]{%
    Contains a list of \texttt{repopackage} elements. This element can be specified multiple times to reflect groups
    for better readability.
  }

\end{description}



\subsection{Metadata Creation Plugins}
\label{subsec:plugins}

Blah.


\section{Calling Options}
\label{sec:options}

\begin{lstlisting}[language=Bash, caption={Calling kiwi-instsource},
label={lst:instsource-call}]
kiwi --root <rootdir> \
     --instsource-local \
     --create-instsource <configdir>
\end{lstlisting}

The most simple call of kiwi-inst\-source is shown in \vref{lst:instsource-call}.
Hereby \texttt{root\-dir} refers to the base directory where all operations
happen. This directory will be created by kiwi. The config directory
\texttt{con\-fig\-dir} is just the same as in the other kiwi modes, the directory
where the config.xml file resides.

The option \textit{instsource-local}  has been added to distinguish between the
local only mode and the remote repository mode. However, as mentioned in
\vref{sec:prereq} the remote mode is not supported in this version.

There are some more options available, such as the \texttt{-v} switch to
increase verbosity and the logfile option. % as described in (AI Marcus).
During development I typically used something like \vref{lst:instsource-call2}.

\begin{lstlisting}[language=Bash, caption={Typical kiwi-instsource call during
development},
label={lst:instsource-call2}]
kiwi --root 19.01 \
     -vv \
     --logfile terminal \
     --instsource-local \
     --create-instsource \
/space/config/openSUSE\:Factory/_product\:openSUSE-11.2-dvd5-dvd-i586/ \
     | tee 19.01.log
\end{lstlisting}

The logfile option's effect is that all logging output is written to the shell
and can be captured easily using the \texttt{tee} command. For debugging it is
helpful to have a file containing all output for analysis with \texttt{grep} and
to see the output passing for progress.

The switch \texttt{-v} which can be used multiple times increases logging
verbosity but slows progress at the same time. Three or more times prints log
information for each resolved package which is sometimes necessary to identify
problems in the used repositories. For most purposes two times \texttt{-v} is
just fine. In this particular example the DVD5 flavour of openSUSE factory was
built.


\section{Metapackages}
\label{sec:metapacks}

TODO

\section{Directory Layout}

TODO


\section{Logfile Analysis}

TODO


%\section{ISO Generation}



